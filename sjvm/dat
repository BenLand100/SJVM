/* 
 * File:   Arrays.h
 * Author: Benjamin J. Land
 *
 * Created on November 27, 2008, 7:22 PM
 */

#ifndef _ARRAYS_H
#define	_ARRAYS_H

#include <cstring>
#include "Object.h"

template <class T>
class Array : public Object {
    friend class ClassFile;
    
private:
    Array() {
    };
    
protected:
    Array(int size) {
        this->elemsz = sizeof(T);
        this->size = size;
        array = new T[size];
        for (int i = 0; i < size; i++) 
            array[i] = 0;
    };
    
public:
    virtual ~Array() {
        delete [] array;
    };
    Array<T>* clone() {
        Array<T>* res = new Array<T>();
        res->type = type;
        res->elemsz = elemsz;
        res->size = size;
        res->array = (T*) new char[size*elemsz];
        memcpy(res->array,array,size*elemsz);
        return res;
    };
    int elemsz;
    int size;
    T *array;
};

#endif	/* _ARRAYS_H */

/* 
 * File:   AttributeInfo.h
 * Author: Benjamin J. Land
 *
 * Created on November 25, 2008, 7:37 PM
 */

#ifndef _ATTRIBUTEINFO_H
#define	_ATTRIBUTEINFO_H

class AttributeInfo {
public:
    short int nameIndex;
    long int length;
    unsigned char *data;
    
    ~AttributeInfo();
    
    AttributeInfo(unsigned char *data, int &index);
};

#endif	/* _ATTRIBUTEINFO_H */

#ifndef _CLASS_H
#define	_CLASS_H

#include "Types.h"
#include "Object.h"
#include "SJVM.h"

#include <map>
#include <string>
#include <vector>

class SJVM;
class MethodInfo;
class FieldInfo;
class AttributeInfo;
class CPInfo;
class Thread;

class ClassFile : public Object {
    
private:
    friend class ClassLoader;
    
    unsigned short int thisClassIndex;
    unsigned short int superClassIndex;
    unsigned short int interfaceCount;
    unsigned short int *interfaceIndexes;
    unsigned short int fieldCount;
    FieldInfo **fields;
    unsigned short int methodCount;
    MethodInfo **methods;
    unsigned short int attributeCount;
    AttributeInfo **attributes;
    
    
    ClassFile(unsigned char *data);
    ClassFile(char *name, SJVM *jvm);
    int validate(ClassLoader *loader, SJVM *jvm);
    void prepFields(Object *ref);
    
public:
    
    template <class T> static Array<T>* newArray(SJVM* sjvm, char *type, int size) {
        if (*type != '[') return 0;
        Array<T> *ref = new Array<T>(size);
        sjvm->gc->reg(ref);
        ref->type = sjvm->loadClass(type);
        return ref;
    };
    
    unsigned short int instanceFields;
    unsigned short int accessFlags;
    unsigned short int cpCount;
    bool arrayType;
    ClassFile *componentType;
    CPInfo **cp;
    std::string name;
    ClassFile *superClass;
    std::map<std::string,MethodInfo*> methodMap;
    std::map<std::string,FieldInfo*> fieldMap;
    std::map<std::string,ClassFile*> interfaceMap;
  
    std::vector<unsigned int> objectIndexes;
    
    JOBJECT newInstance(SJVM* sjvm);
    JINT instanceOf(Object *ref);
    
    virtual ~ClassFile();
    
};


#endif	/* _CLASS_H */

/* 
 * File:   ClassInfo.h
 * Author: Benjamin J. Land
 *
 * Created on November 25, 2008, 7:45 PM
 */

#ifndef _CLASSINFO_H
#define	_CLASSINFO_H



#endif	/* _CLASSINFO_H */

/* 
 * File:   ClassLoader.h
 * Author: Benjamin J. Land
 *
 * Created on November 26, 2008, 5:34 PM
 */

#ifndef _CLASSLOADER_H
#define	_CLASSLOADER_H

#include <map>
#include <string>
#include <vector>

class ClassPath {
public:
    virtual ~ClassPath() { }
    virtual int request(const char *name, unsigned char *&data) = 0;
    virtual void release(unsigned char *data) = 0;
};

class FolderClassPath : public ClassPath {
private:
    std::string path;
public:
    FolderClassPath(const char* path);
    
    virtual int request(const char *name, unsigned char *&data);
    virtual void release(unsigned char *data);
};

class BootstrapClassPath : public ClassPath {
private:
    std::vector<ClassPath*> paths;
    std::map<unsigned char*, ClassPath*> mapped;
public:
    virtual ~BootstrapClassPath();
    void add(ClassPath* path);
    virtual int request(const char *name, unsigned char *&data);
    virtual void release(unsigned char *data);
};

#include "Thread.h"

class ClassFile;
class SJVM;
class Mutex;

class ClassLoader {
private:
    std::map<std::string,ClassFile*> classes;
    ClassPath *bootstrap;
    Mutex mutex;
public:
    virtual ~ClassLoader();
    ClassLoader(ClassPath *classpath);
    ClassFile* load(const char *name, SJVM *jvm);
};

#endif	/* _CLASSLOADER_H */

/* 
 * File:   CPInfo.h
 * Author: Benjamin J. Land
 *
 * Created on November 25, 2008, 7:37 PM
 */

#ifndef _CPINFO_H
#define	_CPINFO_H

#include <string>

class FieldInfo;
class MethodInfo;
class ClassFile;

class CPInfo {
public:
    const static char CONSTANT_Class = 7;
    const static char CONSTANT_Fieldref = 9;
    const static char CONSTANT_Methodref = 10;
    const static char CONSTANT_InterfaceMethodref = 11;
    const static char CONSTANT_String = 8;
    const static char CONSTANT_Integer = 3;
    const static char CONSTANT_Float = 4;
    const static char CONSTANT_Long = 5;
    const static char CONSTANT_Double = 6;
    const static char CONSTANT_NameAndType = 12;
    const static char CONSTANT_Utf8 = 1;
    
    char type;
    
    static CPInfo* read(unsigned char *data, int &index);
    
    virtual ~CPInfo() { };
    
protected:
    CPInfo(char type);
    
};

class UTF8Info : public CPInfo {
public:
    short int size;
    char *bytes;
    UTF8Info(unsigned char *data, int &index);
    virtual ~UTF8Info();
};

class StringInfo : public CPInfo {
public:
    short int stringIndex;
    StringInfo(unsigned char *data, int &index);
};

class NameAndTypeInfo : public CPInfo {
public:
    short int nameIndex;
    short int descriptorIndex;
    NameAndTypeInfo(unsigned char *data, int &index);
};

class LongDoubleInfo : public CPInfo {
public:
    char data[8];
    LongDoubleInfo(unsigned char *data, int &index);
};

class IntegerFloatInfo : public CPInfo {
public:
    char data[4];
    IntegerFloatInfo(unsigned char *data, int &index);
};

class FieldMethodInfo : public CPInfo {
public:
    short int classIndex;
    short int nameAndTypeIndex;
    FieldInfo* fieldRef;
    MethodInfo* methodRef;
    std::string name;
    FieldMethodInfo(unsigned char *data, int &index);
};

class ClassInfo : public CPInfo {
public:
    short int nameIndex;
    ClassFile *classRef;
    std::string name;
    ClassInfo(unsigned char *data, int &index);
};

#endif	/* _CPINFO_H */

/* 
 * File:   Exception.h
 * Author: Benjamin J. Land
 *
 * Created on December 1, 2008, 5:07 PM
 */

#ifndef _EXCEPTION_H
#define	_EXCEPTION_H

#include "Types.h"

class MethodInfo;
class ClassFile;

class Exception {
public:
    JOBJECT cause;
    Exception* parent; //deleted on delete
    MethodInfo* method;
    ClassFile* clazz;
    
    Exception(ClassFile* clazz, MethodInfo* method, Exception* parent);
    Exception(ClassFile* clazz, MethodInfo* method, JOBJECT cause);
    ~Exception();
            
    JOBJECT getCause();
};

#endif	/* _EXCEPTION_H */

/* 
 * File:   FieldInfo.h
 * Author: Benjamin J. Land
 *
 * Created on November 25, 2008, 7:36 PM
 */

#ifndef _FIELDINFO_H
#define	_FIELDINFO_H

class AttributeInfo;

#include "Types.h"

#include <string>

class FieldInfo {
    friend class ClassFile;
private:
    short int accessFlags;
    short int nameIndex;
    short int descriptorIndex;
    short int attributeCount;
    AttributeInfo **attributes;
    char staticObject;   
    
    FieldInfo(unsigned char *data, int &index);
    
public:
    std::string name;
    std::string descriptor;
    int index; //0 to n stored in object, -1 class field
    Variable staticValue;
    
    ~FieldInfo();
};

#endif	/* _FIELDINFO_H */

/* 
 * File:   FieldMethodInfo.h
 * Author: Benjamin J. Land
 *
 * Created on November 25, 2008, 7:46 PM
 */

#ifndef _FIELDMETHODINFO_H
#define	_FIELDMETHODINFO_H



#endif	/* _FIELDMETHODINFO_H */

/* 
 * File:   GarbageColector.h
 * Author: Benjamin J. Land
 *
 * Created on December 18, 2008, 11:40 AM
 */

#ifndef _GARBAGECOLLECTOR_H
#define	_GARBAGECOLLECTOR_H

#include <set>
#include <map>
#include "Mutex.h"

class Object;
class Thread;
class GlobalGC;

class LocalGC {
    friend class GlobalGC;
private:
    std::set<Object*> roots;
    GlobalGC *parent;
    LocalGC *oldLocal;
    Thread *thread;
public:
    LocalGC(GlobalGC *gc, Thread *thread);
    ~LocalGC();
    void addLocal(Object* object);
    void removeLocal(Object* object); //does not clean, prevents death
};

class GlobalGC {
    friend class LocalGC;
private:
    Mutex mutex;
    std::set<LocalGC*> locals;
    void clean(Object* object);
public:
    std::set<Object*> objects;
    GlobalGC();
    ~GlobalGC();
    void sweep();
    void incrPersist(Object* object);
    void decrPersist(Object* object);
    void incrRef(Object* object);
    void decrRef(Object* object);
    void reg(Object* object);
};

#endif	/* _GARBAGECOLLECTOR_H */

/* 
 * File:   Inflate.h
 * Author: Benjamin J. Land
 *
 * Created on December 4, 2008, 7:28 PM
 */

#ifndef _INFLATE_H
#define	_INFLATE_H

#ifdef __cplusplus
#include <cstring>
extern "C" {
#endif

struct _huft;

typedef struct {
	unsigned char*	slide;
	unsigned 	hufts;		/* track memory usage */
	struct _huft*	fixed_tl;
	struct _huft*	fixed_td;
	int		fixed_bl;
	int		fixed_bd;
	unsigned	wp;		/* current position in slide */
	unsigned int 	bb;		/* bit buffer */
	unsigned	bk;		/* bits in bit buffer */
	unsigned char*	inbuf;
	int		insz;
	unsigned char*	outbuf;
	int		outsz;
} inflateInfo;

inflateInfo* inflate_new(void);
int inflate_free(inflateInfo*);
int inflate_oneshot(unsigned char*, int, unsigned char*, int);

#ifdef __cplusplus
};
#endif

#endif	/* _INFLATE_H */

/* 
 * File:   IntegerFloatInfo.h
 * Author: Benjamin J. Land
 *
 * Created on November 25, 2008, 7:47 PM
 */

#ifndef _INTEGERFLOATINFO_H
#define	_INTEGERFLOATINFO_H



#endif	/* _INTEGERFLOATINFO_H */

/* 
 * File:   Zip.h
 * Author: Benjamin J. Land
 *
 * Created on December 3, 2008, 5:10 PM
 */

#ifndef _ZIP_H
#define	_ZIP_H

#include <string>
#include <map>

class ClassLoader;

#define COMPRESSION_STORED	0
#define COMPRESSION_SHRUNK	1
#define COMPRESSION_REDUCED1	2
#define COMPRESSION_REDUCED2	3
#define COMPRESSION_REDUCED3	4
#define COMPRESSION_REDUCED4	5
#define COMPRESSION_IMPLODED	6
#define COMPRESSION_TOKENIZED	7
#define COMPRESSION_DEFLATED	8

typedef struct {
	unsigned short int bitflags;
	unsigned short int comp_method;
	unsigned long int comp_size;
	unsigned long int uncompr_size;
	unsigned short int fname_len;
	unsigned long int relative_offset;
	char* file_name;
} FileHeader;

#include "ClassLoader.h"

class ClassPath;

class JarFile : public ClassPath {
private:
    std::string path;
    std::map<std::string,FileHeader*> files;
public:
    JarFile(char* fpath);
    virtual ~JarFile();

    std::string getPath();
    virtual int request(const char* name, unsigned char *&data);
    virtual void release(unsigned char *data);
    
private:
    int open();
    void readCentralDirectory(unsigned char * data, long len);
    int readFileHeader(unsigned char * data, FileHeader * hdr);

};

#endif	/* _ZIP_H */

/* 
 * Modified by Benjamin Land for readability. Functionally identical to jni.h 
 * released by Sun Microsystems.
 */
#ifndef _JNI_H
#define	_JNI_H

#include <stdio.h>
#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif
    
    #define JNICALL __attribute__((stdcall))

    typedef long int jint;
    typedef long long jlong;
    typedef signed char jbyte;
    
    typedef unsigned char jboolean;
    typedef unsigned short jchar;
    typedef short jshort;
    typedef float jfloat;
    typedef double jdouble;
    typedef jint jsize;
    
#ifdef __cplusplus

    class _jobject {
    };

    class _jclass : public _jobject {
    };

    class _jthrowable : public _jobject {
    };

    class _jstring : public _jobject {
    };

    class _jarray : public _jobject {
    };

    class _jbooleanArray : public _jarray {
    };

    class _jbyteArray : public _jarray {
    };

    class _jcharArray : public _jarray {
    };

    class _jshortArray : public _jarray {
    };

    class _jintArray : public _jarray {
    };

    class _jlongArray : public _jarray {
    };

    class _jfloatArray : public _jarray {
    };

    class _jdoubleArray : public _jarray {
    };

    class _jobjectArray : public _jarray {
    };
    
    typedef _jobject *jobject;
    typedef _jclass *jclass;
    typedef _jthrowable *jthrowable;
    typedef _jstring *jstring;
    typedef _jarray *jarray;
    typedef _jbooleanArray *jbooleanArray;
    typedef _jbyteArray *jbyteArray;
    typedef _jcharArray *jcharArray;
    typedef _jshortArray *jshortArray;
    typedef _jintArray *jintArray;
    typedef _jlongArray *jlongArray;
    typedef _jfloatArray *jfloatArray;
    typedef _jdoubleArray *jdoubleArray;
    typedef _jobjectArray *jobjectArray;
    
#else
    
    struct _jobject;
    typedef struct _jobject *jobject;
    typedef jobject jclass;
    typedef jobject jthrowable;
    typedef jobject jstring;
    typedef jobject jarray;
    typedef jarray jbooleanArray;
    typedef jarray jbyteArray;
    typedef jarray jcharArray;
    typedef jarray jshortArray;
    typedef jarray jintArray;
    typedef jarray jlongArray;
    typedef jarray jfloatArray;
    typedef jarray jdoubleArray;
    typedef jarray jobjectArray;
    
#endif
    
    typedef jobject jweak;
    typedef jobject jref;

    typedef union jvalue {
        jboolean z;
        jbyte b;
        jchar c;
        jshort s;
        jint i;
        jlong j;
        jfloat f;
        jdouble d;
        jobject l;
    } jvalue;
    
    struct _jfieldID;
    typedef struct _jfieldID *jfieldID;
    
    struct _jmethodID;
    typedef struct _jmethodID *jmethodID;

#define JNI_FALSE 0
#define JNI_TRUE 1
    
#define JNI_OK           0                 /* success */
#define JNI_ERR          (-1)              /* unknown error */
#define JNI_EDETACHED    (-2)              /* thread detached from the VM */
#define JNI_EVERSION     (-3)              /* JNI version error */
#define JNI_ENOMEM       (-4)              /* not enough memory */
#define JNI_EEXIST       (-5)              /* VM already created */
#define JNI_EINVAL       (-6)              /* invalid arguments */
    
#define JNI_COMMIT 1
#define JNI_ABORT 2

    typedef struct {
        char *name;
        char *signature;
        void *fnPtr;
    } JNINativeMethod;
    
    struct JNINativeInterface_;
    struct JNIEnv_;
    
#ifdef __cplusplus
    typedef JNIEnv_ JNIEnv;
#else
    typedef const struct JNINativeInterface_ *JNIEnv;
#endif
    \
    struct JNIInvokeInterface_;
    struct JavaVM_;
    
#ifdef __cplusplus
    typedef JavaVM_ JavaVM;
#else
    typedef const struct JNIInvokeInterface_ *JavaVM;
#endif

    struct JNINativeInterface_ {
        void *reserved0;
        void *reserved1;
        void *reserved2;
        void *reserved3;
        jint(JNICALL * GetVersion)(JNIEnv * env);
        jclass(JNICALL * DefineClass) (JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len);
        jclass(JNICALL * FindClass) (JNIEnv *env, const char *name);
        jmethodID(JNICALL * FromReflectedMethod) (JNIEnv *env, jobject method);
        jfieldID(JNICALL * FromReflectedField) (JNIEnv *env, jobject field);
        jobject(JNICALL * ToReflectedMethod) (JNIEnv *env, jclass cls, jmethodID methodID, jboolean isStatic);
        jclass(JNICALL * GetSuperclass) (JNIEnv *env, jclass sub);
        jboolean(JNICALL * IsAssignableFrom) (JNIEnv *env, jclass sub, jclass sup);
        jobject(JNICALL * ToReflectedField) (JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic);
        jint(JNICALL * Throw) (JNIEnv *env, jthrowable obj);
        jint(JNICALL * ThrowNew) (JNIEnv *env, jclass clazz, const char *msg);
        jthrowable(JNICALL * ExceptionOccurred) (JNIEnv * env);
        void (JNICALL * ExceptionDescribe) (JNIEnv * env);
        void (JNICALL * ExceptionClear) (JNIEnv * env);
        void (JNICALL * FatalError) (JNIEnv *env, const char *msg);
        jint(JNICALL * PushLocalFrame) (JNIEnv *env, jint capacity);
        jobject(JNICALL * PopLocalFrame) (JNIEnv *env, jobject result);
        jobject(JNICALL * NewGlobalRef) (JNIEnv *env, jobject lobj);
        void (JNICALL * DeleteGlobalRef) (JNIEnv *env, jobject gref);
        void (JNICALL * DeleteLocalRef) (JNIEnv *env, jobject obj);
        jboolean(JNICALL * IsSameObject) (JNIEnv *env, jobject obj1, jobject obj2);
        jobject(JNICALL * NewLocalRef) (JNIEnv *env, jobject ref);
        jint(JNICALL * EnsureLocalCapacity) (JNIEnv *env, jint capacity);
        jobject(JNICALL * AllocObject) (JNIEnv *env, jclass clazz);
        jobject(JNICALL * NewObject) (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
        jobject(JNICALL * NewObjectV) (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
        jobject(JNICALL * NewObjectA) (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue * args);
        jclass(JNICALL * GetObjectClass) (JNIEnv *env, jobject obj);
        jboolean(JNICALL * IsInstanceOf) (JNIEnv *env, jobject obj, jclass clazz);
        jmethodID(JNICALL * GetMethodID) (JNIEnv *env, jclass clazz, const char *name, const char *sig);
        jobject(JNICALL * CallObjectMethod) (JNIEnv *env, jobject obj, jmethodID methodID, ...);
        jobject(JNICALL * CallObjectMethodV) (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
        jobject(JNICALL * CallObjectMethodA) (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
        jboolean(JNICALL * CallBooleanMethod) (JNIEnv *env, jobject obj, jmethodID methodID, ...);
        jboolean(JNICALL * CallBooleanMethodV) (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
        jboolean(JNICALL * CallBooleanMethodA) (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
        jbyte(JNICALL * CallByteMethod) (JNIEnv *env, jobject obj, jmethodID methodID, ...);
        jbyte(JNICALL * CallByteMethodV) (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
        jbyte(JNICALL * CallByteMethodA) (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
        jchar(JNICALL * CallCharMethod) (JNIEnv *env, jobject obj, jmethodID methodID, ...);
        jchar(JNICALL * CallCharMethodV) (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
        jchar(JNICALL * CallCharMethodA) (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
        jshort(JNICALL * CallShortMethod) (JNIEnv *env, jobject obj, jmethodID methodID, ...);
        jshort(JNICALL * CallShortMethodV) (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
        jshort(JNICALL * CallShortMethodA) (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
        jint(JNICALL * CallIntMethod) (JNIEnv *env, jobject obj, jmethodID methodID, ...);
        jint(JNICALL * CallIntMethodV) (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
        jint(JNICALL * CallIntMethodA) (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
        jlong(JNICALL * CallLongMethod) (JNIEnv *env, jobject obj, jmethodID methodID, ...);
        jlong(JNICALL * CallLongMethodV) (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
        jlong(JNICALL * CallLongMethodA) (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
        jfloat(JNICALL * CallFloatMethod) (JNIEnv *env, jobject obj, jmethodID methodID, ...);
        jfloat(JNICALL * CallFloatMethodV) (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
        jfloat(JNICALL * CallFloatMethodA) (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
        jdouble(JNICALL * CallDoubleMethod) (JNIEnv *env, jobject obj, jmethodID methodID, ...);
        jdouble(JNICALL * CallDoubleMethodV) (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
        jdouble(JNICALL * CallDoubleMethodA) (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
        void (JNICALL * CallVoidMethod) (JNIEnv *env, jobject obj, jmethodID methodID, ...);
        void (JNICALL * CallVoidMethodV) (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
        void (JNICALL * CallVoidMethodA) (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
        jobject(JNICALL * CallNonvirtualObjectMethod) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
        jobject(JNICALL * CallNonvirtualObjectMethodV) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);
        jobject(JNICALL * CallNonvirtualObjectMethodA) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);
        jboolean(JNICALL * CallNonvirtualBooleanMethod) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
        jboolean(JNICALL * CallNonvirtualBooleanMethodV) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);
        jboolean(JNICALL * CallNonvirtualBooleanMethodA) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);
        jbyte(JNICALL * CallNonvirtualByteMethod) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
        jbyte(JNICALL * CallNonvirtualByteMethodV) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);
        jbyte(JNICALL * CallNonvirtualByteMethodA) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);
        jchar(JNICALL * CallNonvirtualCharMethod) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
        jchar(JNICALL * CallNonvirtualCharMethodV) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);
        jchar(JNICALL * CallNonvirtualCharMethodA) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);
        jshort(JNICALL * CallNonvirtualShortMethod) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
        jshort(JNICALL * CallNonvirtualShortMethodV) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);
        jshort(JNICALL * CallNonvirtualShortMethodA) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);
        jint(JNICALL * CallNonvirtualIntMethod) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
        jint(JNICALL * CallNonvirtualIntMethodV) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);
        jint(JNICALL * CallNonvirtualIntMethodA) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);
        jlong(JNICALL * CallNonvirtualLongMethod) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
        jlong(JNICALL * CallNonvirtualLongMethodV) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);
        jlong(JNICALL * CallNonvirtualLongMethodA) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);
        jfloat(JNICALL * CallNonvirtualFloatMethod) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
        jfloat(JNICALL * CallNonvirtualFloatMethodV) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);
        jfloat(JNICALL * CallNonvirtualFloatMethodA) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);
        jdouble(JNICALL * CallNonvirtualDoubleMethod) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
        jdouble(JNICALL * CallNonvirtualDoubleMethodV) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);
        jdouble(JNICALL * CallNonvirtualDoubleMethodA) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);
        void (JNICALL * CallNonvirtualVoidMethod) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
        void (JNICALL * CallNonvirtualVoidMethodV) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);
        void (JNICALL * CallNonvirtualVoidMethodA) (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue * args);
        jfieldID(JNICALL * GetFieldID) (JNIEnv *env, jclass clazz, const char *name, const char *sig);
        jobject(JNICALL * GetObjectField) (JNIEnv *env, jobject obj, jfieldID fieldID);
        jboolean(JNICALL * GetBooleanField) (JNIEnv *env, jobject obj, jfieldID fieldID);
        jbyte(JNICALL * GetByteField) (JNIEnv *env, jobject obj, jfieldID fieldID);
        jchar(JNICALL * GetCharField) (JNIEnv *env, jobject obj, jfieldID fieldID);
        jshort(JNICALL * GetShortField) (JNIEnv *env, jobject obj, jfieldID fieldID);
        jint(JNICALL * GetIntField) (JNIEnv *env, jobject obj, jfieldID fieldID);
        jlong(JNICALL * GetLongField) (JNIEnv *env, jobject obj, jfieldID fieldID);
        jfloat(JNICALL * GetFloatField) (JNIEnv *env, jobject obj, jfieldID fieldID);
        jdouble(JNICALL * GetDoubleField) (JNIEnv *env, jobject obj, jfieldID fieldID);
        void (JNICALL * SetObjectField) (JNIEnv *env, jobject obj, jfieldID fieldID, jobject val);
        void (JNICALL * SetBooleanField) (JNIEnv *env, jobject obj, jfieldID fieldID, jboolean val);
        void (JNICALL * SetByteField) (JNIEnv *env, jobject obj, jfieldID fieldID, jbyte val);
        void (JNICALL * SetCharField) (JNIEnv *env, jobject obj, jfieldID fieldID, jchar val);
        void (JNICALL * SetShortField) (JNIEnv *env, jobject obj, jfieldID fieldID, jshort val);
        void (JNICALL * SetIntField) (JNIEnv *env, jobject obj, jfieldID fieldID, jint val);
        void (JNICALL * SetLongField) (JNIEnv *env, jobject obj, jfieldID fieldID, jlong val);
        void (JNICALL * SetFloatField) (JNIEnv *env, jobject obj, jfieldID fieldID, jfloat val);
        void (JNICALL * SetDoubleField) (JNIEnv *env, jobject obj, jfieldID fieldID, jdouble val);
        jmethodID(JNICALL * GetStaticMethodID) (JNIEnv *env, jclass clazz, const char *name, const char *sig);
        jobject(JNICALL * CallStaticObjectMethod) (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
        jobject(JNICALL * CallStaticObjectMethodV) (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
        jobject(JNICALL * CallStaticObjectMethodA) (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue * args);
        jboolean(JNICALL * CallStaticBooleanMethod) (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
        jboolean(JNICALL * CallStaticBooleanMethodV) (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
        jboolean(JNICALL * CallStaticBooleanMethodA) (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue * args);
        jbyte(JNICALL * CallStaticByteMethod) (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
        jbyte(JNICALL * CallStaticByteMethodV) (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
        jbyte(JNICALL * CallStaticByteMethodA) (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue * args);
        jchar(JNICALL * CallStaticCharMethod) (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
        jchar(JNICALL * CallStaticCharMethodV) (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
        jchar(JNICALL * CallStaticCharMethodA) (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue * args);
        jshort(JNICALL * CallStaticShortMethod) (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
        jshort(JNICALL * CallStaticShortMethodV) (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
        jshort(JNICALL * CallStaticShortMethodA) (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue * args);
        jint(JNICALL * CallStaticIntMethod) (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
        jint(JNICALL * CallStaticIntMethodV) (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
        jint(JNICALL * CallStaticIntMethodA) (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue * args);
        jlong(JNICALL * CallStaticLongMethod) (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
        jlong(JNICALL * CallStaticLongMethodV) (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
        jlong(JNICALL * CallStaticLongMethodA) (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue * args);
        jfloat(JNICALL * CallStaticFloatMethod) (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
        jfloat(JNICALL * CallStaticFloatMethodV) (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
        jfloat(JNICALL * CallStaticFloatMethodA) (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue * args);
        jdouble(JNICALL * CallStaticDoubleMethod) (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
        jdouble(JNICALL * CallStaticDoubleMethodV) (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
        jdouble(JNICALL * CallStaticDoubleMethodA) (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue * args);
        void (JNICALL * CallStaticVoidMethod) (JNIEnv *env, jclass cls, jmethodID methodID, ...);
        void (JNICALL * CallStaticVoidMethodV) (JNIEnv *env, jclass cls, jmethodID methodID, va_list args);
        void (JNICALL * CallStaticVoidMethodA) (JNIEnv *env, jclass cls, jmethodID methodID, const jvalue * args);
        jfieldID(JNICALL * GetStaticFieldID) (JNIEnv *env, jclass clazz, const char *name, const char *sig);
        jobject(JNICALL * GetStaticObjectField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
        jboolean(JNICALL * GetStaticBooleanField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
        jbyte(JNICALL * GetStaticByteField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
        jchar(JNICALL * GetStaticCharField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
        jshort(JNICALL * GetStaticShortField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
        jint(JNICALL * GetStaticIntField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
        jlong(JNICALL * GetStaticLongField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
        jfloat(JNICALL * GetStaticFloatField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
        jdouble(JNICALL * GetStaticDoubleField) (JNIEnv *env, jclass clazz, jfieldID fieldID);
        void (JNICALL * SetStaticObjectField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value);
        void (JNICALL * SetStaticBooleanField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jboolean value);
        void (JNICALL * SetStaticByteField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jbyte value);
        void (JNICALL * SetStaticCharField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jchar value);
        void (JNICALL * SetStaticShortField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jshort value);
        void (JNICALL * SetStaticIntField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jint value);
        void (JNICALL * SetStaticLongField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jlong value);
        void (JNICALL * SetStaticFloatField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jfloat value);
        void (JNICALL * SetStaticDoubleField) (JNIEnv *env, jclass clazz, jfieldID fieldID, jdouble value);
        jstring(JNICALL * NewString) (JNIEnv *env, const jchar *unicode, jsize len);
        jsize(JNICALL * GetStringLength) (JNIEnv *env, jstring str);
        const jchar * (JNICALL * GetStringChars) (JNIEnv *env, jstring str, jboolean * isCopy);
        void (JNICALL * ReleaseStringChars) (JNIEnv *env, jstring str, const jchar * chars);
        jstring(JNICALL * NewStringUTF) (JNIEnv *env, const char *utf);
        jsize(JNICALL * GetStringUTFLength) (JNIEnv *env, jstring str);
        const char* (JNICALL * GetStringUTFChars) (JNIEnv *env, jstring str, jboolean * isCopy);
        void (JNICALL * ReleaseStringUTFChars) (JNIEnv *env, jstring str, const char* chars);
        jsize(JNICALL * GetArrayLength) (JNIEnv *env, jarray array);
        jobjectArray(JNICALL * NewObjectArray) (JNIEnv *env, jsize len, jclass clazz, jobject init);
        jobject(JNICALL * GetObjectArrayElement) (JNIEnv *env, jobjectArray array, jsize index);
        void (JNICALL * SetObjectArrayElement) (JNIEnv *env, jobjectArray array, jsize index, jobject val);
        jbooleanArray(JNICALL * NewBooleanArray) (JNIEnv *env, jsize len);
        jbyteArray(JNICALL * NewByteArray) (JNIEnv *env, jsize len);
        jcharArray(JNICALL * NewCharArray) (JNIEnv *env, jsize len);
        jshortArray(JNICALL * NewShortArray) (JNIEnv *env, jsize len);
        jintArray(JNICALL * NewIntArray) (JNIEnv *env, jsize len);
        jlongArray(JNICALL * NewLongArray) (JNIEnv *env, jsize len);
        jfloatArray(JNICALL * NewFloatArray) (JNIEnv *env, jsize len);
        jdoubleArray(JNICALL * NewDoubleArray) (JNIEnv *env, jsize len);
        jboolean * (JNICALL * GetBooleanArrayElements) (JNIEnv *env, jbooleanArray array, jboolean * isCopy);
        jbyte * (JNICALL * GetByteArrayElements) (JNIEnv *env, jbyteArray array, jboolean * isCopy);
        jchar * (JNICALL * GetCharArrayElements) (JNIEnv *env, jcharArray array, jboolean * isCopy);
        jshort * (JNICALL * GetShortArrayElements) (JNIEnv *env, jshortArray array, jboolean * isCopy);
        jint * (JNICALL * GetIntArrayElements) (JNIEnv *env, jintArray array, jboolean * isCopy);
        jlong * (JNICALL * GetLongArrayElements) (JNIEnv *env, jlongArray array, jboolean * isCopy);
        jfloat * (JNICALL * GetFloatArrayElements) (JNIEnv *env, jfloatArray array, jboolean * isCopy);
        jdouble * (JNICALL * GetDoubleArrayElements) (JNIEnv *env, jdoubleArray array, jboolean * isCopy);
        void (JNICALL * ReleaseBooleanArrayElements) (JNIEnv *env, jbooleanArray array, jboolean *elems, jint mode);
        void (JNICALL * ReleaseByteArrayElements) (JNIEnv *env, jbyteArray array, jbyte *elems, jint mode);
        void (JNICALL * ReleaseCharArrayElements) (JNIEnv *env, jcharArray array, jchar *elems, jint mode);
        void (JNICALL * ReleaseShortArrayElements) (JNIEnv *env, jshortArray array, jshort *elems, jint mode);
        void (JNICALL * ReleaseIntArrayElements) (JNIEnv *env, jintArray array, jint *elems, jint mode);
        void (JNICALL * ReleaseLongArrayElements) (JNIEnv *env, jlongArray array, jlong *elems, jint mode);
        void (JNICALL * ReleaseFloatArrayElements) (JNIEnv *env, jfloatArray array, jfloat *elems, jint mode);
        void (JNICALL * ReleaseDoubleArrayElements) (JNIEnv *env, jdoubleArray array, jdouble *elems, jint mode);
        void (JNICALL * GetBooleanArrayRegion) (JNIEnv *env, jbooleanArray array, jsize start, jsize l, jboolean * buf);
        void (JNICALL * GetByteArrayRegion) (JNIEnv *env, jbyteArray array, jsize start, jsize len, jbyte * buf);
        void (JNICALL * GetCharArrayRegion) (JNIEnv *env, jcharArray array, jsize start, jsize len, jchar * buf);
        void (JNICALL * GetShortArrayRegion) (JNIEnv *env, jshortArray array, jsize start, jsize len, jshort * buf);
        void (JNICALL * GetIntArrayRegion) (JNIEnv *env, jintArray array, jsize start, jsize len, jint * buf);
        void (JNICALL * GetLongArrayRegion) (JNIEnv *env, jlongArray array, jsize start, jsize len, jlong * buf);
        void (JNICALL * GetFloatArrayRegion) (JNIEnv *env, jfloatArray array, jsize start, jsize len, jfloat * buf);
        void (JNICALL * GetDoubleArrayRegion) (JNIEnv *env, jdoubleArray array, jsize start, jsize len, jdouble * buf);
        void (JNICALL * SetBooleanArrayRegion) (JNIEnv *env, jbooleanArray array, jsize start, jsize l, const jboolean * buf);
        void (JNICALL * SetByteArrayRegion) (JNIEnv *env, jbyteArray array, jsize start, jsize len, const jbyte * buf);
        void (JNICALL * SetCharArrayRegion) (JNIEnv *env, jcharArray array, jsize start, jsize len, const jchar * buf);
        void (JNICALL * SetShortArrayRegion) (JNIEnv *env, jshortArray array, jsize start, jsize len, const jshort * buf);
        void (JNICALL * SetIntArrayRegion) (JNIEnv *env, jintArray array, jsize start, jsize len, const jint * buf);
        void (JNICALL * SetLongArrayRegion) (JNIEnv *env, jlongArray array, jsize start, jsize len, const jlong * buf);
        void (JNICALL * SetFloatArrayRegion) (JNIEnv *env, jfloatArray array, jsize start, jsize len, const jfloat * buf);
        void (JNICALL * SetDoubleArrayRegion) (JNIEnv *env, jdoubleArray array, jsize start, jsize len, const jdouble * buf);
        jint(JNICALL * RegisterNatives) (JNIEnv *env, jclass clazz, const JNINativeMethod *methods, jint nMethods);
        jint(JNICALL * UnregisterNatives) (JNIEnv *env, jclass clazz);
        jint(JNICALL * MonitorEnter) (JNIEnv *env, jobject obj);
        jint(JNICALL * MonitorExit) (JNIEnv *env, jobject obj);
        jint(JNICALL * GetJavaVM) (JNIEnv *env, JavaVM **vm);
        void (JNICALL * GetStringRegion) (JNIEnv *env, jstring str, jsize start, jsize len, jchar * buf);
        void (JNICALL * GetStringUTFRegion) (JNIEnv *env, jstring str, jsize start, jsize len, char *buf);
        void * (JNICALL * GetPrimitiveArrayCritical) (JNIEnv *env, jarray array, jboolean * isCopy);
        void (JNICALL * ReleasePrimitiveArrayCritical) (JNIEnv *env, jarray array, void *carray, jint mode);
        const jchar * (JNICALL * GetStringCritical) (JNIEnv *env, jstring string, jboolean * isCopy);
        void (JNICALL * ReleaseStringCritical) (JNIEnv *env, jstring string, const jchar * cstring);
        jweak(JNICALL * NewWeakGlobalRef) (JNIEnv *env, jobject obj);
        void (JNICALL * DeleteWeakGlobalRef) (JNIEnv *env, jweak ref);
        jboolean(JNICALL * ExceptionCheck) (JNIEnv * env);
        jobject(JNICALL * NewDirectByteBuffer) (JNIEnv* env, void* address, jlong capacity);
        void* (JNICALL * GetDirectBufferAddress) (JNIEnv* env, jobject buf);
        jlong(JNICALL * GetDirectBufferCapacity) (JNIEnv* env, jobject buf);
    };

    struct JNIEnv_ {
        const struct JNINativeInterface_ *functions;
        
#ifdef __cplusplus

        jint GetVersion() {
            return functions->GetVersion(this);
        }

        jclass DefineClass(const char *name, jobject loader, const jbyte *buf, jsize len) {
            return functions->DefineClass(this, name, loader, buf, len);
        }

        jclass FindClass(const char *name) {
            return functions->FindClass(this, name);
        }

        jmethodID FromReflectedMethod(jobject method) {
            return functions->FromReflectedMethod(this, method);
        }

        jfieldID FromReflectedField(jobject field) {
            return functions->FromReflectedField(this, field);
        }

        jobject ToReflectedMethod(jclass cls, jmethodID methodID, jboolean isStatic) {
            return functions->ToReflectedMethod(this, cls, methodID, isStatic);
        }

        jclass GetSuperclass(jclass sub) {
            return functions->GetSuperclass(this, sub);
        }

        jboolean IsAssignableFrom(jclass sub, jclass sup) {
            return functions->IsAssignableFrom(this, sub, sup);
        }

        jobject ToReflectedField(jclass cls, jfieldID fieldID, jboolean isStatic) {
            return functions->ToReflectedField(this, cls, fieldID, isStatic);
        }

        jint Throw(jthrowable obj) {
            return functions->Throw(this, obj);
        }

        jint ThrowNew(jclass clazz, const char *msg) {
            return functions->ThrowNew(this, clazz, msg);
        }

        jthrowable ExceptionOccurred() {
            return functions->ExceptionOccurred(this);
        }

        void ExceptionDescribe() {
            functions->ExceptionDescribe(this);
        }

        void ExceptionClear() {
            functions->ExceptionClear(this);
        }

        void FatalError(const char *msg) {
            functions->FatalError(this, msg);
        }

        jint PushLocalFrame(jint capacity) {
            return functions->PushLocalFrame(this, capacity);
        }

        jobject PopLocalFrame(jobject result) {
            return functions->PopLocalFrame(this, result);
        }

        jobject NewGlobalRef(jobject lobj) {
            return functions->NewGlobalRef(this, lobj);
        }

        void DeleteGlobalRef(jobject gref) {
            functions->DeleteGlobalRef(this, gref);
        }

        void DeleteLocalRef(jobject obj) {
            functions->DeleteLocalRef(this, obj);
        }

        jboolean IsSameObject(jobject obj1, jobject obj2) {
            return functions->IsSameObject(this, obj1, obj2);
        }

        jobject NewLocalRef(jobject ref) {
            return functions->NewLocalRef(this, ref);
        }

        jint EnsureLocalCapacity(jint capacity) {
            return functions->EnsureLocalCapacity(this, capacity);
        }

        jobject AllocObject(jclass clazz) {
            return functions->AllocObject(this, clazz);
        }

        jobject NewObject(jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jobject result;
            va_start(args, methodID);
            result = functions->NewObjectV(this, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jobject NewObjectV(jclass clazz, jmethodID methodID, va_list args) {
            return functions->NewObjectV(this, clazz, methodID, args);
        }

        jobject NewObjectA(jclass clazz, jmethodID methodID, const jvalue * args) {
            return functions->NewObjectA(this, clazz, methodID, args);
        }

        jclass GetObjectClass(jobject obj) {
            return functions->GetObjectClass(this, obj);
        }

        jboolean IsInstanceOf(jobject obj, jclass clazz) {
            return functions->IsInstanceOf(this, obj, clazz);
        }

        jmethodID GetMethodID(jclass clazz, const char *name, const char *sig) {
            return functions->GetMethodID(this, clazz, name, sig);
        }

        jobject CallObjectMethod(jobject obj, jmethodID methodID, ...) {
            va_list args;
            jobject result;
            va_start(args, methodID);
            result = functions->CallObjectMethodV(this, obj, methodID, args);
            va_end(args);
            return result;
        }

        jobject CallObjectMethodV(jobject obj, jmethodID methodID, va_list args) {
            return functions->CallObjectMethodV(this, obj, methodID, args);
        }

        jobject CallObjectMethodA(jobject obj, jmethodID methodID, const jvalue * args) {
            return functions->CallObjectMethodA(this, obj, methodID, args);
        }

        jboolean CallBooleanMethod(jobject obj, jmethodID methodID, ...) {
            va_list args;
            jboolean result;
            va_start(args, methodID);
            result = functions->CallBooleanMethodV(this, obj, methodID, args);
            va_end(args);
            return result;
        }

        jboolean CallBooleanMethodV(jobject obj, jmethodID methodID, va_list args) {
            return functions->CallBooleanMethodV(this, obj, methodID, args);
        }

        jboolean CallBooleanMethodA(jobject obj, jmethodID methodID, const jvalue * args) {
            return functions->CallBooleanMethodA(this, obj, methodID, args);
        }

        jbyte CallByteMethod(jobject obj, jmethodID methodID, ...) {
            va_list args;
            jbyte result;
            va_start(args, methodID);
            result = functions->CallByteMethodV(this, obj, methodID, args);
            va_end(args);
            return result;
        }

        jbyte CallByteMethodV(jobject obj, jmethodID methodID, va_list args) {
            return functions->CallByteMethodV(this, obj, methodID, args);
        }

        jbyte CallByteMethodA(jobject obj, jmethodID methodID, const jvalue * args) {
            return functions->CallByteMethodA(this, obj, methodID, args);
        }

        jchar CallCharMethod(jobject obj, jmethodID methodID, ...) {
            va_list args;
            jchar result;
            va_start(args, methodID);
            result = functions->CallCharMethodV(this, obj, methodID, args);
            va_end(args);
            return result;
        }

        jchar CallCharMethodV(jobject obj, jmethodID methodID, va_list args) {
            return functions->CallCharMethodV(this, obj, methodID, args);
        }

        jchar CallCharMethodA(jobject obj, jmethodID methodID, const jvalue * args) {
            return functions->CallCharMethodA(this, obj, methodID, args);
        }

        jshort CallShortMethod(jobject obj, jmethodID methodID, ...) {
            va_list args;
            jshort result;
            va_start(args, methodID);
            result = functions->CallShortMethodV(this, obj, methodID, args);
            va_end(args);
            return result;
        }

        jshort CallShortMethodV(jobject obj, jmethodID methodID, va_list args) {
            return functions->CallShortMethodV(this, obj, methodID, args);
        }

        jshort CallShortMethodA(jobject obj, jmethodID methodID, const jvalue * args) {
            return functions->CallShortMethodA(this, obj, methodID, args);
        }

        jint CallIntMethod(jobject obj, jmethodID methodID, ...) {
            va_list args;
            jint result;
            va_start(args, methodID);
            result = functions->CallIntMethodV(this, obj, methodID, args);
            va_end(args);
            return result;
        }

        jint CallIntMethodV(jobject obj, jmethodID methodID, va_list args) {
            return functions->CallIntMethodV(this, obj, methodID, args);
        }

        jint CallIntMethodA(jobject obj, jmethodID methodID, const jvalue * args) {
            return functions->CallIntMethodA(this, obj, methodID, args);
        }

        jlong CallLongMethod(jobject obj, jmethodID methodID, ...) {
            va_list args;
            jlong result;
            va_start(args, methodID);
            result = functions->CallLongMethodV(this, obj, methodID, args);
            va_end(args);
            return result;
        }

        jlong CallLongMethodV(jobject obj, jmethodID methodID, va_list args) {
            return functions->CallLongMethodV(this, obj, methodID, args);
        }

        jlong CallLongMethodA(jobject obj, jmethodID methodID, const jvalue * args) {
            return functions->CallLongMethodA(this, obj, methodID, args);
        }

        jfloat CallFloatMethod(jobject obj, jmethodID methodID, ...) {
            va_list args;
            jfloat result;
            va_start(args, methodID);
            result = functions->CallFloatMethodV(this, obj, methodID, args);
            va_end(args);
            return result;
        }

        jfloat CallFloatMethodV(jobject obj, jmethodID methodID, va_list args) {
            return functions->CallFloatMethodV(this, obj, methodID, args);
        }

        jfloat CallFloatMethodA(jobject obj, jmethodID methodID, const jvalue * args) {
            return functions->CallFloatMethodA(this, obj, methodID, args);
        }

        jdouble CallDoubleMethod(jobject obj, jmethodID methodID, ...) {
            va_list args;
            jdouble result;
            va_start(args, methodID);
            result = functions->CallDoubleMethodV(this, obj, methodID, args);
            va_end(args);
            return result;
        }

        jdouble CallDoubleMethodV(jobject obj, jmethodID methodID, va_list args) {
            return functions->CallDoubleMethodV(this, obj, methodID, args);
        }

        jdouble CallDoubleMethodA(jobject obj, jmethodID methodID, const jvalue * args) {
            return functions->CallDoubleMethodA(this, obj, methodID, args);
        }

        void CallVoidMethod(jobject obj, jmethodID methodID, ...) {
            va_list args;
            va_start(args, methodID);
            functions->CallVoidMethodV(this, obj, methodID, args);
            va_end(args);
        }

        void CallVoidMethodV(jobject obj, jmethodID methodID, va_list args) {
            functions->CallVoidMethodV(this, obj, methodID, args);
        }

        void CallVoidMethodA(jobject obj, jmethodID methodID, const jvalue * args) {
            functions->CallVoidMethodA(this, obj, methodID, args);
        }

        jobject CallNonvirtualObjectMethod(jobject obj, jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jobject result;
            va_start(args, methodID);
            result = functions->CallNonvirtualObjectMethodV(this, obj, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jobject CallNonvirtualObjectMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args) {
            return functions->CallNonvirtualObjectMethodV(this, obj, clazz, methodID, args);
        }

        jobject CallNonvirtualObjectMethodA(jobject obj, jclass clazz, jmethodID methodID, const jvalue * args) {
            return functions->CallNonvirtualObjectMethodA(this, obj, clazz, methodID, args);
        }

        jboolean CallNonvirtualBooleanMethod(jobject obj, jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jboolean result;
            va_start(args, methodID);
            result = functions->CallNonvirtualBooleanMethodV(this, obj, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jboolean CallNonvirtualBooleanMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args) {
            return functions->CallNonvirtualBooleanMethodV(this, obj, clazz, methodID, args);
        }

        jboolean CallNonvirtualBooleanMethodA(jobject obj, jclass clazz, jmethodID methodID, const jvalue * args) {
            return functions->CallNonvirtualBooleanMethodA(this, obj, clazz, methodID, args);
        }

        jbyte CallNonvirtualByteMethod(jobject obj, jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jbyte result;
            va_start(args, methodID);
            result = functions->CallNonvirtualByteMethodV(this, obj, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jbyte CallNonvirtualByteMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args) {
            return functions->CallNonvirtualByteMethodV(this, obj, clazz, methodID, args);
        }

        jbyte CallNonvirtualByteMethodA(jobject obj, jclass clazz, jmethodID methodID, const jvalue * args) {
            return functions->CallNonvirtualByteMethodA(this, obj, clazz, methodID, args);
        }

        jchar CallNonvirtualCharMethod(jobject obj, jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jchar result;
            va_start(args, methodID);
            result = functions->CallNonvirtualCharMethodV(this, obj, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jchar CallNonvirtualCharMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args) {
            return functions->CallNonvirtualCharMethodV(this, obj, clazz, methodID, args);
        }

        jchar CallNonvirtualCharMethodA(jobject obj, jclass clazz, jmethodID methodID, const jvalue * args) {
            return functions->CallNonvirtualCharMethodA(this, obj, clazz, methodID, args);
        }

        jshort CallNonvirtualShortMethod(jobject obj, jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jshort result;
            va_start(args, methodID);
            result = functions->CallNonvirtualShortMethodV(this, obj, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jshort CallNonvirtualShortMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args) {
            return functions->CallNonvirtualShortMethodV(this, obj, clazz, methodID, args);
        }

        jshort CallNonvirtualShortMethodA(jobject obj, jclass clazz, jmethodID methodID, const jvalue * args) {
            return functions->CallNonvirtualShortMethodA(this, obj, clazz, methodID, args);
        }

        jint CallNonvirtualIntMethod(jobject obj, jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jint result;
            va_start(args, methodID);
            result = functions->CallNonvirtualIntMethodV(this, obj, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jint CallNonvirtualIntMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args) {
            return functions->CallNonvirtualIntMethodV(this, obj, clazz, methodID, args);
        }

        jint CallNonvirtualIntMethodA(jobject obj, jclass clazz, jmethodID methodID, const jvalue * args) {
            return functions->CallNonvirtualIntMethodA(this, obj, clazz, methodID, args);
        }

        jlong CallNonvirtualLongMethod(jobject obj, jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jlong result;
            va_start(args, methodID);
            result = functions->CallNonvirtualLongMethodV(this, obj, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jlong CallNonvirtualLongMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args) {
            return functions->CallNonvirtualLongMethodV(this, obj, clazz, methodID, args);
        }

        jlong CallNonvirtualLongMethodA(jobject obj, jclass clazz, jmethodID methodID, const jvalue * args) {
            return functions->CallNonvirtualLongMethodA(this, obj, clazz, methodID, args);
        }

        jfloat CallNonvirtualFloatMethod(jobject obj, jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jfloat result;
            va_start(args, methodID);
            result = functions->CallNonvirtualFloatMethodV(this, obj, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jfloat CallNonvirtualFloatMethodV(jobject obj, jclass clazz,
                jmethodID methodID, va_list args) {
            return functions->CallNonvirtualFloatMethodV(this, obj, clazz, methodID, args);
        }

        jfloat CallNonvirtualFloatMethodA(jobject obj, jclass clazz,
                jmethodID methodID, const jvalue * args) {
            return functions->CallNonvirtualFloatMethodA(this, obj, clazz, methodID, args);
        }

        jdouble CallNonvirtualDoubleMethod(jobject obj, jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jdouble result;
            va_start(args, methodID);
            result = functions->CallNonvirtualDoubleMethodV(this, obj, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jdouble CallNonvirtualDoubleMethodV(jobject obj, jclass clazz,
                jmethodID methodID, va_list args) {
            return functions->CallNonvirtualDoubleMethodV(this, obj, clazz, methodID, args);
        }

        jdouble CallNonvirtualDoubleMethodA(jobject obj, jclass clazz,
                jmethodID methodID, const jvalue * args) {
            return functions->CallNonvirtualDoubleMethodA(this, obj, clazz, methodID, args);
        }

        void CallNonvirtualVoidMethod(jobject obj, jclass clazz, jmethodID methodID, ...) {
            va_list args;
            va_start(args, methodID);
            functions->CallNonvirtualVoidMethodV(this, obj, clazz, methodID, args);
            va_end(args);
        }

        void CallNonvirtualVoidMethodV(jobject obj, jclass clazz,
                jmethodID methodID, va_list args) {
            functions->CallNonvirtualVoidMethodV(this, obj, clazz, methodID, args);
        }

        void CallNonvirtualVoidMethodA(jobject obj, jclass clazz,
                jmethodID methodID, const jvalue * args) {
            functions->CallNonvirtualVoidMethodA(this, obj, clazz, methodID, args);
        }

        jfieldID GetFieldID(jclass clazz, const char *name, const char *sig) {
            return functions->GetFieldID(this, clazz, name, sig);
        }

        jobject GetObjectField(jobject obj, jfieldID fieldID) {
            return functions->GetObjectField(this, obj, fieldID);
        }

        jboolean GetBooleanField(jobject obj, jfieldID fieldID) {
            return functions->GetBooleanField(this, obj, fieldID);
        }

        jbyte GetByteField(jobject obj, jfieldID fieldID) {
            return functions->GetByteField(this, obj, fieldID);
        }

        jchar GetCharField(jobject obj, jfieldID fieldID) {
            return functions->GetCharField(this, obj, fieldID);
        }

        jshort GetShortField(jobject obj, jfieldID fieldID) {
            return functions->GetShortField(this, obj, fieldID);
        }

        jint GetIntField(jobject obj, jfieldID fieldID) {
            return functions->GetIntField(this, obj, fieldID);
        }

        jlong GetLongField(jobject obj, jfieldID fieldID) {
            return functions->GetLongField(this, obj, fieldID);
        }

        jfloat GetFloatField(jobject obj, jfieldID fieldID) {
            return functions->GetFloatField(this, obj, fieldID);
        }

        jdouble GetDoubleField(jobject obj, jfieldID fieldID) {
            return functions->GetDoubleField(this, obj, fieldID);
        }

        void SetObjectField(jobject obj, jfieldID fieldID, jobject val) {
            functions->SetObjectField(this, obj, fieldID, val);
        }

        void SetBooleanField(jobject obj, jfieldID fieldID, jboolean val) {
            functions->SetBooleanField(this, obj, fieldID, val);
        }

        void SetByteField(jobject obj, jfieldID fieldID, jbyte val) {
            functions->SetByteField(this, obj, fieldID, val);
        }

        void SetCharField(jobject obj, jfieldID fieldID, jchar val) {
            functions->SetCharField(this, obj, fieldID, val);
        }

        void SetShortField(jobject obj, jfieldID fieldID, jshort val) {
            functions->SetShortField(this, obj, fieldID, val);
        }

        void SetIntField(jobject obj, jfieldID fieldID, jint val) {
            functions->SetIntField(this, obj, fieldID, val);
        }

        void SetLongField(jobject obj, jfieldID fieldID, jlong val) {
            functions->SetLongField(this, obj, fieldID, val);
        }

        void SetFloatField(jobject obj, jfieldID fieldID, jfloat val) {
            functions->SetFloatField(this, obj, fieldID, val);
        }

        void SetDoubleField(jobject obj, jfieldID fieldID, jdouble val) {
            functions->SetDoubleField(this, obj, fieldID, val);
        }

        jmethodID GetStaticMethodID(jclass clazz, const char *name, const char *sig) {
            return functions->GetStaticMethodID(this, clazz, name, sig);
        }

        jobject CallStaticObjectMethod(jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jobject result;
            va_start(args, methodID);
            result = functions->CallStaticObjectMethodV(this, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jobject CallStaticObjectMethodV(jclass clazz, jmethodID methodID, va_list args) {
            return functions->CallStaticObjectMethodV(this, clazz, methodID, args);
        }

        jobject CallStaticObjectMethodA(jclass clazz, jmethodID methodID, const jvalue * args) {
            return functions->CallStaticObjectMethodA(this, clazz, methodID, args);
        }

        jboolean CallStaticBooleanMethod(jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jboolean result;
            va_start(args, methodID);
            result = functions->CallStaticBooleanMethodV(this, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jboolean CallStaticBooleanMethodV(jclass clazz, jmethodID methodID, va_list args) {
            return functions->CallStaticBooleanMethodV(this, clazz, methodID, args);
        }

        jboolean CallStaticBooleanMethodA(jclass clazz, jmethodID methodID, const jvalue * args) {
            return functions->CallStaticBooleanMethodA(this, clazz, methodID, args);
        }

        jbyte CallStaticByteMethod(jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jbyte result;
            va_start(args, methodID);
            result = functions->CallStaticByteMethodV(this, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jbyte CallStaticByteMethodV(jclass clazz, jmethodID methodID, va_list args) {
            return functions->CallStaticByteMethodV(this, clazz, methodID, args);
        }

        jbyte CallStaticByteMethodA(jclass clazz, jmethodID methodID, const jvalue * args) {
            return functions->CallStaticByteMethodA(this, clazz, methodID, args);
        }

        jchar CallStaticCharMethod(jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jchar result;
            va_start(args, methodID);
            result = functions->CallStaticCharMethodV(this, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jchar CallStaticCharMethodV(jclass clazz, jmethodID methodID, va_list args) {
            return functions->CallStaticCharMethodV(this, clazz, methodID, args);
        }

        jchar CallStaticCharMethodA(jclass clazz, jmethodID methodID, const jvalue * args) {
            return functions->CallStaticCharMethodA(this, clazz, methodID, args);
        }

        jshort CallStaticShortMethod(jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jshort result;
            va_start(args, methodID);
            result = functions->CallStaticShortMethodV(this, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jshort CallStaticShortMethodV(jclass clazz, jmethodID methodID, va_list args) {
            return functions->CallStaticShortMethodV(this, clazz, methodID, args);
        }

        jshort CallStaticShortMethodA(jclass clazz, jmethodID methodID, const jvalue * args) {
            return functions->CallStaticShortMethodA(this, clazz, methodID, args);
        }

        jint CallStaticIntMethod(jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jint result;
            va_start(args, methodID);
            result = functions->CallStaticIntMethodV(this, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jint CallStaticIntMethodV(jclass clazz, jmethodID methodID, va_list args) {
            return functions->CallStaticIntMethodV(this, clazz, methodID, args);
        }

        jint CallStaticIntMethodA(jclass clazz, jmethodID methodID, const jvalue * args) {
            return functions->CallStaticIntMethodA(this, clazz, methodID, args);
        }

        jlong CallStaticLongMethod(jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jlong result;
            va_start(args, methodID);
            result = functions->CallStaticLongMethodV(this, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jlong CallStaticLongMethodV(jclass clazz, jmethodID methodID, va_list args) {
            return functions->CallStaticLongMethodV(this, clazz, methodID, args);
        }

        jlong CallStaticLongMethodA(jclass clazz, jmethodID methodID, const jvalue * args) {
            return functions->CallStaticLongMethodA(this, clazz, methodID, args);
        }

        jfloat CallStaticFloatMethod(jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jfloat result;
            va_start(args, methodID);
            result = functions->CallStaticFloatMethodV(this, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jfloat CallStaticFloatMethodV(jclass clazz, jmethodID methodID, va_list args) {
            return functions->CallStaticFloatMethodV(this, clazz, methodID, args);
        }

        jfloat CallStaticFloatMethodA(jclass clazz, jmethodID methodID, const jvalue * args) {
            return functions->CallStaticFloatMethodA(this, clazz, methodID, args);
        }

        jdouble CallStaticDoubleMethod(jclass clazz, jmethodID methodID, ...) {
            va_list args;
            jdouble result;
            va_start(args, methodID);
            result = functions->CallStaticDoubleMethodV(this, clazz, methodID, args);
            va_end(args);
            return result;
        }

        jdouble CallStaticDoubleMethodV(jclass clazz, jmethodID methodID, va_list args) {
            return functions->CallStaticDoubleMethodV(this, clazz, methodID, args);
        }

        jdouble CallStaticDoubleMethodA(jclass clazz, jmethodID methodID, const jvalue * args) {
            return functions->CallStaticDoubleMethodA(this, clazz, methodID, args);
        }

        void CallStaticVoidMethod(jclass cls, jmethodID methodID, ...) {
            va_list args;
            va_start(args, methodID);
            functions->CallStaticVoidMethodV(this, cls, methodID, args);
            va_end(args);
        }

        void CallStaticVoidMethodV(jclass cls, jmethodID methodID, va_list args) {
            functions->CallStaticVoidMethodV(this, cls, methodID, args);
        }

        void CallStaticVoidMethodA(jclass cls, jmethodID methodID, const jvalue * args) {
            functions->CallStaticVoidMethodA(this, cls, methodID, args);
        }

        jfieldID GetStaticFieldID(jclass clazz, const char *name, const char *sig) {
            return functions->GetStaticFieldID(this, clazz, name, sig);
        }

        jobject GetStaticObjectField(jclass clazz, jfieldID fieldID) {
            return functions->GetStaticObjectField(this, clazz, fieldID);
        }

        jboolean GetStaticBooleanField(jclass clazz, jfieldID fieldID) {
            return functions->GetStaticBooleanField(this, clazz, fieldID);
        }

        jbyte GetStaticByteField(jclass clazz, jfieldID fieldID) {
            return functions->GetStaticByteField(this, clazz, fieldID);
        }

        jchar GetStaticCharField(jclass clazz, jfieldID fieldID) {
            return functions->GetStaticCharField(this, clazz, fieldID);
        }

        jshort GetStaticShortField(jclass clazz, jfieldID fieldID) {
            return functions->GetStaticShortField(this, clazz, fieldID);
        }

        jint GetStaticIntField(jclass clazz, jfieldID fieldID) {
            return functions->GetStaticIntField(this, clazz, fieldID);
        }

        jlong GetStaticLongField(jclass clazz, jfieldID fieldID) {
            return functions->GetStaticLongField(this, clazz, fieldID);
        }

        jfloat GetStaticFloatField(jclass clazz, jfieldID fieldID) {
            return functions->GetStaticFloatField(this, clazz, fieldID);
        }

        jdouble GetStaticDoubleField(jclass clazz, jfieldID fieldID) {
            return functions->GetStaticDoubleField(this, clazz, fieldID);
        }

        void SetStaticObjectField(jclass clazz, jfieldID fieldID, jobject value) {
            functions->SetStaticObjectField(this, clazz, fieldID, value);
        }

        void SetStaticBooleanField(jclass clazz, jfieldID fieldID, jboolean value) {
            functions->SetStaticBooleanField(this, clazz, fieldID, value);
        }

        void SetStaticByteField(jclass clazz, jfieldID fieldID, jbyte value) {
            functions->SetStaticByteField(this, clazz, fieldID, value);
        }

        void SetStaticCharField(jclass clazz, jfieldID fieldID, jchar value) {
            functions->SetStaticCharField(this, clazz, fieldID, value);
        }

        void SetStaticShortField(jclass clazz, jfieldID fieldID, jshort value) {
            functions->SetStaticShortField(this, clazz, fieldID, value);
        }

        void SetStaticIntField(jclass clazz, jfieldID fieldID, jint value) {
            functions->SetStaticIntField(this, clazz, fieldID, value);
        }

        void SetStaticLongField(jclass clazz, jfieldID fieldID, jlong value) {
            functions->SetStaticLongField(this, clazz, fieldID, value);
        }

        void SetStaticFloatField(jclass clazz, jfieldID fieldID, jfloat value) {
            functions->SetStaticFloatField(this, clazz, fieldID, value);
        }

        void SetStaticDoubleField(jclass clazz, jfieldID fieldID, jdouble value) {
            functions->SetStaticDoubleField(this, clazz, fieldID, value);
        }

        jstring NewString(const jchar *unicode, jsize len) {
            return functions->NewString(this, unicode, len);
        }

        jsize GetStringLength(jstring str) {
            return functions->GetStringLength(this, str);
        }

        const jchar * GetStringChars(jstring str, jboolean * isCopy) {
            return functions->GetStringChars(this, str, isCopy);
        }

        void ReleaseStringChars(jstring str, const jchar * chars) {
            functions->ReleaseStringChars(this, str, chars);
        }

        jstring NewStringUTF(const char *utf) {
            return functions->NewStringUTF(this, utf);
        }

        jsize GetStringUTFLength(jstring str) {
            return functions->GetStringUTFLength(this, str);
        }

        const char* GetStringUTFChars(jstring str, jboolean * isCopy) {
            return functions->GetStringUTFChars(this, str, isCopy);
        }

        void ReleaseStringUTFChars(jstring str, const char* chars) {
            functions->ReleaseStringUTFChars(this, str, chars);
        }

        jsize GetArrayLength(jarray array) {
            return functions->GetArrayLength(this, array);
        }

        jobjectArray NewObjectArray(jsize len, jclass clazz, jobject init) {
            return functions->NewObjectArray(this, len, clazz, init);
        }

        jobject GetObjectArrayElement(jobjectArray array, jsize index) {
            return functions->GetObjectArrayElement(this, array, index);
        }

        void SetObjectArrayElement(jobjectArray array, jsize index, jobject val) {
            functions->SetObjectArrayElement(this, array, index, val);
        }

        jbooleanArray NewBooleanArray(jsize len) {
            return functions->NewBooleanArray(this, len);
        }

        jbyteArray NewByteArray(jsize len) {
            return functions->NewByteArray(this, len);
        }

        jcharArray NewCharArray(jsize len) {
            return functions->NewCharArray(this, len);
        }

        jshortArray NewShortArray(jsize len) {
            return functions->NewShortArray(this, len);
        }

        jintArray NewIntArray(jsize len) {
            return functions->NewIntArray(this, len);
        }

        jlongArray NewLongArray(jsize len) {
            return functions->NewLongArray(this, len);
        }

        jfloatArray NewFloatArray(jsize len) {
            return functions->NewFloatArray(this, len);
        }

        jdoubleArray NewDoubleArray(jsize len) {
            return functions->NewDoubleArray(this, len);
        }

        jboolean * GetBooleanArrayElements(jbooleanArray array, jboolean * isCopy) {
            return functions->GetBooleanArrayElements(this, array, isCopy);
        }

        jbyte * GetByteArrayElements(jbyteArray array, jboolean * isCopy) {
            return functions->GetByteArrayElements(this, array, isCopy);
        }

        jchar * GetCharArrayElements(jcharArray array, jboolean * isCopy) {
            return functions->GetCharArrayElements(this, array, isCopy);
        }

        jshort * GetShortArrayElements(jshortArray array, jboolean * isCopy) {
            return functions->GetShortArrayElements(this, array, isCopy);
        }

        jint * GetIntArrayElements(jintArray array, jboolean * isCopy) {
            return functions->GetIntArrayElements(this, array, isCopy);
        }

        jlong * GetLongArrayElements(jlongArray array, jboolean * isCopy) {
            return functions->GetLongArrayElements(this, array, isCopy);
        }

        jfloat * GetFloatArrayElements(jfloatArray array, jboolean * isCopy) {
            return functions->GetFloatArrayElements(this, array, isCopy);
        }

        jdouble * GetDoubleArrayElements(jdoubleArray array, jboolean * isCopy) {
            return functions->GetDoubleArrayElements(this, array, isCopy);
        }

        void ReleaseBooleanArrayElements(jbooleanArray array, jboolean *elems, jint mode) {
            functions->ReleaseBooleanArrayElements(this, array, elems, mode);
        }

        void ReleaseByteArrayElements(jbyteArray array, jbyte *elems, jint mode) {
            functions->ReleaseByteArrayElements(this, array, elems, mode);
        }

        void ReleaseCharArrayElements(jcharArray array, jchar *elems, jint mode) {
            functions->ReleaseCharArrayElements(this, array, elems, mode);
        }

        void ReleaseShortArrayElements(jshortArray array, jshort *elems, jint mode) {
            functions->ReleaseShortArrayElements(this, array, elems, mode);
        }

        void ReleaseIntArrayElements(jintArray array, jint *elems, jint mode) {
            functions->ReleaseIntArrayElements(this, array, elems, mode);
        }

        void ReleaseLongArrayElements(jlongArray array, jlong *elems, jint mode) {
            functions->ReleaseLongArrayElements(this, array, elems, mode);
        }

        void ReleaseFloatArrayElements(jfloatArray array, jfloat *elems, jint mode) {
            functions->ReleaseFloatArrayElements(this, array, elems, mode);
        }

        void ReleaseDoubleArrayElements(jdoubleArray array, jdouble *elems, jint mode) {
            functions->ReleaseDoubleArrayElements(this, array, elems, mode);
        }

        void GetBooleanArrayRegion(jbooleanArray array, jsize start, jsize len, jboolean * buf) {
            functions->GetBooleanArrayRegion(this, array, start, len, buf);
        }

        void GetByteArrayRegion(jbyteArray array, jsize start, jsize len, jbyte * buf) {
            functions->GetByteArrayRegion(this, array, start, len, buf);
        }

        void GetCharArrayRegion(jcharArray array, jsize start, jsize len, jchar * buf) {
            functions->GetCharArrayRegion(this, array, start, len, buf);
        }

        void GetShortArrayRegion(jshortArray array, jsize start, jsize len, jshort * buf) {
            functions->GetShortArrayRegion(this, array, start, len, buf);
        }

        void GetIntArrayRegion(jintArray array, jsize start, jsize len, jint * buf) {
            functions->GetIntArrayRegion(this, array, start, len, buf);
        }

        void GetLongArrayRegion(jlongArray array, jsize start, jsize len, jlong * buf) {
            functions->GetLongArrayRegion(this, array, start, len, buf);
        }

        void GetFloatArrayRegion(jfloatArray array, jsize start, jsize len, jfloat * buf) {
            functions->GetFloatArrayRegion(this, array, start, len, buf);
        }

        void GetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len, jdouble * buf) {
            functions->GetDoubleArrayRegion(this, array, start, len, buf);
        }

        void SetBooleanArrayRegion(jbooleanArray array, jsize start, jsize len, const jboolean * buf) {
            functions->SetBooleanArrayRegion(this, array, start, len, buf);
        }

        void SetByteArrayRegion(jbyteArray array, jsize start, jsize len, const jbyte * buf) {
            functions->SetByteArrayRegion(this, array, start, len, buf);
        }

        void SetCharArrayRegion(jcharArray array, jsize start, jsize len, const jchar * buf) {
            functions->SetCharArrayRegion(this, array, start, len, buf);
        }

        void SetShortArrayRegion(jshortArray array, jsize start, jsize len, const jshort * buf) {
            functions->SetShortArrayRegion(this, array, start, len, buf);
        }

        void SetIntArrayRegion(jintArray array, jsize start, jsize len, const jint * buf) {
            functions->SetIntArrayRegion(this, array, start, len, buf);
        }

        void SetLongArrayRegion(jlongArray array, jsize start, jsize len, const jlong * buf) {
            functions->SetLongArrayRegion(this, array, start, len, buf);
        }

        void SetFloatArrayRegion(jfloatArray array, jsize start, jsize len, const jfloat * buf) {
            functions->SetFloatArrayRegion(this, array, start, len, buf);
        }

        void SetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len, const jdouble * buf) {
            functions->SetDoubleArrayRegion(this, array, start, len, buf);
        }

        jint RegisterNatives(jclass clazz, const JNINativeMethod *methods, jint nMethods) {
            return functions->RegisterNatives(this, clazz, methods, nMethods);
        }

        jint UnregisterNatives(jclass clazz) {
            return functions->UnregisterNatives(this, clazz);
        }

        jint MonitorEnter(jobject obj) {
            return functions->MonitorEnter(this, obj);
        }

        jint MonitorExit(jobject obj) {
            return functions->MonitorExit(this, obj);
        }

        jint GetJavaVM(JavaVM **vm) {
            return functions->GetJavaVM(this, vm);
        }

        void GetStringRegion(jstring str, jsize start, jsize len, jchar * buf) {
            functions->GetStringRegion(this, str, start, len, buf);
        }

        void GetStringUTFRegion(jstring str, jsize start, jsize len, char *buf) {
            functions->GetStringUTFRegion(this, str, start, len, buf);
        }

        void * GetPrimitiveArrayCritical(jarray array, jboolean * isCopy) {
            return functions->GetPrimitiveArrayCritical(this, array, isCopy);
        }

        void ReleasePrimitiveArrayCritical(jarray array, void *carray, jint mode) {
            functions->ReleasePrimitiveArrayCritical(this, array, carray, mode);
        }

        const jchar * GetStringCritical(jstring string, jboolean * isCopy) {
            return functions->GetStringCritical(this, string, isCopy);
        }

        void ReleaseStringCritical(jstring string, const jchar * cstring) {
            functions->ReleaseStringCritical(this, string, cstring);
        }

        jweak NewWeakGlobalRef(jobject obj) {
            return functions->NewWeakGlobalRef(this, obj);
        }

        void DeleteWeakGlobalRef(jweak ref) {
            functions->DeleteWeakGlobalRef(this, ref);
        }

        jboolean ExceptionCheck() {
            return functions->ExceptionCheck(this);
        }

        jobject NewDirectByteBuffer(void* address, jlong capacity) {
            return functions->NewDirectByteBuffer(this, address, capacity);
        }

        void* GetDirectBufferAddress(jobject buf) {
            return functions->GetDirectBufferAddress(this, buf);
        }

        jlong GetDirectBufferCapacity(jobject buf) {
            return functions->GetDirectBufferCapacity(this, buf);
        }
        
#endif
        
    };

    typedef struct JavaVMOption {
        char *optionString;
        void *extraInfo;
    } JavaVMOption;

    typedef struct JavaVMInitArgs {
        jint version;
        jint nOptions;
        JavaVMOption *options;
        jboolean ignoreUnrecognized;
    } JavaVMInitArgs;

    typedef struct JavaVMAttachArgs {
        jint version;
        char *name;
        jobject group;
    } JavaVMAttachArgs;

    /* These structures will be VM-specific. */
    typedef struct JDK1_1InitArgs {
        jint version;
        char **properties;
        jint checkSource;
        jint nativeStackSize;
        jint javaStackSize;
        jint minHeapSize;
        jint maxHeapSize;
        jint verifyMode;
        char *classpath;
        jint(JNICALL * vfprintf)(FILE *fp, const char *format, va_list args);
        void (JNICALL * exit)(jint code);
        void (JNICALL * abort)(void);
        jint enableClassGC;
        jint enableVerboseGC;
        jint disableAsyncGC;
        jint verbose;
        jboolean debugging;
        jint debugPort;
    } JDK1_1InitArgs;

    typedef struct JDK1_1AttachArgs {
        void * __padding; /* C compilers don't allow empty structures. */
    } JDK1_1AttachArgs;
    
#define JDK1_2
#define JDK1_4

    /* End VM-specific. */
    struct JNIInvokeInterface_ {
        void *reserved0;
        void *reserved1;
        void *reserved2;
        jint(JNICALL * DestroyJavaVM)(JavaVM * vm);
        jint(JNICALL * AttachCurrentThread)(JavaVM *vm, void **penv, void *args);
        jint(JNICALL * DetachCurrentThread)(JavaVM * vm);
        jint(JNICALL * GetEnv)(JavaVM *vm, void **penv, jint version);
        jint(JNICALL * AttachCurrentThreadAsDaemon)(JavaVM *vm, void **penv, void *args);
    };

    struct JavaVM_ {
        const struct JNIInvokeInterface_ *functions;
        
#ifdef __cplusplus

        jint DestroyJavaVM() {
            return functions->DestroyJavaVM(this);
        }

        jint AttachCurrentThread(void **penv, void *args) {
            return functions->AttachCurrentThread(this, penv, args);
        }

        jint DetachCurrentThread() {
            return functions->DetachCurrentThread(this);
        }

        jint GetEnv(void **penv, jint version) {
            return functions->GetEnv(this, penv, version);
        }

        jint AttachCurrentThreadAsDaemon(void **penv, void *args) {
            return functions->AttachCurrentThreadAsDaemon(this, penv, args);
        }
        
#endif
        
    };
    
    extern "C" jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args);
    extern "C" jint JNICALL JNI_CreateJavaVM(JavaVM **pvm, void **penv, void *args);
    extern "C" jint JNICALL JNI_GetCreatedJavaVMs(JavaVM **, jsize, jsize *);
    extern "C" jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved);
    extern "C" void JNICALL JNI_OnUnload(JavaVM *vm, void *reserved);
    
#define JNI_VERSION_1_1 0x00010001
#define JNI_VERSION_1_2 0x00010002
#define JNI_VERSION_1_4 0x00010004
    
#ifdef __cplusplus
};
#endif

#endif

/* 
 * File:   LongDoubleInfo.h
 * Author: Benjamin J. Land
 *
 * Created on November 25, 2008, 7:47 PM
 */

#ifndef _LONGDOUBLEINFO_H
#define	_LONGDOUBLEINFO_H



#endif	/* _LONGDOUBLEINFO_H */

/* 
 * File:   MethodInfo.h
 * Author: Benjamin J. Land
 *
 * Created on November 25, 2008, 7:36 PM
 */

#ifndef _METHODINFO_H
#define	_METHODINFO_H

#include <string>
#include <vector>
#include "ClassFile.h"

class AttributeInfo;

typedef struct {
    unsigned short int startPC;
    unsigned short int endPC;
    unsigned short int handlerPC;
    unsigned short int catchType;
} ExceptionEntry;

class Code {
public:
    unsigned short int maxStack;
    unsigned short int maxLocals;
    unsigned long int codeLength;
    unsigned char *code;
    unsigned short int exceptionCount;
    ExceptionEntry **exceptions;
    unsigned short int attributeCount;
    AttributeInfo **attributes;
    
    Code(AttributeInfo *code);
    ~Code();
};

class MethodInfo {
    friend class ClassFile;
private:
    unsigned short int nameIndex;
    unsigned short int descriptorIndex;
    unsigned short int attributeCount;
    AttributeInfo **attributes;

    MethodInfo(unsigned char *data, int &index);

public:
    unsigned short int accessFlags;
    std::string name;
    std::string descriptor;
    std::string full;
    std::vector<char> typeSz;
    ClassFile* clazz;
    int nargs; //size in bytes
    int argsc; //number of args
    int result;
    int resobject;
    Code *code;
    void *native;
    
    ~MethodInfo();
};

#endif	/* _METHODINFO_H */

/* 
 * File:   Mutex.h
 * Author: Benjamin J. Land
 *
 * Created on December 18, 2008, 8:04 PM
 */

#ifndef _MUTEX_H
#define	_MUTEX_H

class Mutex {
public:
    Mutex();
    ~Mutex();
    void lock();
    void unlock();
private:
    Mutex(Mutex &ref);
    void *data;
};

class Lock {
private:
    Mutex *mutex;
public:
    Lock(Mutex *_mutex);
    ~Lock();
};

#endif	/* _MUTEX_H */

/* 
 * File:   NameAndTypeInfo.h
 * Author: Benjamin J. Land
 *
 * Created on November 25, 2008, 7:48 PM
 */

#ifndef _NAMEANDTYPEINFO_H
#define	_NAMEANDTYPEINFO_H



#endif	/* _NAMEANDTYPEINFO_H */

/* 
 * File:   Native.h
 * Author: Benjamin J. Land
 *
 * Created on November 29, 2008, 8:30 PM
 */

#ifndef _NATIVE_H
#define	_NATIVE_H

#include <map>
#include <string>

class LibraryPool {
private:
    std::map<std::string,void*> libraries;
public:
    LibraryPool();
    ~LibraryPool();
    int loadlib(const char *library);
    void* address(const char *name);
};


#endif	/* _NATIVE_H */

/* 
 * File:   Object.h
 * Author: Benjamin J. Land
 *
 * Created on November 26, 2008, 5:13 PM
 */

#ifndef _OBJECT_H
#define	_OBJECT_H

#include "Types.h"
#include "Mutex.h"

class ClassFile;
class Object;
class Mutex;

class Object {
    friend class ClassFile;
    friend class GlobalGC;
    friend class LocalGC;
    
private:
    unsigned int staticCount;
    unsigned int refCount;
    unsigned int localCount;
    
protected:
    Object();
    
public:
    virtual ~Object();
    
    ClassFile *type;
    Variable *fields;
    Mutex mutex;
    
};

#endif	/* _OBJECT_H */

/* 
 * File:   OPCodes.h
 * Author: Benjamin J. Land
 *
 * Created on November 27, 2008, 1:57 PM
 */

#ifndef _OPCODES_H
#define	_OPCODES_H

#define nop 0x00
#define aconst_null 0x01
#define iconst_m1 0x02
#define iconst_0 0x03
#define iconst_1 0x04
#define iconst_2 0x05
#define iconst_3 0x06
#define iconst_4 0x07
#define iconst_5 0x08
#define lconst_0 0x09
#define lconst_1 0x0a
#define fconst_0 0x0b
#define fconst_1 0x0c
#define fconst_2 0x0d
#define dconst_0 0x0e
#define dconst_1 0x0f
#define bipush 0x10
#define sipush 0x11
#define ldc 0x12
#define ldc_w 0x13
#define ldc2_w 0x14
#define iload 0x15
#define lload 0x16
#define fload 0x17
#define dload 0x18
#define aload 0x19
#define iload_0 0x1a
#define iload_1 0x1b
#define iload_2 0x1c
#define iload_3 0x1d
#define lload_0 0x1e
#define lload_1 0x1f
#define lload_2 0x20
#define lload_3 0x21
#define fload_0 0x22
#define fload_1 0x23
#define fload_2 0x24
#define fload_3 0x25
#define dload_0 0x26
#define dload_1 0x27
#define dload_2 0x28
#define dload_3 0x29
#define aload_0 0x2a
#define aload_1 0x2b
#define aload_2 0x2c
#define aload_3 0x2d
#define iaload 0x2e
#define laload 0x2f
#define faload 0x30
#define daload 0x31
#define aaload 0x32
#define baload 0x33
#define caload 0x34
#define saload 0x35
#define istore 0x36
#define lstore 0x37
#define fstore 0x38
#define dstore 0x39
#define astore 0x3a
#define istore_0 0x3b
#define istore_1 0x3c
#define istore_2 0x3d
#define istore_3 0x3e
#define lstore_0 0x3f
#define lstore_1 0x40
#define lstore_2 0x41
#define lstore_3 0x42
#define fstore_0 0x43
#define fstore_1 0x44
#define fstore_2 0x45
#define fstore_3 0x46
#define dstore_0 0x47
#define dstore_1 0x48
#define dstore_2 0x49
#define dstore_3 0x4a
#define astore_0 0x4b
#define astore_1 0x4c
#define astore_2 0x4d
#define astore_3 0x4e
#define iastore 0x4f
#define lastore 0x50
#define fastore 0x51
#define dastore 0x52
#define aastore 0x53
#define bastore 0x54
#define castore 0x55
#define sastore 0x56
#define pop 0x57
#define pop2 0x58
#define dup 0x59
#define dup_x1 0x5a
#define dup_x2 0x5b
#define dup2 0x5c
#define dup2_x1 0x5d
#define dup2_x2 0x5e
#define swap 0x5f
#define iadd 0x60
#define ladd 0x61
#define fadd 0x62
#define dadd 0x63
#define isub 0x64
#define lsub 0x65
#define fsub 0x66
#define dsub 0x67
#define imul 0x68
#define lmul 0x69
#define fmul 0x6a
#define dmul 0x6b
#define idiv 0x6c
#define ldiv 0x6d
#define fdiv 0x6e
#define ddiv 0x6f
#define irem 0x70
#define lrem 0x71
#define frem 0x72
#define drem 0x73
#define ineg 0x74
#define lneg 0x75
#define fneg 0x76
#define dneg 0x77
#define ishl 0x78
#define lshl 0x79
#define ishr 0x7a
#define lshr 0x7b
#define iushr 0x7c
#define lushr 0x7d
#define iand 0x7e
#define land 0x7f
#define ior 0x80
#define lor 0x81
#define ixor 0x82
#define lxor 0x83
#define iinc 0x84
#define i2l 0x85
#define i2f 0x86
#define i2d 0x87
#define l2i 0x88
#define l2f 0x89
#define l2d 0x8a
#define f2i 0x8b
#define f2l 0x8c
#define f2d 0x8d
#define d2i 0x8e
#define d2l 0x8f
#define d2f 0x90
#define i2b 0x91
#define i2c 0x92
#define i2s 0x93
#define lcmp 0x94
#define fcmpl 0x95
#define fcmpg 0x96
#define dcmpl 0x97
#define dcmpg 0x98
#define ifeq 0x99
#define ifne 0x9a
#define iflt 0x9b
#define ifge 0x9c
#define ifgt 0x9d
#define ifle 0x9e
#define if_icmpeq 0x9f
#define if_icmpne 0xa0
#define if_icmplt 0xa1
#define if_icmpge 0xa2
#define if_icmpgt 0xa3
#define if_icmple 0xa4
#define if_acmpeq 0xa5
#define if_acmpne 0xa6
#define jump 0xa7
#define jsr 0xa8
#define ret 0xa9
#define tableswitch 0xaa
#define lookupswitch 0xab
#define ireturn 0xac
#define lreturn 0xad
#define freturn 0xae
#define dreturn 0xaf
#define areturn 0xb0
#define vreturn 0xb1
#define getstatic 0xb2
#define putstatic 0xb3
#define getfield 0xb4
#define putfield 0xb5
#define invokevirtual 0xb6
#define invokespecial 0xb7
#define invokestatic 0xb8
#define invokeinterface 0xb9
#define xxxunusedxxx 0xba
#define newobj 0xbb
#define newarray 0xbc
#define anewarray 0xbd
#define arraylength 0xbe
#define athrow 0xbf
#define checkcast 0xc0
#define instanceof 0xc1
#define monitorenter 0xc2
#define monitorexit 0xc3
#define wide 0xc4
#define multianewarray 0xc5
#define ifnull 0xc6
#define ifnonnull 0xc7
#define jump_w 0xc8
#define jsr_w 0xc9

//Reserved opcodes:

#define breakpoint 0xca
#define impdep1 0xfe
#define impdep2 0xff

#endif	/* _OPCODES_H */

/* 
 * File:   SJVM.h
 * Author: Benjamin J. Land
 *
 * Created on November 26, 2008, 5:02 PM
 */

#ifndef _SJVM_H
#define	_SJVM_H

#include "Types.h"
#include "jni.h"
#include "Native.h"
#include "GarbageCollector.h"

#include <map>

class GlobalGC;
class Exception;
class ClassLoader;
class ClassPath;
class MethodInfo;
class ClassFile;
class Thread;
class LibraryPool;


extern struct JNIInvokeInterface_ SJVM_JNIInvokeInterface;

class SJVM {
    friend class Thread;
private:
    JavaVM* vm;
    LibraryPool libpool;
    ClassLoader *loader;
    std::map<unsigned int,Thread*> threads;
    std::map<std::string,JOBJECT> strings;
    std::map<std::string,void*> natives;
public:
    SJVM(ClassPath *path);
    virtual ~SJVM();
    GlobalGC *gc;
    void mapNative(char *fullname, void *address);
    void* getNative(char *fullname);
    Variable execute(MethodInfo *meth, ClassFile *cur, Thread *thread, long *args, long argsc, Exception **exception);

    JavaVM* getJavaVM();
    ClassFile* loadClass(const char* name);

};

#endif	/* _SJVM_H */

/* 
 * File:   StringInfo.h
 * Author: Benjamin J. Land
 *
 * Created on November 25, 2008, 7:47 PM
 */

#ifndef _STRINGINFO_H
#define	_STRINGINFO_H



#endif	/* _STRINGINFO_H */

#ifndef _THREAD_H
#define	_THREAD_H

#include "jni.h"

#include "Object.h"
#include "GarbageCollector.h"

class SJVM;
class Exception;
class Object;

extern struct JNINativeInterface_ SJVM_JNINativeInterface;

//FIXME needs type set
class Thread : public Object {
    friend class SJVM;
private:
    SJVM *sjvm;
    JNIEnv* jnienv;
    unsigned int id;
    
    Thread(SJVM *sjvm);
    virtual ~Thread();
public:
    JNIEnv* getEnv();
    void start();
    Exception *nativeException;
    LocalGC *nativeLocal;
    
    static Thread* getThread(SJVM *sjvm);
};

#endif	/* _THREAD_H */
#ifndef _TYPES_H
#define	_TYPES_H

class Object;
class ClassFile;

template <class T> class Array;

typedef unsigned char	JBOOLEAN;
typedef unsigned short	JCHAR;
typedef short		JSHORT;
typedef float		JFLOAT;
typedef double		JDOUBLE;
typedef long            JINT;
typedef long long       JLONG;
typedef signed char     JBYTE;

typedef Object*         JOBJECT;
typedef ClassFile*      JCLASS;

typedef Array<JBOOLEAN>*JBOOLEANARRAY;
typedef Array<JCHAR>*   JCHARARRAY;
typedef Array<JBYTE>*   JBYTEARRAY;
typedef Array<JSHORT>*  JSHORTARRAY;
typedef Array<JINT>*    JINTARRAY;
typedef Array<JLONG>*   JLONGARRAY;
typedef Array<JFLOAT>*  JFLOATARRAY;
typedef Array<JDOUBLE>* JDOUBLEARRAY;
typedef Array<JOBJECT>* JOBJECTARRAY;

typedef union {
    JBOOLEAN z;
    JBYTE    b;
    JCHAR    c;
    JSHORT   s;
    JFLOAT   f;
    JDOUBLE  d;
    JINT     i;
    JLONG    j;
    JOBJECT  l;
} Variable;

#endif	/* _TYPES_H */

/* 
 * File:   UTF8Info.h
 * Author: Benjamin J. Land
 *
 * Created on November 25, 2008, 7:49 PM
 */

#ifndef _UTF8INFO_H
#define	_UTF8INFO_H



#endif	/* _UTF8INFO_H */

/*
 * Mark Adler's INFLATE algorithm, heavily modified by Benjamin Land
 */

#define	IDBG(s) /* XXX */

#include "Inflate.h"

#define	WSIZE	0x8000

typedef struct _huft {
    unsigned char e; /* number of extra bits or operation */
    unsigned char b;

    /* number of bits in this code or subcode */
    union {
        unsigned short int n; /* literal, length base, or distance base */
        struct _huft* t; /* pointer to next level of table */
    } v;
} huft;

static int inflate_codes(inflateInfo*, huft*, huft*, int, int);
static int inflate_stored(inflateInfo*);
static int inflate_fixed(inflateInfo*);
static int inflate_dynamic(inflateInfo*);
static int inflate_block(inflateInfo*, int*);
static int huft_free(huft*);
static int inflate(inflateInfo*);
static int huft_build(inflateInfo* pG, unsigned* b, unsigned n, unsigned s, unsigned short int* d, unsigned short int* e, huft** t, int* m);

/* Tables for deflate from PKZIP's appnote.txt. */
static unsigned border[] = {/* Order of the bit length code lengths */
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

static unsigned short int cplens[] = {/* Copy lengths for literal codes 257..285 */
    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
    35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
/* note: see note #13 above about the 258 in this list. */

static unsigned short int cplext[] = {/* Extra bits for literal codes 257..285 */
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
    3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99}; /* 99==invalid */

static unsigned short int cpdist[] = {/* Copy offsets for distance codes 0..29 */
    1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
    257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
    8193, 12289, 16385, 24577};

static unsigned short int cpdext[] = {/* Extra bits for distance codes */
    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
    7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
    12, 12, 13, 13};

static unsigned short int mask_bits[] = {
    0x0000,
    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
};

#define	LBITS	9		/* bits in base literal/length lookup table */
#define	DBITS	6		/* bits in base distance lookup table */

#define NEEDBITS(G, N)						\
	{							\
		unsigned long int c;					\
		while (k < (N)) {				\
			if ((G)->insz <= 0) {			\
				return (1);			\
			}					\
			c = (G)->inbuf[0];			\
			(G)->inbuf++;				\
			b |= c << k;				\
			k += 8;					\
		}						\
	}

#define DUMPBITS(G, N)						\
	{							\
		b >>= (N);					\
		k -= (N);					\
	}

#define	FLUSH(G, N)						\
	{							\
		int c;						\
		int p;						\
		c = ((N) < (G)->outsz ? (N) : (G)->outsz);	\
		for (p = 0; c > 0; p++, c--) {			\
			(G)->outbuf[p] = (G)->slide[p];		\
		}						\
		(G)->outbuf += p;				\
		(G)->outsz -= p;				\
	}

static int inflate_codes(inflateInfo* pG, huft* tl, huft* td, int bl, int bd) {
    register unsigned e; /* table entry flag/number of extra bits */
    unsigned n, d; /* length and index for copy */
    unsigned w; /* current window position */
    huft *t; /* pointer to table entry */
    unsigned ml, md; /* masks for bl and bd bits */
    register unsigned long int b; /* bit buffer */
    register unsigned k; /* number of bits in bit buffer */


    /* make local copies of globals */
    b = pG->bb; /* initialize bit buffer */
    k = pG->bk;
    w = pG->wp; /* initialize window position */


    /* inflate the coded data */
    ml = mask_bits[bl]; /* precompute masks for speed */
    md = mask_bits[bd];
    while (1) /* do until end of block */ {
        NEEDBITS(pG, (unsigned) bl)
        if ((e = (t = tl + ((unsigned) b & ml))->e) > 16)
            do {
                if (e == 99)
                    return 1;
                DUMPBITS(pG, t->b)
                e -= 16;
                NEEDBITS(pG, e)
            } while ((e = (t = t->v.t + ((unsigned) b & mask_bits[e]))->e) > 16);
        DUMPBITS(pG, t->b)
        if (e == 16) /* then it's a literal */ {
            pG->slide[w++] = (unsigned char) t->v.n;
            if (w == WSIZE) {
                FLUSH(pG, w);
                w = 0;
            }
        } else /* it's an EOB or a length */ {
            /* exit if end of block */
            if (e == 15)
                break;

            /* get length of block to copy */
            NEEDBITS(pG, e)
            n = t->v.n + ((unsigned) b & mask_bits[e]);
            DUMPBITS(pG, e);

            /* decode distance of block to copy */
            NEEDBITS(pG, (unsigned) bd)
            if ((e = (t = td + ((unsigned) b & md))->e) > 16)
                do {
                    if (e == 99)
                        return 1;
                    DUMPBITS(pG, t->b)
                    e -= 16;
                    NEEDBITS(pG, e)
                } while ((e = (t = t->v.t + ((unsigned) b & mask_bits[e]))->e) > 16);
            DUMPBITS(pG, t->b)
            NEEDBITS(pG, e)
            d = w - t->v.n - ((unsigned) b & mask_bits[e]);
            DUMPBITS(pG, e)

                    /* do the copy */
            do {
                n -= (e = (e = WSIZE - ((d &= WSIZE - 1) > w ? d : w)) > n ? n : e);
                if (w - d >= e) /* (this test assumes unsigned comparison) */ {
                    memcpy(pG->slide + w, pG->slide + d, e);
                    w += e;
                    d += e;
                } else /* do it slowly to avoid memcpy() overlap */
                    do {
                        pG->slide[w++] = pG->slide[d++];
                    } while (--e);
                if (w == WSIZE) {
                    FLUSH(pG, w);
                    w = 0;
                }
            } while (n);
        }
    }


    /* restore the globals from the locals */
    pG->wp = w; /* restore global window pointer */
    pG->bb = b; /* restore global bit buffer */
    pG->bk = k;


    /* done */
    return 0;
}

static int inflate_stored(inflateInfo* pG) {
    unsigned n; /* number of bytes in block */
    unsigned w; /* current window position */
    register unsigned long int b; /* bit buffer */
    register unsigned k; /* number of bits in bit buffer */


    /* make local copies of globals */
    IDBG(dprintf("\nstored block"));
    b = pG->bb; /* initialize bit buffer */
    k = pG->bk;
    w = pG->wp; /* initialize window position */


    /* go to byte boundary */
    n = k & 7;
    DUMPBITS(pG, n);


    /* get the length and its complement */
    NEEDBITS(pG, 16)
    n = ((unsigned) b & 0xffff);
    DUMPBITS(pG, 16)
    NEEDBITS(pG, 16)
    if (n != (unsigned) ((~b) & 0xffff))
        return 1; /* error in compressed data */
    DUMPBITS(pG, 16)


            /* read and output the compressed data */
    while (n--) {
        NEEDBITS(pG, 8)
        pG->slide[w++] = (unsigned char) b;
        if (w == WSIZE) {
            FLUSH(pG, w);
            w = 0;
        }
        DUMPBITS(pG, 8)
    }


    /* restore the globals from the locals */
    pG->wp = w; /* restore global window pointer */
    pG->bb = b; /* restore global bit buffer */
    pG->bk = k;
    return 0;
}

static int inflate_fixed(inflateInfo* pG) {
    /* if first time, set up tables for fixed blocks */
    IDBG(dprintf("\nliteral block"));
    if (pG->fixed_tl == 0) {
        int i; /* temporary variable */
        unsigned l[288]; /* length list for huft_build */

        /* literal table */
        for (i = 0; i < 144; i++)
            l[i] = 8;
        for (; i < 256; i++)
            l[i] = 9;
        for (; i < 280; i++)
            l[i] = 7;
        for (; i < 288; i++) /* make a complete, but wrong code set */
            l[i] = 8;
        pG->fixed_bl = 7;
        if ((i = huft_build(pG, l, 288, 257, cplens, cplext,
                &pG->fixed_tl, &pG->fixed_bl)) != 0) {
            pG->fixed_tl = 0;
            return i;
        }

        /* distance table */
        for (i = 0; i < 30; i++) /* make an incomplete code set */
            l[i] = 5;
        pG->fixed_bd = 5;
        if ((i = huft_build(pG, l, 30, 0, cpdist, cpdext,
                &pG->fixed_td, &pG->fixed_bd)) > 1) {
            huft_free(pG->fixed_tl);
            pG->fixed_tl = 0;
            return i;
        }
    }

    /* decompress until an end-of-block code */
    return inflate_codes(pG, pG->fixed_tl, pG->fixed_td,
            pG->fixed_bl, pG->fixed_bd) != 0;
}

static int inflate_dynamic(inflateInfo* pG) {
    int i; /* temporary variables */
    unsigned j;
    unsigned l; /* last length */
    unsigned m; /* mask for bit lengths table */
    unsigned n; /* number of lengths to get */
    huft *tl; /* literal/length code table */
    huft *td; /* distance code table */
    int bl; /* lookup bits for tl */
    int bd; /* lookup bits for td */
    unsigned nb; /* number of bit length codes */
    unsigned nl; /* number of literal/length codes */
    unsigned nd; /* number of distance codes */
    unsigned ll[288 + 32]; /* literal/length and distance code lengths */
    register unsigned long int b; /* bit buffer */
    register unsigned k; /* number of bits in bit buffer */


    /* make local bit buffer */
    IDBG(dprintf("\ndynamic block"));
    b = pG->bb;
    k = pG->bk;


    /* read in table lengths */
    NEEDBITS(pG, 5)
    nl = 257 + ((unsigned) b & 0x1f); /* number of literal/length codes */
    DUMPBITS(pG, 5)
    NEEDBITS(pG, 5)
    nd = 1 + ((unsigned) b & 0x1f); /* number of distance codes */
    DUMPBITS(pG, 5)
    NEEDBITS(pG, 4)
    nb = 4 + ((unsigned) b & 0xf); /* number of bit length codes */
    DUMPBITS(pG, 4)
    if (nl > 288 || nd > 32)
        return 1; /* bad lengths */


    /* read in bit-length-code lengths */
    for (j = 0; j < nb; j++) {
        NEEDBITS(pG, 3)
        ll[border[j]] = (unsigned) b & 7;
        DUMPBITS(pG, 3)
    }
    for (; j < 19; j++)
        ll[border[j]] = 0;


    /* build decoding table for trees--single level, 7 bit lookup */
    bl = 7;
    i = huft_build(pG, ll, 19, 19, 0, 0, &tl, &bl);
    if (bl == 0) /* no bit lengths */
        i = 1;
    if (i) {
        if (i == 1)
            huft_free(tl);
        return i; /* incomplete code set */
    }


    /* read in literal and distance code lengths */
    n = nl + nd;
    m = mask_bits[bl];
    i = l = 0;
    while ((unsigned) i < n) {
        NEEDBITS(pG, (unsigned) bl)
        j = (td = tl + ((unsigned) b & m))->b;
        DUMPBITS(pG, j)
        j = td->v.n;
        if (j < 16) /* length of code in bits (0..15) */
            ll[i++] = l = j; /* save last length in l */
        else if (j == 16) /* repeat last length 3 to 6 times */ {
            NEEDBITS(pG, 2)
            j = 3 + ((unsigned) b & 3);
            DUMPBITS(pG, 2)
            if ((unsigned) i + j > n)
                return 1;
            while (j--)
                ll[i++] = l;
        } else if (j == 17) /* 3 to 10 zero length codes */ {
            NEEDBITS(pG, 3)
            j = 3 + ((unsigned) b & 7);
            DUMPBITS(pG, 3)
            if ((unsigned) i + j > n)
                return 1;
            while (j--)
                ll[i++] = 0;
            l = 0;
        } else /* j == 18: 11 to 138 zero length codes */ {
            NEEDBITS(pG, 7)
            j = 11 + ((unsigned) b & 0x7f);
            DUMPBITS(pG, 7)
            if ((unsigned) i + j > n)
                return 1;
            while (j--)
                ll[i++] = 0;
            l = 0;
        }
    }


    /* free decoding table for trees */
    huft_free(tl);


    /* restore the global bit buffer */
    pG->bb = b;
    pG->bk = k;


    /* build the decoding tables for literal/length and distance codes */
    bl = LBITS;
    i = huft_build(pG, ll, nl, 257, cplens, cplext, &tl, &bl);
    if (bl == 0) /* no literals or lengths */
        i = 1;
    if (i) {
        if (i == 1) {
            huft_free(tl);
        }
        return i; /* incomplete code set */
    }
    bd = DBITS;
    i = huft_build(pG, ll + nl, nd, 0, cpdist, cpdext, &td, &bd);
    if (bd == 0 && nl > 257) /* lengths but no distances */ {
        huft_free(tl);
        return 1;
    }
    if (i == 1) {
        i = 0;
    }
    if (i) {
        huft_free(tl);
        return i;
    }


    /* decompress until an end-of-block code */
    if (inflate_codes(pG, tl, td, bl, bd))
        return 1;


    /* free the decoding tables, return */
    huft_free(tl);
    huft_free(td);
    return 0;
}

static int inflate_block(inflateInfo* pG, int* e) {
    unsigned t; /* block type */
    register unsigned long int b; /* bit buffer */
    register unsigned k; /* number of bits in bit buffer */


    /* make local bit buffer */
    b = pG->bb;
    k = pG->bk;


    /* read in last block bit */
    NEEDBITS(pG, 1)
            *e = (int) b & 1;
    DUMPBITS(pG, 1)


    /* read in block type */
    NEEDBITS(pG, 2)
    t = (unsigned) b & 3;
    DUMPBITS(pG, 2)


    /* restore the global bit buffer */
    pG->bb = b;
    pG->bk = k;


    /* inflate that block type */
    if (t == 2)
        return inflate_dynamic(pG);
    if (t == 0)
        return inflate_stored(pG);
    if (t == 1)
        return inflate_fixed(pG);


    /* bad block type */
    return 2;
}

/*
 * Create a new inflater.
 */
inflateInfo* inflate_new(void) {
    inflateInfo* info;

    info = malloc(sizeof(inflateInfo));
    if (!info) {
        return 0;
    }
    info->fixed_tl = 0;
    info->fixed_td = 0;
    info->fixed_bl = 0;
    info->fixed_bd = 0;
    info->slide = malloc(WSIZE);
    if (!info->slide) {
        free(info);
        return 0;
    }

    return (info);
}

/*
 * We pass in a buffer of deflated data and a place to stored the inflated
 * result.  This does not provide continuous operation and should only be
 * use in "one shot" more.
 */
int inflate_oneshot(unsigned char* ibuf, int ilen, unsigned char* obuf, int olen) {
    int r; /* result code: 0 on success */
    inflateInfo* pG;

    pG = inflate_new();

    if (!pG) {
        return 1;
    }

    pG->inbuf = ibuf;
    pG->insz = ilen;
    pG->outbuf = obuf;
    pG->outsz = olen;

    r = inflate(pG);

    inflate_free(pG);

    return (r);
}

/*
 * Inflate the given data into the given buffer.
 */
static int inflate(inflateInfo* pG) {
    int e; /* last block flag */
    int r; /* result code */
    unsigned h; /* maximum huft's malloc'ed */

    /* initialize window, bit buffer */
    pG->wp = 0;
    pG->bk = 0;
    pG->bb = 0;

    /* decompress until the last block */
    h = 0;
    do {
        pG->hufts = 0;
        if ((r = inflate_block(pG, &e)) != 0) {
            return r;
        }
        if (pG->hufts > h) {
            h = pG->hufts;
        }
    } while (!e);


    /* flush out G.slide */
    FLUSH(pG, pG->wp);

    /* return success */
    IDBG(dprintf("\n%u bytes in Huffman tables (%d/entry)\n", h * sizeof (huft), sizeof (huft)));
    return 0;
}

int inflate_free(inflateInfo* pG) {
    if (pG != 0) {
        if (pG->fixed_tl != 0) {
            huft_free(pG->fixed_td);
            huft_free(pG->fixed_tl);
            pG->fixed_td = pG->fixed_tl = 0;
        }
        free(pG->slide);
        free(pG);
    }

    return 0;
}


/* If BMAX needs to be larger than 16, then h and x[] should be unsigned long int. */
#define BMAX 16         /* maximum bit length of any code (16 for explode) */
#define N_MAX 288       /* maximum number of codes in any set */

static int huft_build(inflateInfo* pG, unsigned* b, unsigned n, unsigned s, unsigned short int* d, unsigned short int* e, huft** t, int* m) {
    unsigned a; /* counter for codes of length k */
    unsigned c[BMAX + 1]; /* bit length count table */
    unsigned el; /* length of EOB code (value 256) */
    unsigned f; /* i repeats in table every f entries */
    int g; /* maximum code length */
    int h; /* table level */
    register unsigned i; /* counter, current code */
    register unsigned j; /* counter */
    register int k; /* number of bits in current code */
    int lx[BMAX + 1]; /* memory for l[-1..BMAX-1] */
    int *l = lx + 1; /* stack of bits per table */
    register unsigned *p; /* pointer into c[], b[], or v[] */
    register huft *q; /* points to current table */
    huft r; /* table entry for structure assignment */
    huft * u[BMAX]; /* table stack */
    unsigned v[N_MAX]; /* values in order of bit length */
    register int w; /* bits before this table == (l * h) */
    unsigned x[BMAX + 1]; /* bit offsets, then code stack */
    unsigned *xp; /* pointer into x */
    int y; /* number of dummy codes added */
    unsigned z; /* number of entries in current table */


    /* Generate counts for each bit length */
    el = n > 256 ? b[256] : BMAX; /* set length of EOB code, if any */
    memset(c, 0, sizeof (c));
    p = b;
    i = n;
    do {
        c[*p]++;
        p++; /* assume all entries <= BMAX */
    } while (--i);
    if (c[0] == n) /* null input--all zero length codes */ {
        *t = 0;
        *m = 0;
        return 0;
    }


    /* Find minimum and maximum length, bound *m by those */
    for (j = 1; j <= BMAX; j++)
        if (c[j])
            break;
    k = j; /* minimum code length */
    if ((unsigned) * m < j)
        *m = j;
    for (i = BMAX; i; i--)
        if (c[i])
            break;
    g = i; /* maximum code length */
    if ((unsigned) * m > i)
        *m = i;


    /* Adjust last length count to fill out codes, if needed */
    for (y = 1 << j; j < i; j++, y <<= 1)
        if ((y -= c[j]) < 0)
            return 2; /* bad input: more codes than bits */
    if ((y -= c[i]) < 0)
        return 2;
    c[i] += y;


    /* Generate starting offsets into the value table for each length */
    x[1] = j = 0;
    p = c + 1;
    xp = x + 2;
    while (--i) { /* note that i == g from above */
        *xp++ = (j += *p++);
    }


    /* Make a table of values in order of bit lengths */
    memset(v, 0, sizeof (v));
    p = b;
    i = 0;
    do {
        if ((j = *p++) != 0)
            v[x[j]++] = i;
    } while (++i < n);
    n = x[g]; /* set n to length of v */


    /* Generate the Huffman codes and for each, make the table entries */
    x[0] = i = 0; /* first Huffman code is zero */
    p = v; /* grab values in bit order */
    h = -1; /* no tables yet--level -1 */
    w = l[-1] = 0; /* no bits decoded yet */
    u[0] = 0; /* just to keep compilers happy */
    q = 0; /* ditto */
    z = 0; /* ditto */

    /* go through the bit lengths (k already is bits in shortest code) */
    for (; k <= g; k++) {
        a = c[k];
        while (a--) {
            /* here i is the Huffman code of length k bits for value *p */
            /* make tables up to required level */
            while (k > w + l[h]) {
                w += l[h++]; /* add bits already decoded */

                /* compute minimum size table less than or equal to *m bits */
                z = (z = g - w) > (unsigned) * m ? *m : z; /* upper limit */
                if ((f = 1 << (j = k - w)) > a + 1) /* try a k-w bit table */ { /* too few codes for k-w bit table */
                    f -= a + 1; /* deduct codes from patterns left */
                    xp = c + k;
                    while (++j < z) /* try smaller tables up to z bits */ {
                        if ((f <<= 1) <= *++xp)
                            break; /* enough codes to use up j bits */
                        f -= *xp; /* else deduct codes from patterns */
                    }
                }
                if ((unsigned) w + j > el && (unsigned) w < el)
                    j = el - w; /* make EOB code end at table */
                z = 1 << j; /* table entries for j-bit table */
                l[h] = j; /* set table size in stack */

                /* allocate and link in new table */
                if ((q = (huft *) malloc((z + 1) * sizeof (huft))) ==
                        0) {
                    if (h)
                        huft_free(u[0]);
                    return 3; /* not enough memory */
                }
                pG->hufts += z + 1; /* track memory usage */
                *t = q + 1; /* link to list for huft_free() */
                *(t = &(q->v.t)) = 0;
                u[h] = ++q; /* table starts after link */

                /* connect to last table, if there is one */
                if (h) {
                    x[h] = i; /* save pattern for backing up */
                    r.b = (unsigned char) l[h - 1]; /* bits to dump before this table */
                    r.e = (unsigned char) (16 + j); /* bits in this table */
                    r.v.t = q; /* pointer to this table */
                    j = (i & ((1 << w) - 1)) >> (w - l[h - 1]);
                    u[h - 1][j] = r; /* connect to last table */
                }
            }

            /* set up table entry in r */
            r.b = (unsigned char) (k - w);
            if (p >= v + n)
                r.e = 99; /* out of values--invalid code */
            else if (*p < s) {
                r.e = (unsigned char) (*p < 256 ? 16 : 15); /* 256 is end-of-block code */
                r.v.n = (unsigned short int) * p++; /* simple code is just the value */
            } else {
                r.e = (unsigned char) e[*p - s]; /* non-simple--look up in lists */
                r.v.n = d[*p++ - s];
            }

            /* fill code-like entries with r */
            f = 1 << (k - w);
            for (j = i >> w; j < z; j += f)
                q[j] = r;

            /* backwards increment the k-bit code i */
            for (j = 1 << (k - 1); i & j; j >>= 1)
                i ^= j;
            i ^= j;

            /* backup over finished tables */
            while ((i & ((1 << w) - 1)) != x[h])
                w -= l[--h]; /* don't need to update q */
        }
    }


    /* return actual size of base table */
    *m = l[0];


    /* Return true (1) if we were given an incomplete table */
    return y != 0 && g != 1;
}

static int huft_free(huft* t) {
    huft *p, *q;

    /* Go through linked list, freeing from the malloced (t[-1]) address. */
    p = t;
    while (p != 0) {
        q = (--p)->v.t;
        free(p);
        p = q;
    }
    return 0;
}
#include "AttributeInfo.h"

#define U2(var,data,index) var = data[index++] << 8; var |= data[index++];
#define U4(var,data,index) var = data[index++] << 24; var |= data[index++] << 16; var |= data[index++] << 8; var |= data[index++];

#include <iostream>

AttributeInfo::AttributeInfo(unsigned char *data, int &index) {
    U2(nameIndex,data,index);
    U4(length,data,index);
    this->data = new unsigned char[length];
    for (int i = 0; i < length; i++)
        this->data[i] = data[i+index];
    index += length;
}

AttributeInfo::~AttributeInfo() {
    delete [] data;
}
#include "ClassFile.h"
#include "ClassLoader.h"
#include "FieldInfo.h"
#include "MethodInfo.h"
#include "CPInfo.h"
#include "AttributeInfo.h"
#include "SJVM.h"
#include "Thread.h"

#include <cstring>
#include <map>
#include <vector>
#include <iostream>

//#define DEBUG_OUTPUT

#ifdef DEBUG_OUTPUT
#define debug(v) std::cout << v;
#else
#define debug(v)
#endif

#define U2(var,data,index) var = data[index++] << 8; var |= data[index++];

ClassFile::ClassFile(char *_name, SJVM *jvm) : name(_name) {
    thisClassIndex = 0;
    superClassIndex = 0;
    interfaceCount = 0;
    interfaceIndexes = 0;
    fieldCount = 0;
    fields = 0;
    methodCount = 0;
    methods = 0;
    attributeCount = 0;
    attributes = 0;
    instanceFields = 0;
    accessFlags = 0;
    cpCount = 0;
    cp = 0;
    
    interfaceMap["java/lang/Cloneable"] = jvm->loadClass("java/lang/Cloneable");
    interfaceMap["java/io/Serializable"] = jvm->loadClass("java/io/Serializable");
    
    arrayType = 1;
    superClass = jvm->loadClass("java/lang/Object");
    if (_name[1] == 'L' || _name[1] == '[') {
        componentType = jvm->loadClass(_name + 1);
    } else {
        componentType = 0;
    }
    type = jvm->loadClass("java/lang/Class");
    this->Object::fields = new Variable[type->instanceFields];
    type->prepFields(this);
}

ClassFile::ClassFile(unsigned char *data) : name("null") {
    arrayType = 0;
    componentType = 0;
    int index = 8;
    U2(cpCount, data, index);
    debug("Constant Pool Count " << cpCount << '\n');
    cp = new CPInfo*[cpCount];
    cp[0] = 0;
    for (int i = 1; i < cpCount; i++) {
        cp[i] = CPInfo::read(data, index);
        if (cp[i]->type == CPInfo::CONSTANT_Double || cp[i]->type == CPInfo::CONSTANT_Long) {
            cp[++i] = 0;
        }
        /*switch (cp[i]->type) {
            case CPInfo::CONSTANT_Long :
            {
                LongDoubleInfo *info = (LongDoubleInfo*) cp[i];
                debug(i << ": " << *(long long*)info->data << '\n');
                break;
            }
            case CPInfo::CONSTANT_Utf8 :
            {
                UTF8Info *info = (UTF8Info*) cp[i];
                debug(i << ": " << info->bytes << '\n');
                break;
            }
            case CPInfo::CONSTANT_String :
            {
                StringInfo *info = (StringInfo*) cp[i];
                debug(i << ": StringInfo: " << info->stringIndex << '\n');
                break;
            }
            case CPInfo::CONSTANT_NameAndType :
            {
                NameAndTypeInfo *info = (NameAndTypeInfo*) cp[i];
                debug(i << ": Name: " << info->nameIndex << " Type: " << info->descriptorIndex << '\n');
                break;
            }
            case CPInfo::CONSTANT_Fieldref :
            case CPInfo::CONSTANT_Methodref :
            case CPInfo::CONSTANT_InterfaceMethodref :
            {
                FieldMethodInfo *info = (FieldMethodInfo*) cp[i];
                debug(i << ": Class: " << info->classIndex << " NameAndType: " << info->nameAndTypeIndex << '\n');
                break;
            }
            case CPInfo::CONSTANT_Class :
            {
                ClassInfo *info = (ClassInfo*) cp[i];
                debug(i << ": ClassName: " << info->nameIndex << '\n');
                break;
            }
        }*/
    }
    U2(accessFlags, data, index);
    U2(thisClassIndex, data, index);
    debug("This Class " << thisClassIndex << '\n');
    U2(superClassIndex, data, index);
    debug("Super Class " << superClassIndex << '\n');
    U2(interfaceCount, data, index);
    debug("Interfaces Count " << interfaceCount << '\n');
    interfaceIndexes = new unsigned short int[interfaceCount];
    for (int i = 0; i < interfaceCount; i++) {
        U2(interfaceIndexes[i], data, index);
    }
    U2(fieldCount, data, index);
    debug("Field Count " << fieldCount << '\n');
    fields = new FieldInfo*[fieldCount];
    for (int i = 0; i < fieldCount; i++)
        fields[i] = new FieldInfo(data, index);
    U2(methodCount, data, index);
    debug("Method Count " << methodCount << '\n');
    methods = new MethodInfo*[methodCount];
    for (int i = 0; i < methodCount; i++) {
        methods[i] = new MethodInfo(data, index);
        UTF8Info *info = (UTF8Info*) cp[methods[i]->nameIndex];
        debug(i << ": " << info->bytes << '\n');
    }
    U2(attributeCount, data, index);
    debug("Attribute Count " << attributeCount << '\n');
    attributes = new AttributeInfo*[attributeCount];
    for (int i = 0; i < attributeCount; i++)
        attributes[i] = new AttributeInfo(data, index);
}

ClassFile::~ClassFile() {
    for (int i = 0; i < cpCount; i++)
        if (cp[i] != 0) delete cp[i];
    delete [] cp;
    delete [] interfaceIndexes;
    for (int i = 0; i < fieldCount; i++) {
        //if (fields[i]->staticObject)
        //    fields[i]->staticValue.l->staticCount--;
        delete fields[i];
    }
    delete [] fields;
    for (int i = 0; i < methodCount; i++)
        delete methods[i];
    delete [] methods;
    for (int i = 0; i < attributeCount; i++)
        delete attributes[i];
    delete [] attributes;
}

int ClassFile::validate(ClassLoader *loader, SJVM *jvm) {
    ClassInfo *cinfo = (ClassInfo*) cp[thisClassIndex];
    UTF8Info *uinfo = (UTF8Info*) cp[cinfo->nameIndex];
    name.clear();
    name.append(uinfo->bytes);
    debug("Validating " << name << '\n');
    if (superClassIndex != 0) {
        ClassInfo *cinfo = (ClassInfo*) cp[superClassIndex];
        UTF8Info *uinfo = (UTF8Info*) cp[cinfo->nameIndex];
        superClass = loader->load(uinfo->bytes, jvm);
        instanceFields = superClass->instanceFields;
    } else {
        superClass = 0;
        instanceFields = 0;
    }
    for (int i = 0; i < interfaceCount; i++) {
        ClassInfo *cinfo = (ClassInfo*) cp[interfaceIndexes[i]];
        UTF8Info *uinfo = (UTF8Info*) cp[cinfo->nameIndex];
        ClassFile *interface = loader->load(uinfo->bytes, jvm);
        interfaceMap[interface->name] = interface;
    }
    for (int i = 0; i < methodCount; i++) {
        UTF8Info *uinfo;
        uinfo = (UTF8Info*) cp[methods[i]->nameIndex];
        methods[i]->clazz = this;
        methods[i]->name.clear();
        methods[i]->name.append(uinfo->bytes);
        debug("\t-" << methods[i]->name << " ");
        uinfo = (UTF8Info*) cp[methods[i]->descriptorIndex];
        methods[i]->descriptor.clear();
        methods[i]->descriptor.append(uinfo->bytes);
        methods[i]->nargs = 0;
        methods[i]->argsc = 0;
        for (char *c = ((char*) methods[i]->descriptor.c_str()) + 1;; c++) {
            switch (*c) {
                case '[': 
                    continue;
                case ')':
                    switch(*(++c)) {
                        case 'V':
                            methods[i]->result = 0;
                            break;
                        case 'D':
                        case 'J':
                            methods[i]->result = 2;
                            break;
                        case 'L':
                        case '[':
                            methods[i]->resobject = 1;
                        default:
                            methods[i]->result = 1;
                    }
                    break;
                case 'L':
                    for (;*c != ';';c++);
                case 'Z':
                case 'C':
                case 'B':
                case 'S':
                case 'I':
                case 'F':
                    methods[i]->nargs++;
                    methods[i]->argsc++;
                    methods[i]->typeSz.push_back(1);
                    continue;
                case 'J':
                case 'D':
                    methods[i]->nargs+=2;
                    methods[i]->argsc++;
                    methods[i]->typeSz.push_back(2);
                    continue;
            }
            break;
        }
        debug(methods[i]->descriptor << '\n');
        methods[i]->code = 0;
        for (int c = 0; c < methods[i]->attributeCount; c++) {
            AttributeInfo *ainfo = methods[i]->attributes[c];
            char* name = ((UTF8Info*) cp[ainfo->nameIndex])->bytes;
            if (!strcmp(name, "Code")) {
                methods[i]->code = new Code(ainfo);
                break;
            }
        }
        methods[i]->full.clear();
        methods[i]->full.append(methods[i]->name);
        methods[i]->full.append(methods[i]->descriptor);
        methodMap[methods[i]->full] = methods[i];
    }
    if (superClass)
        objectIndexes = superClass->objectIndexes;
    debug("Starting with " << objectIndexes.size() << " Object Fields\n");
    for (int i = 0; i < fieldCount; i++) {
        UTF8Info *uinfo;
        uinfo = (UTF8Info*) cp[fields[i]->nameIndex];
        fields[i]->name.clear();
        fields[i]->name.append(uinfo->bytes);
        debug("\t-" << fields[i]->name << ' ');
        uinfo = (UTF8Info*) cp[fields[i]->descriptorIndex];
        fields[i]->descriptor.clear();
        fields[i]->descriptor.append(uinfo->bytes);
        debug(fields[i]->descriptor << '\n');
        if (fields[i]->accessFlags & 0x0008) { //static
            fields[i]->index = -1;
            switch (fields[i]->descriptor.c_str()[0]) {
                case 'Z':
                    fields[i]->staticValue.z = 0;
                    break;
                case 'B':
                    fields[i]->staticValue.b = 0;
                    break;
                case 'C':
                    fields[i]->staticValue.c = 0;
                    break;
                case 'S':
                    fields[i]->staticValue.s = 0;
                    break;
                case 'F':
                    fields[i]->staticValue.f = 0.0;
                    break;
                case 'D':
                    fields[i]->staticValue.d = 0.0;
                    break;
                case 'I':
                    fields[i]->staticValue.i = 0;
                    break;
                case 'J':
                    fields[i]->staticValue.j = 0;
                    break;
                case 'L':
                case '[':
                    fields[i]->staticValue.l = 0;
                    fields[i]->staticObject = 1;
                    break;
                default:
                    debug("Invalid descriptor\n");
            }
        } else {
            instanceFields++;
            fields[i]->index = instanceFields - 1;
            if (fields[i]->descriptor.c_str()[0] == 'L' || fields[i]->descriptor.c_str()[0] == '[')
                objectIndexes.push_back(instanceFields - 1);
        }
        fieldMap[fields[i]->name] = fields[i];
    }
    type = loader->load("java/lang/Class",jvm);
    Object::fields = new Variable[type->instanceFields];
    type->prepFields(this);
    if (methodMap.find("<clinit>()V") != methodMap.end()) {
        debug("Running static initilizer\n");
        MethodInfo *info = methodMap["<clinit>()V"];
        Thread *thread = Thread::getThread(jvm);
        jvm->execute(info,this, thread,0,0,&thread->nativeException);
    }
    return 0;
}

//ONLY PLACE NEW OBJECTS ARE CREATED... Minus native ones
Object* ClassFile::newInstance(SJVM *sjvm) {
    if (arrayType) return 0; //use newArray
    Object* ref = new Object();
    sjvm->gc->reg(ref);
    debug("New " << this->name << " allocated\n");
    ref->type = this;
    ref->fields = new Variable[instanceFields];
    prepFields(ref);
    return ref;
}

void ClassFile::prepFields(Object *ref) {
    debug("Prepping " << this->name << " fields\n");
    if (superClass != 0) superClass->prepFields(ref);
    for (std::map<std::string, FieldInfo*>::iterator iter = fieldMap.begin(); iter != fieldMap.end(); iter++) {
        FieldInfo* info = iter->second;
        if (info->index >= 0) {
            debug(info->index << ": " << iter->first << '\n');
            switch (info->descriptor.c_str()[0]) {
                case 'Z':
                    ref->fields[info->index].z = 0;
                    break;
                case 'B':
                    ref->fields[info->index].b = 0;
                    break;
                case 'C':
                    ref->fields[info->index].c = 0;
                    break;
                case 'S':
                    ref->fields[info->index].s = 0;
                    break;
                case 'F':
                    ref->fields[info->index].f = 0.0;
                    break;
                case 'D':
                    ref->fields[info->index].d = 0.0;
                    break;
                case 'I':
                    ref->fields[info->index].i = 0;
                    break;
                case 'J':
                    ref->fields[info->index].j = 0;
                    break;
                case 'L':
                case '[':
                    ref->fields[info->index].l = 0;
                    break;
                default:
                    debug("Invalid descriptor\n");
            }
        }
    }
}

JINT ClassFile::instanceOf(Object *ref) {
    debug((int)ref->type << ref->type->name << " instanceof " << name << '\n');
    if (ref->type->arrayType) {
        if (superClass == 0) return 1;
        for (JCLASS type = ref->type; type != 0; type = type->superClass) {
            debug("subclass...? " << type->name << '\n');
            if (type == this) return 1;
            for (std::map<std::string,ClassFile*>::iterator iter = type->interfaceMap.begin(); iter != type->interfaceMap.end(); iter++) {
                debug("implements...? " << iter->second->name << '\n');
                if (iter->second == this) return 1;
            }
        }
        /*for (JCLASS type = ref->type->componentType; type != 0; type = type->superClass) {debug("subclass...? " << type->name << '\n');
            if (type == componentType) return 1;
            for (std::map<std::string,ClassFile*>::iterator iter = type->interfaceMap.begin(); iter != type->interfaceMap.end(); iter++) {
                debug("implements...? " << iter->second->name << '\n');
                if (iter->second == componentType) return 1;
            }
        }*/
        return 0;
    } else {
        if (superClass == 0) return 1;
        for (JCLASS type = ref->type; type != 0; type = type->superClass) {
            debug("subclass...? " << type->name << '\n');
            if (type == this) return 1;
            for (std::map<std::string,ClassFile*>::iterator iter = type->interfaceMap.begin(); iter != type->interfaceMap.end(); iter++) {
                debug("implements...? " << iter->second->name << '\n');
                if (iter->second == this) return 1;
            }
        }
        return 0;
    }
}
#include "Arrays.h"
#include "ClassFile.h"
#include "SJVM.h"
#include "ClassLoader.h"
#include "Thread.h"
#include "Exception.h"

#include <iostream>
#include <fstream>
#include <string>

//#define DEBUG_OUTPUT

#ifdef DEBUG_OUTPUT
#define debug(v) std::cout << v;
#else
#define debug(v)
#endif

FolderClassPath::FolderClassPath(const char* cpath) : path(cpath) {

}

int FolderClassPath::request(const char *name, unsigned char *&data) {
    std::string fpath(path);
    fpath.append(name);
    fpath.append(".class");
    std::ifstream file(fpath.c_str(), std::ios::in | std::ios::binary | std::ios::ate);
    if (file.is_open()) {
        int size = file.tellg();
        data = new unsigned char[size];
        file.seekg(0, std::ios::beg);
        file.read((char*) data, size);
        file.close();
        return 0;
    }
    return -1;
}

void FolderClassPath::release(unsigned char *data) {
    delete [] data;
}

void BootstrapClassPath::add(ClassPath* path) {
    paths.push_back(path);
}

BootstrapClassPath::~BootstrapClassPath() {
    for (int i = 0; i < paths.size(); i++) {
        delete paths[i];
    }
}

int BootstrapClassPath::request(const char* name, unsigned char *&data) {
    for (int i = 0; i < paths.size(); i++) {
        if (paths[i]->request(name, data) == 0) {
            mapped[data] = paths[i];
            return 0;
        }
    }
    return 1;
}

void BootstrapClassPath::release(unsigned char* data) {
    mapped[data]->release(data);
    mapped.erase(data);
}

ClassLoader::ClassLoader(ClassPath *classpath) {
    bootstrap = classpath;
}

ClassFile* ClassLoader::load(const char* name, SJVM *jvm) {
    mutex.lock();
    if (classes.find(name) == classes.end()) {
        unsigned char *data;
        debug("Loading class " << name << '\n');
        if (name[0] == '[') {
            debug("Array Type detected\n");
            ClassFile *atype = new ClassFile((char*)name, jvm);
            classes[name] = atype;
            return atype;
        }
        if (bootstrap->request(name, data)) {
            Thread *thread = Thread::getThread(jvm);
            JNIEnv* env = thread->getEnv();
            jclass clazz = env->FindClass("java/lang/ClassNotFoundException");
            jmethodID id = env->GetMethodID(clazz, "<init>", "(Ljava/lang/String;)V");
            JOBJECT obj = (JOBJECT) env->NewObject(clazz, id, env->NewStringUTF(name));
            thread->nativeException = new Exception(0, 0, obj);
            return 0;
        }
        ClassFile *classfile = new ClassFile(data);
        bootstrap->release(data);
        classes[name] = classfile;
        classfile->validate(this, jvm);
        return classfile;
    }
    debug("Class " << name << " Cached\n");
    ClassFile *result = classes[name];
    mutex.unlock();
    return result;
}

ClassLoader::~ClassLoader() {
    mutex.lock();
    for (std::map<std::string, ClassFile*>::iterator iter = classes.begin(); iter != classes.end(); iter++) {
        debug("Freeing class " << iter->second->name << '\n');
        delete iter->second;
    }
    classes.clear();
    delete bootstrap;
    mutex.unlock();
}
#include "CPInfo.h"
#include "FieldInfo.h"
#include "MethodInfo.h"

#include <iostream>

#define U2(var,data,index) var = data[index++] << 8; var |= data[index++];

CPInfo::CPInfo(char type) {
    this->type = type;
}

CPInfo* CPInfo::read(unsigned char *data, int &index) {
    switch (data[index]) {
        case CONSTANT_Class:
            return new ClassInfo(data,index);
        case CONSTANT_Fieldref:
        case CONSTANT_Methodref:
        case CONSTANT_InterfaceMethodref:
            return new FieldMethodInfo(data,index);
        case CONSTANT_String:
            return new StringInfo(data,index);
        case CONSTANT_Integer:
        case CONSTANT_Float:
            return new IntegerFloatInfo(data,index);
        case CONSTANT_Long:
        case CONSTANT_Double:
            return new LongDoubleInfo(data,index);
        case CONSTANT_NameAndType:
            return new NameAndTypeInfo(data,index);
        case CONSTANT_Utf8:
            return new UTF8Info(data,index);
    }
    return 0;
}

UTF8Info::UTF8Info(unsigned char *data, int &index) : CPInfo(data[index++]) {
    U2(size,data,index);
    bytes = new char[size+1];
    for (int i = 0; i < size; i++) 
        bytes[i] = data[i+index];
    bytes[size] = 0;
    index += size;
}

UTF8Info::~UTF8Info() {
    delete [] bytes;
}

StringInfo::StringInfo(unsigned char *data, int &index) : CPInfo(data[index++]) {
    U2(stringIndex,data,index);
}

NameAndTypeInfo::NameAndTypeInfo(unsigned char *data, int &index) : CPInfo(data[index++]) {
    U2(nameIndex,data,index);
    U2(descriptorIndex,data,index);
}

LongDoubleInfo::LongDoubleInfo(unsigned char *data, int &index) : CPInfo(data[index++]) {
    for (int i = 0; i < 8; i++) 
        this->data[i] = data[7-i+index];
    index += 8;
}

IntegerFloatInfo::IntegerFloatInfo(unsigned char *data, int &index) : CPInfo(data[index++]) {
    for (int i = 0; i < 4; i++) 
        this->data[i] = data[3-i+index];
    index += 4;
}

FieldMethodInfo::FieldMethodInfo(unsigned char *data, int &index) : CPInfo(data[index++]) {
    U2(classIndex,data,index);
    U2(nameAndTypeIndex,data,index);
    fieldRef = 0;
    methodRef = 0;
}

ClassInfo::ClassInfo(unsigned char *data, int &index) : CPInfo(data[index++]) {
    U2(nameIndex,data,index);
    classRef = 0;
}
#include "Exception.h"
#include "Object.h"
#include "ClassFile.h"
#include <iostream>

//#define DEBUG_OUTPUT

#ifdef DEBUG_OUTPUT
#define debug(v) std::cout << v;
#else
#define debug(v)
#endif

Exception::Exception(ClassFile* clazz, MethodInfo* method, Exception* parent) {
    this->clazz = clazz;
    this->method = method;
    this->parent = parent;
    this->cause = parent->cause;
    debug("Pushed Exception " << (int)cause->type << ' ' << cause->type->name<< '\n');
}

Exception::Exception(ClassFile* clazz, MethodInfo* method, JOBJECT cause) {
    this->clazz = clazz;
    this->method = method;
    this->parent = 0;
    this->cause = cause;
    debug("New Exception " << (int)cause->type << ' ' << cause->type->name<< '\n');
}

Exception::~Exception() {
    if (parent != 0) delete parent;
}

JOBJECT Exception::getCause() {
    debug("Cause Type: " << (int) cause->type << '\n');
    return cause;
}
#include "FieldInfo.h"
#include "AttributeInfo.h"

#define U2(var,data,index) var = data[index++] << 8; var |= data[index++];

FieldInfo::FieldInfo(unsigned char *data, int &index) {
    staticObject = 0;
    U2(accessFlags,data,index);
    U2(nameIndex,data,index);
    U2(descriptorIndex,data,index);
    U2(attributeCount,data,index);
    attributes = new AttributeInfo*[attributeCount];
    for (int i = 0; i < attributeCount; i++) 
        attributes[i] = new AttributeInfo(data, index);
}

FieldInfo::~FieldInfo() {
    for (int i = 0; i < attributeCount; i++) 
        delete attributes[i];
    delete [] attributes;
}

#include "ClassFile.h"

#include <set>
#include <iostream>
#include <cstring>
#include <vector>

#include "ClassFile.h"
#include "GarbageCollector.h"
#include "Object.h"
#include "Thread.h"
#include "Arrays.h"

#define WARNING_OUTPUT
//#define DEBUG_OUTPUT

#ifdef DEBUG_OUTPUT
#define debug(v) std::cout << v;
#else
#define debug(v)
#endif

#ifdef WARNING_OUTPUT
#define warn(v) std::cout << "WARNING: " << v;
#else
#define warn(v)
#endif


LocalGC::LocalGC(GlobalGC *gc, Thread *thread) {
    parent = gc;
    gc->mutex.lock();
    oldLocal = thread->nativeLocal;
    thread->nativeLocal = this;
    this->thread = thread;
    gc->locals.insert(this);
    gc->mutex.unlock();
    debug("Local GC Init\n");
}

LocalGC::~LocalGC() {
    parent->mutex.lock();
    thread->nativeLocal = oldLocal;
    parent->locals.erase(this);
    for (std::set<Object*>::iterator iter = roots.begin(); iter != roots.end(); iter++) {
        Object *obj = *iter;
        debug("GC: " << obj->refCount << ' ' << obj->staticCount << ' ' << obj->localCount << ' ' << (int)obj << '\n');
        obj->localCount--;
        if (obj->refCount || obj->staticCount || obj->localCount) 
            continue;
        parent->clean(obj);
    }
    roots.clear();
    parent->mutex.unlock();
    debug("Local GC Out of Focus\n");
}

void LocalGC::addLocal(Object* obj) {
    if (!obj) return;
    debug("Local Added: " << (int)obj << '\n');
    debug("GC: " << obj->refCount << ' ' << obj->staticCount << ' ' << obj->localCount << ' ' << (int)obj << '\n');
    parent->mutex.lock();
    if (roots.find(obj) == roots.end()) {
        roots.insert(obj);
        obj->localCount++;
    }
    parent->mutex.unlock();
}

void LocalGC::removeLocal(Object* obj) {
    if (!obj) return;
    debug("Local Removed: " << (int)obj << '\n');
    debug("GC: " << obj->refCount << ' ' << obj->staticCount << ' ' << obj->localCount << ' ' << (int)obj << '\n');
    parent->mutex.lock();
    if (roots.find(obj) != roots.end()) {
        debug("haha\n");
        roots.erase(obj);
        obj->localCount--;
    }
    parent->mutex.unlock();
}

GlobalGC::GlobalGC() {
    
}

GlobalGC::~GlobalGC() {
    sweep();
    mutex.lock();
    for (std::set<LocalGC*>::iterator iter = locals.begin(); iter != locals.end(); iter = locals.begin()) {
        delete (*iter); //dangerous to force, but thread safe
    }
    for (std::set<Object*>::iterator iter = objects.begin(); iter != objects.end(); iter++) {
        delete *iter;
    }
    mutex.unlock();
}

void GlobalGC::sweep() {
}

void GlobalGC::clean(Object* object) {
    if (!object) return;
    debug("Cleaning " << (int) object << ' ');
    if (object->type) {
        if (object->type->arrayType && object->type->componentType) {
            JOBJECTARRAY array = (JOBJECTARRAY)object;
            for (int i = 0; i < array->size; i++) {
                decrRef(array->array[i]);
            }
        }
        debug(object->type->name << '\n');
        std::vector<unsigned int> indexes = object->type->objectIndexes;
        Variable *fields = new Variable[object->type->instanceFields];
        memcpy(fields,object->fields,object->type->instanceFields*sizeof(Variable));
        for (int i = 0; i < indexes.size(); i++) {
            debug("decrref1\n");
            decrRef(fields[indexes[i]].l);
            debug("decrref2\n");
        }
    } else {
        debug("Untyped\n"); 
    }
    debug("cleaned\n");
    if (objects.find(object) != objects.end()) {
        objects.erase(object);
        debug("deleting\n");
        delete object;
        debug("deleted\n");
    }
}

void GlobalGC::incrPersist(Object* obj) {
    if (!obj) return;
    debug("Incr Persist: " << (int)obj << '\n');
    debug("GC: " << obj->refCount << ' ' << obj->staticCount << ' ' << obj->localCount << ' ' << (int)obj << '\n');
    mutex.lock();
    obj->staticCount++;
    mutex.unlock();
}

void GlobalGC::decrPersist(Object* obj) {
    if (!obj) return;
    mutex.lock();
    debug("Decr Persist: " << (int)obj << '\n');
    debug("GC: " << obj->refCount << ' ' << obj->staticCount << ' ' << obj->localCount << ' ' << (int)obj << '\n');
    mutex.lock();
    obj->staticCount--;
    if (!(obj->refCount || obj->staticCount || obj->localCount)) {
        clean(obj);
    }
    mutex.unlock();
}

void GlobalGC::incrRef(Object* obj) {
    if (!obj) return;
    debug("Incr Ref: " << (int)obj << '\n');
    debug("GC: " << obj->refCount << ' ' << obj->staticCount << ' ' << obj->localCount << ' ' << (int)obj << '\n');
    mutex.lock();
    obj->refCount++;
    mutex.unlock();
}

void GlobalGC::decrRef(Object* obj) {
    if (!obj) return;
    debug("Decr Ref: " << (int)obj << '\n');
    debug("GC: " << obj->refCount << ' ' << obj->staticCount << ' ' << obj->localCount << ' ' << (int)obj << '\n');
    mutex.lock();
    obj->refCount--;
    if (!(obj->refCount || obj->staticCount || obj->localCount)) {
        clean(obj);
    }
    mutex.unlock();
}

void GlobalGC::reg(Object *obj) {
    objects.insert(obj);
}
#include <sstream>

#include "jni.h"
#include "Arrays.h"
#include "ClassFile.h"
#include "SJVM.h"
#include <iostream>
#include <string>

//#define DEBUG_OUTPUT

#ifdef DEBUG_OUTPUT
#define debug(v) std::cout << v;
#else
#define debug(v)
#endif

extern "C" void JNICALL Java_gnu_classpath_VMSystemProperties_preInit(JNIEnv* env, jclass type, jobject properties) {
    jclass props = env->FindClass("java/util/Properties");
    jmethodID set = env->GetMethodID(props, "setProperty", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;");
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.version"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.vendor"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.vendor.url"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.home"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.vm.specification.version"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.vm.specification.vendor"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.vm.specification.name"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.vm.version"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.vm.vendor"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.vm.name"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.specification.version"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.specification.vendor"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.specification.name"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.class.version"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.class.path"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.library.path"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.io.tmpdir"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.compiler"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("java.ext.dirs"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("os.name"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("os.arch"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("os.version"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("file.separator"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("path.separator"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("line.separator"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("user.name"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("user.home"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("user.dir"), env->NewStringUTF(""));
    env->CallObjectMethod(properties, set, env->NewStringUTF("gnu.cpu.endian"), env->NewStringUTF(""));
}

extern "C" void JNICALL Java_java_lang_VMSystem_arraycopy(JNIEnv* env, jclass type, jobject src, jint sstart, jobject dest, jint dstart, jint length) {
    JBYTEARRAY s = (JBYTEARRAY) src;
    JBYTEARRAY d = (JBYTEARRAY) dest;
    debug(d->elemsz << ' ' << s->elemsz << ' ' << sstart << ' ' << dstart << ' ' << length << '\n');
    memcpy(d->array + d->elemsz*dstart, s->array + s->elemsz*sstart, s->elemsz * length);
}

extern "C" jobject JNICALL Java_java_lang_VMObject_clone(JNIEnv* env, jclass type, jobject cloner) {
    JOBJECT obj = (JOBJECT)cloner;
    JCLASS cls = obj->type;
    if (cls->arrayType) {
        return (jobject) ((JBYTEARRAY)obj)->clone();
    } else {
        JOBJECT clone = cls->newInstance((SJVM*) env->functions->reserved0); //No need to add it to the gc, done on return
        memcpy(clone->fields,obj->fields,cls->instanceFields*sizeof(Variable));
        for (int i = 0; i < cls->objectIndexes.size(); i++) 
            ((SJVM*)env->functions->reserved0)->gc->incrRef(clone->fields[cls->objectIndexes[i]].l);
        return (jobject) clone;
    }
}

extern "C" jstring JNICALL Java_java_lang_VMDouble_toString(JNIEnv* env, jclass type, jdouble val, jboolean isfloat) {
    std::stringstream stream;
    stream << val;
    return env->NewStringUTF(stream.str().c_str());
}

extern "C" jclass JNICALL Java_java_lang_VMObject_getClass(JNIEnv* env, jclass type, jobject obj) {
    return (jclass) ((JOBJECT)obj)->type;
}

extern "C" jstring JNICALL Java_java_lang_VMClass_getName(JNIEnv* env, jclass type, jclass cls) {
    return env->NewStringUTF(((JCLASS)cls)->name.c_str());
}

#include "Jar.h"
#include "Inflate.h"
#include "ClassLoader.h"

#include <iostream>
#include <fstream>
#include <map>
#include <cstring>

//#define DEBUG_OUTPUT

#ifdef DEBUG_OUTPUT
#define debug(v) std::cout << v;
#else
#define debug(v)
#endif

JarFile::JarFile(char* fpath) : path(fpath) {
    open();
}

JarFile::~JarFile() {
    for (std::map<std::string, FileHeader*>::iterator iter = files.begin(); iter != files.end(); iter++) {
        FileHeader *info = iter->second;
        if (info->fname_len > 0) delete [] info->file_name;
        delete info;
    }
    files.clear();
}

std::string JarFile::getPath() {
    return path;
}

int JarFile::open() {
    std::ifstream file(path.c_str(), std::ios::in | std::ios::binary | std::ios::ate);
    if (!file.is_open())
        return -1;
    int size = file.tellg();
    unsigned char *data = new unsigned char[size];
    file.seekg(0, std::ios::beg);
    file.read((char*) data, size);
    file.close();
    if (*(unsigned int*) data != 0x04034b50) {
        return -1;
        delete[] data;
    }
    readCentralDirectory(data, size);
    delete[] data;
    return 0;
}

void JarFile::readCentralDirectory(unsigned char * data, long len) {
    unsigned char * tmp = data;
    unsigned long int * tmp2 = (unsigned long int *) tmp;
    len -= 4;
    while ((*tmp2) != 0x02014b50 && len) {
        tmp++;
        tmp2 = (unsigned long int *) tmp;
        len--;
    }
    int size;
    do {
        FileHeader fhdr;
        size = readFileHeader(tmp, &fhdr);
        if (size) {
            if (files.find(fhdr.file_name) == files.end()) {
                FileHeader *pfhdr = new FileHeader;
                *pfhdr = fhdr;
                files[fhdr.file_name] = pfhdr;
            } else {
                if (fhdr.fname_len > 0) delete [] fhdr.file_name;
            }
        }
        tmp += size;
    } while (size != 0);
}

int JarFile::readFileHeader(unsigned char * data, FileHeader * hdr) {
#define U1(buf,o) buf[o]
#define U2(buf,o) (buf[o+1] << 8) | buf[o]
#define U3(buf,o) (buf[o+2] << 16) | (buf[o+1] << 8) | buf[o]
#define U4(buf,o) (buf[o+3] << 24) | (buf[o+2] << 16) | (buf[o+1] << 8) | buf[o]
    unsigned char * origdata = data;
    std::string m_stData, st_temp;
    unsigned int sig = U4(data, 0);
    if (sig != 0x02014b50) return 0;
    hdr->bitflags = U2(data, 8);
    hdr->comp_method = U2(data, 10);
    hdr->comp_size = U4(data, 20);
    hdr->uncompr_size = U4(data, 24);
    hdr->fname_len = U2(data, 28);
    int extralen = U2(data, 30);
    int commentlen = U2(data, 32);
    hdr->relative_offset = U4(data, 42);
    data += 46;
    if (hdr->fname_len > 0) {
        char *fn;
        fn = new char[hdr->fname_len + 1];
        strncpy(fn, (char*) data, hdr->fname_len);
        fn[hdr->fname_len] = '\0';
        hdr->file_name = fn;
    }
    return (data + hdr->fname_len + commentlen + extralen - origdata);
}

int JarFile::request(const char* name, unsigned char *&data) {
    std::string sname(name);
    sname.append(".class");
    if (files.find(sname) == files.end()) {
        data = 0;
        return -1;
    }
    FileHeader *header = files[sname];
    int offset = header->relative_offset;
    int cprSize = header->comp_size;
    if (cprSize == 0) {
        data = new unsigned char[4]; //Give it something
        return 0; //essentially a success
    }
    int ucprSize = header->uncompr_size;
    debug(name << ' ' << offset << ' ' << cprSize << ' ' << ucprSize << '\n');
    unsigned char *buffer = new unsigned char[cprSize];
    std::ifstream file(path.c_str(), std::ios::in | std::ios::binary);
    if (!file.is_open()) {
        data = 0;
        return -1;
    }
    debug("grabbing data");
    unsigned short int extralen, namelen;
    file.seekg(header->relative_offset + 26, std::ios::beg);
    file.read((char*) & namelen, 2);
    file.read((char*) & extralen, 2);
    debug(' ' << extralen << ' ' << namelen << '\n');
    file.seekg(namelen + extralen, std::ios::cur);
    file.read((char*) buffer, cprSize);
    file.close();
    switch (header->comp_method) {
        case COMPRESSION_STORED:
            data = buffer;
            return 0;
        case COMPRESSION_DEFLATED:
            data = new unsigned char[ucprSize];
            if (inflate_oneshot(buffer, cprSize, data, ucprSize) == 0) {
                delete [] buffer;
                return 0;
            }
        case COMPRESSION_SHRUNK:
        case COMPRESSION_REDUCED1:
        case COMPRESSION_REDUCED2:
        case COMPRESSION_REDUCED3:
        case COMPRESSION_REDUCED4:
        case COMPRESSION_IMPLODED:
        case COMPRESSION_TOKENIZED:
        default:
            delete [] buffer;
            return -1;
    }
}

void JarFile::release(unsigned char *data) {
    delete[] data;
}

#include "GarbageCollector.h"
#include "FieldInfo.h"
#include "SJVM.h"
#include "Thread.h"
#include "Exception.h"
#include "GarbageCollector.h"
#include "ClassFile.h"
#include "MethodInfo.h"
#include "Types.h"
#include "CPInfo.h"
#include "Arrays.h"
#include "Object.h"
#include "Thread.h"
#include "Jar.h"

#include "jni.h"
#include "SJVM.h"
#include "ClassLoader.h"

#include <iostream>
#include <string>
#include <cstring>
#include <stdlib.h>

//#define DEBUG_OUTPUT

#ifdef DEBUG_OUTPUT
#define debug(v) std::cout << v;
#else
#define debug(v)
#endif


static int java_major_version = 1;
static int java_minor_version = 1;
extern struct JNINativeInterface_ SJVM_JNINativeInterface;
extern JavaVM SJVM_JavaVM;
extern struct JNIEnv_ SJVM_JNIEnv;
static JNICALL jint SJVM_GetVersion(JNIEnv*);
static JNICALL jclass SJVM_FindClass(JNIEnv*, const char*);
static JNICALL jint SJVM_ThrowNew(JNIEnv*, jclass, const char*);
static JNICALL jint SJVM_Throw(JNIEnv* env, jobject obj);

inline Variable callV(SJVM* sjvm, Thread* thread, MethodInfo* meth, jobject obj, va_list args, Exception** thrown) {
    debug("JNI: CallV\n");
    long argsarr[meth->nargs + 1];
    argsarr[0] = (long) obj;
    for (int i = 0, c = 1; i < meth->argsc; i++) {
        if (meth->typeSz[i] == 2) {
            long long a = va_arg(args, long long);
            *(long long*) &argsarr[c] = a;
            c += 2;
        } else {
            long a = va_arg(args, long);
            *(long*) &argsarr[c] = a;
            c++;
        }
    }
    Variable res = sjvm->execute(meth, meth->clazz, thread, argsarr, meth->nargs + 1, thrown);
    if (meth->resobject) thread->nativeLocal->addLocal(res.l);
    return res;
}

inline Variable callVirtualV(SJVM* sjvm, Thread* thread, MethodInfo* meth, jobject obj, va_list args, Exception** thrown) {
    debug("JNI: CallV\n");
    long argsarr[meth->nargs + 1];
    argsarr[0] = (long) obj;
    for (int i = 0, c = 1; i < meth->argsc; i++) {
        if (meth->typeSz[i] == 2) {
            long long a = va_arg(args, long long);
            *(long long*) &argsarr[c] = a;
            c += 2;
        } else {
            long a = va_arg(args, long);
            *(long*) &argsarr[c] = a;
            c++;
        }
    }
    for (ClassFile *type = ((JOBJECT) obj)->type; type != 0; type = type->superClass) {
        if (type->methodMap.find(meth->full) != type->methodMap.end()) {
            MethodInfo *invoke = type->methodMap[meth->full];
            Variable res = sjvm->execute(invoke, invoke->clazz, thread, argsarr, meth->nargs + 1, thrown);
            if (invoke->resobject) thread->nativeLocal->addLocal(res.l);
            return res;
        }
    }
}

inline Variable callStaticV(SJVM* sjvm, Thread* thread, MethodInfo* meth, va_list args, Exception** thrown) {
    debug("JNI: CallStaticV\n");
    long argsarr[meth->nargs];
    for (int i = 0, c = 0; i < meth->argsc; i++) {
        if (meth->typeSz[i] == 2) {
            long long a = va_arg(args, long long);
            *(long long*) &argsarr[c] = a;
            c += 2;
        } else {
            long a = va_arg(args, long);
            *(long*) &argsarr[c] = a;
            c++;
        }
    }
    Variable res = sjvm->execute(meth, meth->clazz, thread, argsarr, meth->nargs, thrown);
    if (meth->resobject) thread->nativeLocal->addLocal(res.l);
    return res;
}

inline Variable callA(SJVM* sjvm, Thread* thread, MethodInfo* meth, jobject obj, const jvalue* args, Exception** thrown) {
    debug("JNI: CallA\n");
    long argsarr[meth->nargs + 1];
    argsarr[0] = (long) obj;
    for (int i = 0, c = 1; i < meth->argsc; i++) {
        if (meth->typeSz[i] == 2) {
            *(long long*) &argsarr[c] = args[i].j;
            c += 2;
        } else {
            *(long*) &argsarr[c] = args[i].i;
            c++;
        }
    }
    Variable res = sjvm->execute(meth, meth->clazz, thread, argsarr, meth->nargs + 1, thrown);
    if (meth->resobject) thread->nativeLocal->addLocal(res.l);
    return res;
}

inline Variable callVirtualA(SJVM* sjvm, Thread* thread, MethodInfo* meth, jobject obj, const jvalue* args, Exception** thrown) {
    debug("JNI: CallA\n");
    long argsarr[meth->nargs + 1];
    argsarr[0] = (long) obj;
    for (int i = 0, c = 1; i < meth->argsc; i++) {
        if (meth->typeSz[i] == 2) {
            *(long long*) &argsarr[c] = args[i].j;
            c += 2;
        } else {
            *(long*) &argsarr[c] = args[i].i;
            c++;
        }
    }
    for (ClassFile *type = ((JOBJECT) obj)->type; type != 0; type = type->superClass) {
        if (type->methodMap.find(meth->full) != type->methodMap.end()) {
            MethodInfo *invoke = type->methodMap[meth->full];
            Variable res = sjvm->execute(invoke, invoke->clazz, thread, argsarr, meth->nargs + 1, thrown);
            if (invoke->resobject) thread->nativeLocal->addLocal(res.l);
            return res;
        }
    }
}

inline Variable callStaticA(SJVM* sjvm, Thread* thread, MethodInfo* meth, const jvalue* args, Exception** thrown) {
    debug("JNI: CallStaticA\n");
    long argsarr[meth->nargs];
    for (int i = 0, c = 0; i < meth->argsc; i++) {
        if (meth->typeSz[i] == 2) {
            *(long long*) &argsarr[c] = args[i].j;
            c += 2;
        } else {
            *(long*) &argsarr[c] = args[i].i;
            c++;
        }
    }
    Variable res = sjvm->execute(meth, meth->clazz, thread, argsarr, meth->nargs, thrown);
    if (meth->resobject) thread->nativeLocal->addLocal(res.l);
    return res;
}

extern "C" jint JNICALL JNI_GetDefaultJavaVMInitArgs(void* args_) {
    JavaVMInitArgs *args = (JavaVMInitArgs*) args_;
    if (args->version != ((java_major_version << 16) | java_minor_version)) {
        return JNI_EVERSION;
    }
    args->version = (java_major_version << 16) | java_minor_version;
    return JNI_OK;
}

extern "C" jint JNICALL JNI_CreateJavaVM(JavaVM** vm, void** env_, void* args_) {
    JavaVMInitArgs *args = (JavaVMInitArgs*) args_;
    JNIEnv **env = (JNIEnv**) env_;
    if (args->version != ((java_major_version << 16) | java_minor_version)) {
        return JNI_EVERSION;
    }
    int count = args->nOptions;
    BootstrapClassPath *path = new BootstrapClassPath;
    path->add(new JarFile((char*)"/usr/share/classpath/glibj.zip"));
    path->add(new JarFile((char*)"/usr/share/classpath/tools.zip"));
    for (int i = 0; i < count; i++) {
        path->add(new FolderClassPath(args->options[i].optionString));
    }
    SJVM *sjvm = new SJVM(path);
    *vm = sjvm->getJavaVM();
    Thread *thread = Thread::getThread(sjvm);
    *env = thread->getEnv();
    return 0;
}

extern "C" jint JNICALL JNI_GetCreatedJavaVMs(JavaVM** vm, jsize buflen, jsize* nvm) {
    return JNI_ERR;
}

extern JNICALL void SJVM_FatalError(JNIEnv* env, const char* mess) {
    fprintf(stderr, "FATAL ERROR: %s\n", mess);
    exit(1);
}

extern JNICALL void SJVM_DeleteGlobalRef(JNIEnv* env, jref obj) {
    ((SJVM*) env->functions->reserved0)->gc->decrPersist((JOBJECT) obj);
}

extern JNICALL void SJVM_DeleteLocalRef(JNIEnv* env, jref obj) {
    //do nothing, force not the local deletion
}

extern JNICALL jboolean SJVM_IsSameObject(JNIEnv* env, jobject obj1, jobject obj2) {
    return obj1 == obj2 ? JNI_TRUE : JNI_FALSE;
}

extern JNICALL void SJVM_ReleaseStringChars(JNIEnv* env, jstring data, const jchar* chars) {
    //do nothing, always the chars returned they are
}

extern JNICALL jint SJVM_GetVersion(JNIEnv* env) {
    return ((java_major_version << 16) | java_minor_version);
}

extern JNICALL jref SJVM_NewGlobalRef(JNIEnv* env, jref obj) { //Create global ref
    ((SJVM*) env->functions->reserved0)->gc->incrPersist((JOBJECT) obj);
    return obj;
}

extern JNICALL jclass SJVM_DefineClass(JNIEnv* env, const char *name, jobject loader, const jbyte *buf, jsize len) { //Define the class
    //FIXME load it
    return 0;
}

extern JNICALL jclass SJVM_FindClass(JNIEnv* env, const char* name) { //Use Class.ForName
    return (jclass) ((SJVM*) env->functions->reserved0)->loadClass(name);
}

extern JNICALL jclass SJVM_GetSuperClass(JNIEnv* env, jclass cls) {
    return (jclass) ((JCLASS) cls)->superClass;
}

extern JNICALL jboolean SJVM_IsAssignableFrom(JNIEnv* env, jclass cls1, jclass cls2) {
    return 0; //FIXME what?
}

extern JNICALL jint SJVM_Throw(JNIEnv* env, jthrowable obj) { //Post Exception
    ((Thread*) env->functions->reserved1)->nativeException = new Exception(0, 0, (JOBJECT) obj);
}

extern JNICALL jint SJVM_ThrowNew(JNIEnv* env, jclass cls, const char* mess) { //Create exception & post it
    return 0; //FIXME what?
}

extern JNICALL jthrowable SJVM_ExceptionOccurred(JNIEnv* env) {
    return (jthrowable) ((Thread*) env->functions->reserved1)->nativeException;
}

extern JNICALL void SJVM_ExceptionDescribe(JNIEnv* env) {
    //FIXME print exception
}

extern JNICALL void SJVM_ExceptionClear(JNIEnv* env) {
    if (((Thread*) env->functions->reserved1)->nativeException)
        delete ((Thread*) env->functions->reserved1)->nativeException;
    ((Thread*) env->functions->reserved1)->nativeException = 0;
}

extern JNICALL jobject SJVM_AllocObject(JNIEnv* env, jclass cls) {
    JOBJECT obj = ((JCLASS) cls)->newInstance((SJVM*) env->functions->reserved0);
    ((Thread*) env->functions->reserved1)->nativeLocal->addLocal(obj);
    debug("JNI: Alocated Object\n");
    return (jobject) obj;
}

extern JNICALL jobject SJVM_NewObjectV(JNIEnv* env, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    jobject obj = env->AllocObject(cls);
    callV(jvm, thread, method, obj, args, &thread->nativeException);
    return obj;
}

extern JNICALL jobject SJVM_NewObject(JNIEnv* env, jclass cls, jmethodID meth, ...) {
    jobject obj;
    va_list args;
    va_start(args, meth);
    obj = SJVM_NewObjectV(env, cls, meth, args);
    va_end(args);
    return obj;
}

extern JNICALL jobject SJVM_NewObjectA(JNIEnv* env, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    jobject obj = env->AllocObject(cls);
    callA(jvm, thread, method, obj, args, &thread->nativeException);
    return obj;
}

extern JNICALL jclass SJVM_GetObjectClass(JNIEnv* env, jobject obj) {
    return (jclass) ((JOBJECT) obj)->type;
}

extern JNICALL jboolean SJVM_IsInstanceOf(JNIEnv* env, jobject obj, jclass cls) {
    return ((JCLASS) cls)->instanceOf((JOBJECT) obj);
}

extern JNICALL jmethodID SJVM_GetMethodID(JNIEnv* env, jclass cls, const char* name, const char* sig) {
    std::string full(name);
    full.append(sig);
    debug("JNI: GetMethodID - " << full << '\n');
    return (jmethodID) ((JCLASS) cls)->methodMap[full];
}

extern JNICALL jobject SJVM_CallObjectMethodV(JNIEnv* env, jobject obj, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jobject) callVirtualV(jvm, thread, method, obj, args, &thread->nativeException).l;
}

extern JNICALL jobject SJVM_CallObjectMethod(JNIEnv* env, jobject obj, jmethodID meth, ...) {
    va_list args;
    jobject ret;
    va_start(args, meth);
    ret = SJVM_CallObjectMethodV(env, obj, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jobject SJVM_CallObjectMethodA(JNIEnv* env, jobject obj, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jobject) callVirtualA(jvm, thread, method, obj, args, &thread->nativeException).l;
}

extern JNICALL jboolean SJVM_CallBooleanMethodV(JNIEnv* env, jobject obj, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jboolean) callVirtualV(jvm, thread, method, obj, args, &thread->nativeException).z;
}

extern JNICALL jboolean SJVM_CallBooleanMethod(JNIEnv* env, jobject obj, jmethodID meth, ...) {
    va_list args;
    jboolean ret;
    va_start(args, meth);
    ret = SJVM_CallBooleanMethodV(env, obj, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jboolean SJVM_CallBooleanMethodA(JNIEnv* env, jobject obj, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jboolean) callVirtualA(jvm, thread, method, obj, args, &thread->nativeException).z;
}

extern JNICALL jbyte SJVM_CallByteMethodV(JNIEnv* env, jobject obj, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jbyte) callVirtualV(jvm, thread, method, obj, args, &thread->nativeException).b;
}

extern JNICALL jbyte SJVM_CallByteMethod(JNIEnv* env, jobject obj, jmethodID meth, ...) {
    va_list args;
    jbyte ret;
    va_start(args, meth);
    ret = SJVM_CallByteMethodV(env, obj, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jbyte SJVM_CallByteMethodA(JNIEnv* env, jobject obj, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jbyte) callVirtualA(jvm, thread, method, obj, args, &thread->nativeException).b;
}

extern JNICALL jchar SJVM_CallCharMethodV(JNIEnv* env, jobject obj, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jchar) callVirtualV(jvm, thread, method, obj, args, &thread->nativeException).c;
}

extern JNICALL jchar SJVM_CallCharMethod(JNIEnv* env, jobject obj, jmethodID meth, ...) {
    va_list args;
    jchar ret;
    va_start(args, meth);
    ret = SJVM_CallCharMethodV(env, obj, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jchar SJVM_CallCharMethodA(JNIEnv* env, jobject obj, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jchar) callVirtualA(jvm, thread, method, obj, args, &thread->nativeException).c;
}

extern JNICALL jshort SJVM_CallShortMethodV(JNIEnv* env, jobject obj, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jshort) callVirtualV(jvm, thread, method, obj, args, &thread->nativeException).s;
}

extern JNICALL jshort SJVM_CallShortMethod(JNIEnv* env, jobject obj, jmethodID meth, ...) {
    va_list args;
    jshort ret;
    va_start(args, meth);
    ret = SJVM_CallShortMethodV(env, obj, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jshort SJVM_CallShortMethodA(JNIEnv* env, jobject obj, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jshort) callVirtualA(jvm, thread, method, obj, args, &thread->nativeException).s;
}

extern JNICALL jint SJVM_CallIntMethodV(JNIEnv* env, jobject obj, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jint) callVirtualV(jvm, thread, method, obj, args, &thread->nativeException).i;
}

extern JNICALL jint SJVM_CallIntMethod(JNIEnv* env, jobject obj, jmethodID meth, ...) {
    va_list args;
    jint ret;
    va_start(args, meth);
    ret = SJVM_CallIntMethodV(env, obj, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jint SJVM_CallIntMethodA(JNIEnv* env, jobject obj, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jint) callVirtualA(jvm, thread, method, obj, args, &thread->nativeException).i;
}

extern JNICALL jlong SJVM_CallLongMethodV(JNIEnv* env, jobject obj, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jlong) callVirtualV(jvm, thread, method, obj, args, &thread->nativeException).j;
}

extern JNICALL jlong SJVM_CallLongMethod(JNIEnv* env, jobject obj, jmethodID meth, ...) {
    va_list args;
    jlong ret;
    va_start(args, meth);
    ret = SJVM_CallLongMethodV(env, obj, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jlong SJVM_CallLongMethodA(JNIEnv* env, jobject obj, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jlong) callVirtualA(jvm, thread, method, obj, args, &thread->nativeException).j;
}

extern JNICALL jfloat SJVM_CallFloatMethodV(JNIEnv* env, jobject obj, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jfloat) callVirtualV(jvm, thread, method, obj, args, &thread->nativeException).f;
}

extern JNICALL jfloat SJVM_CallFloatMethod(JNIEnv* env, jobject obj, jmethodID meth, ...) {
    va_list args;
    jfloat ret;
    va_start(args, meth);
    ret = SJVM_CallFloatMethodV(env, obj, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jfloat SJVM_CallFloatMethodA(JNIEnv* env, jobject obj, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jfloat) callVirtualA(jvm, thread, method, obj, args, &thread->nativeException).f;
}

extern JNICALL jdouble SJVM_CallDoubleMethodV(JNIEnv* env, jobject obj, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jdouble) callVirtualV(jvm, thread, method, obj, args, &thread->nativeException).d;
}

extern JNICALL jdouble SJVM_CallDoubleMethod(JNIEnv* env, jobject obj, jmethodID meth, ...) {
    va_list args;
    jdouble ret;
    va_start(args, meth);
    ret = SJVM_CallDoubleMethodV(env, obj, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jdouble SJVM_CallDoubleMethodA(JNIEnv* env, jobject obj, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jdouble) callVirtualA(jvm, thread, method, obj, args, &thread->nativeException).d;
}

extern JNICALL void SJVM_CallVoidMethodV(JNIEnv* env, jobject obj, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    callVirtualV(jvm, thread, method, obj, args, &thread->nativeException);
}

extern JNICALL void SJVM_CallVoidMethod(JNIEnv* env, jobject obj, jmethodID meth, ...) {
    va_list args;
    va_start(args, meth);
    SJVM_CallVoidMethodV(env, obj, meth, args);
    va_end(args);
}

extern JNICALL void SJVM_CallVoidMethodA(JNIEnv* env, jobject obj, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    callVirtualA(jvm, thread, method, obj, args, &thread->nativeException);
}

extern JNICALL jobject SJVM_CallNonvirtualObjectMethodV(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jobject) callV(jvm, thread, method, obj, args, &thread->nativeException).l;
}

extern JNICALL jobject SJVM_CallNonvirtualObjectMethod(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, ...) {
    va_list args;
    jobject ret;
    va_start(args, meth);
    ret = SJVM_CallNonvirtualObjectMethodV(env, obj, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jobject SJVM_CallNonvirtualObjectMethodA(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jobject) callA(jvm, thread, method, obj, args, &thread->nativeException).l;
}

extern JNICALL jboolean SJVM_CallNonvirtualBooleanMethodV(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jboolean) callV(jvm, thread, method, obj, args, &thread->nativeException).z;
}

extern JNICALL jboolean SJVM_CallNonvirtualBooleanMethod(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, ...) {
    va_list args;
    jboolean ret;
    va_start(args, meth);
    ret = SJVM_CallNonvirtualBooleanMethodV(env, obj, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jboolean SJVM_CallNonvirtualBooleanMethodA(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jboolean) callA(jvm, thread, method, obj, args, &thread->nativeException).z;
}

extern JNICALL jbyte SJVM_CallNonvirtualByteMethodV(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jbyte) callV(jvm, thread, method, obj, args, &thread->nativeException).b;
}

extern JNICALL jbyte SJVM_CallNonvirtualByteMethod(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, ...) {
    va_list args;
    jbyte ret;
    va_start(args, meth);
    ret = SJVM_CallNonvirtualByteMethodV(env, obj, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jbyte SJVM_CallNonvirtualByteMethodA(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jbyte) callA(jvm, thread, method, obj, args, &thread->nativeException).b;
}

extern JNICALL jchar SJVM_CallNonvirtualCharMethodV(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jchar) callV(jvm, thread, method, obj, args, &thread->nativeException).c;
}

extern JNICALL jchar SJVM_CallNonvirtualCharMethod(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, ...) {
    va_list args;
    jchar ret;
    va_start(args, meth);
    ret = SJVM_CallNonvirtualCharMethodV(env, obj, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jchar SJVM_CallNonvirtualCharMethodA(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jchar) callA(jvm, thread, method, obj, args, &thread->nativeException).c;
}

extern JNICALL jshort SJVM_CallNonvirtualShortMethodV(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jshort) callV(jvm, thread, method, obj, args, &thread->nativeException).s;
}

extern JNICALL jshort SJVM_CallNonvirtualShortMethod(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, ...) {
    va_list args;
    jshort ret;
    va_start(args, meth);
    ret = SJVM_CallNonvirtualShortMethodV(env, obj, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jshort SJVM_CallNonvirtualShortMethodA(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jshort) callA(jvm, thread, method, obj, args, &thread->nativeException).s;
}

extern JNICALL jint SJVM_CallNonvirtualIntMethodV(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jint) callV(jvm, thread, method, obj, args, &thread->nativeException).i;
}

extern JNICALL jint SJVM_CallNonvirtualIntMethod(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, ...) {
    va_list args;
    jint ret;
    va_start(args, meth);
    ret = SJVM_CallNonvirtualIntMethodV(env, obj, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jint SJVM_CallNonvirtualIntMethodA(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jint) callA(jvm, thread, method, obj, args, &thread->nativeException).i;
}

extern JNICALL jlong SJVM_CallNonvirtualLongMethodV(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jlong) callV(jvm, thread, method, obj, args, &thread->nativeException).j;
}

extern JNICALL jlong SJVM_CallNonvirtualLongMethod(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, ...) {
    va_list args;
    jlong ret;
    va_start(args, meth);
    ret = SJVM_CallNonvirtualLongMethodV(env, obj, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jlong SJVM_CallNonvirtualLongMethodA(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jlong) callA(jvm, thread, method, obj, args, &thread->nativeException).j;
}

extern JNICALL jfloat SJVM_CallNonvirtualFloatMethodV(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jfloat) callV(jvm, thread, method, obj, args, &thread->nativeException).f;
}

extern JNICALL jfloat SJVM_CallNonvirtualFloatMethod(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, ...) {
    va_list args;
    jfloat ret;
    va_start(args, meth);
    ret = SJVM_CallNonvirtualFloatMethodV(env, obj, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jfloat SJVM_CallNonvirtualFloatMethodA(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jfloat) callA(jvm, thread, method, obj, args, &thread->nativeException).f;
}

extern JNICALL jdouble SJVM_CallNonvirtualDoubleMethodV(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jdouble) callV(jvm, thread, method, obj, args, &thread->nativeException).d;
}

extern JNICALL jdouble SJVM_CallNonvirtualDoubleMethod(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, ...) {
    va_list args;
    jdouble ret;
    va_start(args, meth);
    ret = SJVM_CallNonvirtualDoubleMethodV(env, obj, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jdouble SJVM_CallNonvirtualDoubleMethodA(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jdouble) callA(jvm, thread, method, obj, args, &thread->nativeException).d;
}

extern JNICALL void SJVM_CallNonvirtualVoidMethodV(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    callV(jvm, thread, method, obj, args, &thread->nativeException);
}

extern JNICALL void SJVM_CallNonvirtualVoidMethod(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, ...) {
    va_list args;
    va_start(args, meth);
    SJVM_CallNonvirtualVoidMethodV(env, obj, cls, meth, args);
    va_end(args);
}

extern JNICALL void SJVM_CallNonvirtualVoidMethodA(JNIEnv* env, jobject obj, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    callA(jvm, thread, method, obj, args, &thread->nativeException);
}

extern JNICALL jfieldID SJVM_GetFieldID(JNIEnv* env, jclass cls, const char* name, const char* sig) {
    return (jfieldID) ((JCLASS) cls)->fieldMap[name];
}

extern JNICALL jobject SJVM_GetObjectField(JNIEnv* env, jobject obj, jfieldID fld) {
    JOBJECT got = ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].l;
    ((Thread*) env->functions->reserved1)->nativeLocal->addLocal(got);
    return (jobject) got;
}

extern JNICALL jboolean SJVM_GetBooleanField(JNIEnv* env, jobject obj, jfieldID fld) {
    return ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].z;
}

extern JNICALL jbyte SJVM_GetByteField(JNIEnv* env, jobject obj, jfieldID fld) {
    return ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].b;
}

extern JNICALL jchar SJVM_GetCharField(JNIEnv* env, jobject obj, jfieldID fld) {
    return ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].c;
}

extern JNICALL jshort SJVM_GetShortField(JNIEnv* env, jobject obj, jfieldID fld) {
    return ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].s;
}

extern JNICALL jint SJVM_GetIntField(JNIEnv* env, jobject obj, jfieldID fld) {
    return ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].i;
}

extern JNICALL jlong SJVM_GetLongField(JNIEnv* env, jobject obj, jfieldID fld) {
    return ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].j;
}

extern JNICALL jfloat SJVM_GetFloatField(JNIEnv* env, jobject obj, jfieldID fld) {
    return ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].f;
}

extern JNICALL jdouble SJVM_GetDoubleField(JNIEnv* env, jobject obj, jfieldID fld) {
    return ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].d;
}

extern JNICALL void SJVM_SetObjectField(JNIEnv* env, jobject obj, jfieldID fld, jobject val) {
    JOBJECT old = ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].l;
    if (old) ((SJVM*) env->functions->reserved0)->gc->decrRef(old);
    ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].l = (JOBJECT) val;
    ((SJVM*) env->functions->reserved0)->gc->incrRef((JOBJECT) val);
}

extern JNICALL void SJVM_SetBooleanField(JNIEnv* env, jobject obj, jfieldID fld, jboolean val) {
    ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].z = val;
}

extern JNICALL void SJVM_SetByteField(JNIEnv* env, jobject obj, jfieldID fld, jbyte val) {
    ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].b = val;
}

extern JNICALL void SJVM_SetCharField(JNIEnv* env, jobject obj, jfieldID fld, jchar val) {
    ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].c = val;
}

extern JNICALL void SJVM_SetShortField(JNIEnv* env, jobject obj, jfieldID fld, jshort val) {
    ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].s = val;
}

extern JNICALL void SJVM_SetIntField(JNIEnv* env, jobject obj, jfieldID fld, jint val) {
    ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].i = val;
}

extern JNICALL void SJVM_SetLongField(JNIEnv* env, jobject obj, jfieldID fld, jlong val) {
    ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].j = val;
}

extern JNICALL void SJVM_SetFloatField(JNIEnv* env, jobject obj, jfieldID fld, jfloat val) {
    ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].f = val;
}

extern JNICALL void SJVM_SetDoubleField(JNIEnv* env, jobject obj, jfieldID fld, jdouble val) {
    ((JOBJECT) obj)->fields[((FieldInfo*) fld)->index].d = val;
}

extern JNICALL jmethodID SJVM_GetStaticMethodID(JNIEnv* env, jclass cls, const char* name, const char* sig) {
    std::string full(name);
    full.append(sig);
    return (jmethodID) ((JCLASS) cls)->methodMap[full];
}

extern JNICALL jobject SJVM_CallStaticObjectMethodV(JNIEnv* env, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jobject) callStaticV(jvm, thread, method, args, &thread->nativeException).l;
}

extern JNICALL jobject SJVM_CallStaticObjectMethod(JNIEnv* env, jclass cls, jmethodID meth, ...) {
    va_list args;
    jobject ret;
    va_start(args, meth);
    ret = SJVM_CallStaticObjectMethodV(env, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jobject SJVM_CallStaticObjectMethodA(JNIEnv* env, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jobject) callStaticA(jvm, thread, method, args, &thread->nativeException).l;
}

extern JNICALL jboolean SJVM_CallStaticBooleanMethodV(JNIEnv* env, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jboolean) callStaticV(jvm, thread, method, args, &thread->nativeException).z;
}

extern JNICALL jboolean SJVM_CallStaticBooleanMethod(JNIEnv* env, jclass cls, jmethodID meth, ...) {
    va_list args;
    jboolean ret;
    va_start(args, meth);
    ret = SJVM_CallStaticBooleanMethodV(env, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jboolean SJVM_CallStaticBooleanMethodA(JNIEnv* env, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jboolean) callStaticA(jvm, thread, method, args, &thread->nativeException).z;
}

extern JNICALL jbyte SJVM_CallStaticByteMethodV(JNIEnv* env, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jbyte) callStaticV(jvm, thread, method, args, &thread->nativeException).b;
}

extern JNICALL jbyte SJVM_CallStaticByteMethod(JNIEnv* env, jclass cls, jmethodID meth, ...) {
    va_list args;
    jbyte ret;
    va_start(args, meth);
    ret = SJVM_CallStaticByteMethodV(env, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jbyte SJVM_CallStaticByteMethodA(JNIEnv* env, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jbyte) callStaticA(jvm, thread, method, args, &thread->nativeException).b;
}

extern JNICALL jchar SJVM_CallStaticCharMethodV(JNIEnv* env, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jchar) callStaticV(jvm, thread, method, args, &thread->nativeException).c;
}

extern JNICALL jchar SJVM_CallStaticCharMethod(JNIEnv* env, jclass cls, jmethodID meth, ...) {
    va_list args;
    jchar ret;
    va_start(args, meth);
    ret = SJVM_CallStaticCharMethodV(env, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jchar SJVM_CallStaticCharMethodA(JNIEnv* env, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jchar) callStaticA(jvm, thread, method, args, &thread->nativeException).c;
}

extern JNICALL jshort SJVM_CallStaticShortMethodV(JNIEnv* env, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jshort) callStaticV(jvm, thread, method, args, &thread->nativeException).s;
}

extern JNICALL jshort SJVM_CallStaticShortMethod(JNIEnv* env, jclass cls, jmethodID meth, ...) {
    va_list args;
    jshort ret;
    va_start(args, meth);
    ret = SJVM_CallStaticShortMethodV(env, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jshort SJVM_CallStaticShortMethodA(JNIEnv* env, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jshort) callStaticA(jvm, thread, method, args, &thread->nativeException).s;
}

extern JNICALL jint SJVM_CallStaticIntMethodV(JNIEnv* env, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jint) callStaticV(jvm, thread, method, args, &thread->nativeException).i;
}

extern JNICALL jint SJVM_CallStaticIntMethod(JNIEnv* env, jclass cls, jmethodID meth, ...) {
    va_list args;
    jint ret;
    va_start(args, meth);
    ret = SJVM_CallStaticIntMethodV(env, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jint SJVM_CallStaticIntMethodA(JNIEnv* env, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jint) callStaticA(jvm, thread, method, args, &thread->nativeException).i;
}

extern JNICALL jlong SJVM_CallStaticLongMethodV(JNIEnv* env, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jlong) callStaticV(jvm, thread, method, args, &thread->nativeException).j;
}

extern JNICALL jlong SJVM_CallStaticLongMethod(JNIEnv* env, jclass cls, jmethodID meth, ...) {
    va_list args;
    jlong ret;
    va_start(args, meth);
    ret = SJVM_CallStaticLongMethodV(env, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jlong SJVM_CallStaticLongMethodA(JNIEnv* env, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jlong) callStaticA(jvm, thread, method, args, &thread->nativeException).j;
}

extern JNICALL jfloat SJVM_CallStaticFloatMethodV(JNIEnv* env, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jfloat) callStaticV(jvm, thread, method, args, &thread->nativeException).f;
}

extern JNICALL jfloat SJVM_CallStaticFloatMethod(JNIEnv* env, jclass cls, jmethodID meth, ...) {
    va_list args;
    jfloat ret;
    va_start(args, meth);
    ret = SJVM_CallStaticFloatMethodV(env, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jfloat SJVM_CallStaticFloatMethodA(JNIEnv* env, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jfloat) callStaticA(jvm, thread, method, args, &thread->nativeException).f;
}

extern JNICALL jdouble SJVM_CallStaticDoubleMethodV(JNIEnv* env, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jdouble) callStaticV(jvm, thread, method, args, &thread->nativeException).d;
}

extern JNICALL jdouble SJVM_CallStaticDoubleMethod(JNIEnv* env, jclass cls, jmethodID meth, ...) {
    va_list args;
    jdouble ret;
    va_start(args, meth);
    ret = SJVM_CallStaticDoubleMethodV(env, cls, meth, args);
    va_end(args);
    return ret;
}

extern JNICALL jdouble SJVM_CallStaticDoubleMethodA(JNIEnv* env, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    return (jdouble) callStaticA(jvm, thread, method, args, &thread->nativeException).d;
}

extern JNICALL void SJVM_CallStaticVoidMethodV(JNIEnv* env, jclass cls, jmethodID meth, va_list args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    callStaticV(jvm, thread, method, args, &thread->nativeException);
}

extern JNICALL void SJVM_CallStaticVoidMethod(JNIEnv* env, jclass cls, jmethodID meth, ...) {
    va_list args;
    va_start(args, meth);
    SJVM_CallStaticVoidMethodV(env, cls, meth, args);
    va_end(args);
}

extern JNICALL void SJVM_CallStaticVoidMethodA(JNIEnv* env, jclass cls, jmethodID meth, const jvalue* args) {
    MethodInfo* method = (MethodInfo*) meth;
    SJVM* jvm = (SJVM*) env->functions->reserved0;
    Thread* thread = (Thread*) env->functions->reserved1;
    callStaticA(jvm, thread, method, args, &thread->nativeException);
}

extern JNICALL jfieldID SJVM_GetStaticFieldID(JNIEnv* env, jclass cls, const char* name, const char* sig) {
    return (jfieldID) ((JCLASS) cls)->fieldMap[name];
}

extern JNICALL jobject SJVM_GetStaticObjectField(JNIEnv* env, jclass cls, jfieldID fld) {
    JOBJECT obj = ((FieldInfo*) fld)->staticValue.l;
    ((Thread*) env->functions->reserved1)->nativeLocal->addLocal(obj);
    return (jobject) obj;
}

extern JNICALL jboolean SJVM_GetStaticBooleanField(JNIEnv* env, jclass cls, jfieldID fld) {
    return ((FieldInfo*) fld)->staticValue.z;
}

extern JNICALL jbyte SJVM_GetStaticByteField(JNIEnv* env, jclass cls, jfieldID fld) {
    return ((FieldInfo*) fld)->staticValue.b;
}

extern JNICALL jchar SJVM_GetStaticCharField(JNIEnv* env, jclass cls, jfieldID fld) {
    return ((FieldInfo*) fld)->staticValue.c;
}

extern JNICALL jshort SJVM_GetStaticShortField(JNIEnv* env, jclass cls, jfieldID fld) {
    return ((FieldInfo*) fld)->staticValue.s;
}

extern JNICALL jint SJVM_GetStaticIntField(JNIEnv* env, jclass cls, jfieldID fld) {
    return ((FieldInfo*) fld)->staticValue.i;
}

extern JNICALL jlong SJVM_GetStaticLongField(JNIEnv* env, jclass cls, jfieldID fld) {
    return ((FieldInfo*) fld)->staticValue.j;
}

extern JNICALL jfloat SJVM_GetStaticFloatField(JNIEnv* env, jclass cls, jfieldID fld) {
    return ((FieldInfo*) fld)->staticValue.f;
}

extern JNICALL jdouble SJVM_GetStaticDoubleField(JNIEnv* env, jclass cls, jfieldID fld) {
    return ((FieldInfo*) fld)->staticValue.d;
}

extern JNICALL void SJVM_SetStaticObjectField(JNIEnv* env, jclass cls, jfieldID fld, jobject val) {
    JOBJECT old = ((FieldInfo*) fld)->staticValue.l;
    if (old) ((SJVM*) env->functions->reserved0)->gc->decrRef(old);
    ((FieldInfo*) fld)->staticValue.l = (JOBJECT) val;
    ((Thread*) env->functions->reserved1)->nativeLocal->addLocal((JOBJECT) val);
}

extern JNICALL void SJVM_SetStaticBooleanField(JNIEnv* env, jclass cls, jfieldID fld, jboolean val) {
    ((FieldInfo*) fld)->staticValue.z = val;
}

extern JNICALL void SJVM_SetStaticByteField(JNIEnv* env, jclass cls, jfieldID fld, jbyte val) {
    ((FieldInfo*) fld)->staticValue.b = val;
}

extern JNICALL void SJVM_SetStaticCharField(JNIEnv* env, jclass cls, jfieldID fld, jchar val) {
    ((FieldInfo*) fld)->staticValue.c = val;
}

extern JNICALL void SJVM_SetStaticShortField(JNIEnv* env, jclass cls, jfieldID fld, jshort val) {
    ((FieldInfo*) fld)->staticValue.s = val;
}

extern JNICALL void SJVM_SetStaticIntField(JNIEnv* env, jclass cls, jfieldID fld, jint val) {
    ((FieldInfo*) fld)->staticValue.i = val;
}

extern JNICALL void SJVM_SetStaticLongField(JNIEnv* env, jclass cls, jfieldID fld, jlong val) {
    ((FieldInfo*) fld)->staticValue.j = val;
}

extern JNICALL void SJVM_SetStaticFloatField(JNIEnv* env, jclass cls, jfieldID fld, jfloat val) {
    ((FieldInfo*) fld)->staticValue.f = val;
}

extern JNICALL void SJVM_SetStaticDoubleField(JNIEnv* env, jclass cls, jfieldID fld, jdouble val) {
    ((FieldInfo*) fld)->staticValue.d = val;
}

extern JNICALL jstring SJVM_NewString(JNIEnv* env, const jchar* data, jsize len) {
    JCLASS sclass = ((SJVM*) env->functions->reserved0)->loadClass("java/lang/String");
    JOBJECT sobj = sclass->newInstance((SJVM*) env->functions->reserved0);
    ((Thread*) env->functions->reserved1)->nativeLocal->addLocal(sobj);
    JCHARARRAY chars = ClassFile::newArray<JCHAR>((SJVM*)env->functions->reserved0,(char*)"[C",len);
    ((SJVM*) env->functions->reserved0)->gc->incrRef(chars);
    sobj->fields[sclass->fieldMap["value"]->index].l = chars;
    for (int i = 0; i < len; i++)
        chars->array[i] = data[i];
    sobj->fields[sclass->fieldMap["offset"]->index].i = 0;
    sobj->fields[sclass->fieldMap["count"]->index].i = len;
}

extern JNICALL jsize SJVM_GetStringLength(JNIEnv* env, jstring data) {
    return ((JOBJECT) data)->fields[((JOBJECT) data)->type->fieldMap["count"]->index].i;
}

extern JNICALL const jchar* SJVM_GetStringChars(JNIEnv* env, jstring data, jboolean* copy) {
    if (copy != NULL) *copy = JNI_FALSE;
    return ((JCHARARRAY) ((JOBJECT) data)->fields[((JOBJECT) data)->type->fieldMap["value"]->index].l)->array;
}

extern JNICALL jstring SJVM_NewStringUTF(JNIEnv* env, const char* data) {
    JCLASS sclass = ((SJVM*) env->functions->reserved0)->loadClass("java/lang/String");
    JOBJECT sobj = sclass->newInstance((SJVM*) env->functions->reserved0);
    ((Thread*) env->functions->reserved1)->nativeLocal->addLocal(sobj);
    int len = 0;
    int clen = strlen(data);
    unsigned char* bytes = (unsigned char*) data;
    for (int i = 0; i < clen;) {
        if ((bytes[i] & 0x80) == 0) {
            len++;
            i++;
        } else if ((bytes[i] & 0xE0) == 0xC0) {
            len += 2;
            i += 2;
        } else if ((bytes[i] & 0xF0) == 0xE0) {
            len += 3;
            i += 3;
        }
    }
    JCHARARRAY chars = ClassFile::newArray<JCHAR>((SJVM*)env->functions->reserved0,(char*)"[C",len);
    ((SJVM*) env->functions->reserved0)->gc->incrRef(chars);
    sobj->fields[sclass->fieldMap["value"]->index].l = chars;
    JCHAR* array = chars->array;
    for (int i = 0, c = 0; i < len; i++) {
        if ((bytes[c] & 0x80) == 0x00) {
            array[i] = bytes[c];
            c++;
        } else if ((bytes[c] & 0xE0) == 0xC0) {
            array[i] = ((bytes[c] & 0x1F) << 6) + (bytes[c + 1] & 0x3F);
            c += 2;
        } else if ((bytes[c] & 0xF0) == 0xE0) {
            array[i] = ((bytes[c] & 0xF) << 12) + ((bytes[c + 1] & 0x3F) << 6) + (bytes[c + 2] & 0x3F);
            c += 3;
        }
    }
    sobj->fields[sclass->fieldMap["offset"]->index].i = 0;
    sobj->fields[sclass->fieldMap["count"]->index].i = len;
    return (jstring) sobj;
}

extern JNICALL jsize SJVM_GetStringUTFLength(JNIEnv* env, jstring data) {
    JOBJECT sobj = ((JOBJECT) data);
    JCLASS sclass = sobj->type;
    JCHARARRAY chars = (JCHARARRAY) sobj->fields[sclass->fieldMap["value"]->index].l;
    int offset = sobj->fields[sclass->fieldMap["offset"]->index].i;
    int clen = sobj->fields[sclass->fieldMap["count"]->index].i;
    JCHAR* ptr = chars->array;
    int len = 0;
    for (int i = offset; i < clen; i++) {
        if (ptr[i] >= 0x0001 && ptr[i] <= 0x007F) {
            len += 1;
        } else if (ptr[i] >= 0x0080 && ptr[i] <= 0x07FF) {
            len += 2;
        } else {
            len += 3;
        }
    }
    return len;
}

extern JNICALL const char* SJVM_GetStringUTFChars(JNIEnv* env, jstring data, jboolean* copy) {
    JOBJECT sobj = ((JOBJECT) data);
    JCLASS sclass = sobj->type;
    JCHARARRAY chars = (JCHARARRAY) sobj->fields[sclass->fieldMap["value"]->index].l;
    int offset = sobj->fields[sclass->fieldMap["offset"]->index].i;
    int clen = sobj->fields[sclass->fieldMap["count"]->index].i;
    JCHAR* ptr = chars->array;
    int len = 0;
    for (int i = offset; i < clen; i++) {
        if (ptr[i] >= 0x0001 && ptr[i] <= 0x007F) {
            len += 1;
        } else if (ptr[i] >= 0x0080 && ptr[i] <= 0x07FF) {
            len += 2;
        } else {
            len += 3;
        }
    }
    char* buf = new char[len + 1];
    buf[len] = 0;
    if (copy != NULL) {
        *copy = JNI_TRUE;
    }
    for (int j = 0, i = offset; i < clen; i++) {
        if (ptr[i] >= 0x0001 && ptr[i] <= 0x007F) {
            buf[j++] = ptr[i] & 0x7F;
        } else if (ptr[i] >= 0x0080 && ptr[i] <= 0x07FF) {
            buf[j++] = 0xC0 | ((ptr[i] >> 6) & 0x1F);
            buf[j++] = 0x80 | (ptr[i] & 0x3F);
        } else {
            buf[j++] = 0xE0 | ((ptr[i] >> 12) & 0x0F);
            buf[j++] = 0x80 | ((ptr[i] >> 6) & 0x3F);
            buf[j++] = 0x80 | (ptr[i] & 0x3F);
        }
    }
    return buf;
}

extern JNICALL void SJVM_ReleaseStringUTFChars(JNIEnv* env, jstring data, const char* chars) {
    delete [] chars;
}

extern JNICALL jsize SJVM_GetArrayLength(JNIEnv* env, jarray arr) {
    return ((JOBJECTARRAY) arr)->size;
}

extern JNICALL jobjectArray SJVM_NewObjectArray(JNIEnv* env, jsize len, jclass cls, jobject init) {
    std::string str("[");
    str.append(((JCLASS)cls)->name);
    JOBJECTARRAY array = ClassFile::newArray<JOBJECT>((SJVM*)env->functions->reserved0,(char*)str.c_str(),len);
    for (int i = 0; i < len; i++) {
        array->array[i] = (JOBJECT) init;
    }
    return (jobjectArray) array;
    ((Thread*) env->functions->reserved1)->nativeLocal->addLocal(array);
}

extern JNICALL jobject SJVM_GetObjectArrayElement(JNIEnv* env, jobjectArray arr, jsize elem) {
    JOBJECT obj = ((JOBJECTARRAY) arr)->array[elem];
    ((Thread*) env->functions->reserved1)->nativeLocal->addLocal(obj);
    return (jobject) obj;
}

extern JNICALL void SJVM_SetObjectArrayElement(JNIEnv* env, jobjectArray arr, jsize elem, jobject val) {
    JOBJECT old = ((JOBJECTARRAY) arr)->array[elem];
    if (old) ((SJVM*) env->functions->reserved0)->gc->decrRef(old);
    ((JOBJECTARRAY) arr)->array[elem] = (JOBJECT) val;
    ((SJVM*) env->functions->reserved0)->gc->incrRef((JOBJECT) val);
}

extern JNICALL jbooleanArray SJVM_NewBooleanArray(JNIEnv* env, jsize len) {
    return (jbooleanArray) ClassFile::newArray<JBOOLEAN>((SJVM*)env->functions->reserved0,(char*)"[Z",len);
}

extern JNICALL jbyteArray SJVM_NewByteArray(JNIEnv* env, jsize len) {
    return (jbyteArray) ClassFile::newArray<JBYTE>((SJVM*)env->functions->reserved0,(char*)"[B",len);
}

extern JNICALL jcharArray SJVM_NewCharArray(JNIEnv* env, jsize len) {
    return (jcharArray) ClassFile::newArray<JCHAR>((SJVM*)env->functions->reserved0,(char*)"[C",len);
}

extern JNICALL jshortArray SJVM_NewShortArray(JNIEnv* env, jsize len) {
    return (jshortArray) ClassFile::newArray<JSHORT>((SJVM*)env->functions->reserved0,(char*)"[S",len);
}

extern JNICALL jintArray SJVM_NewIntArray(JNIEnv* env, jsize len) {
    return (jintArray) ClassFile::newArray<JINT>((SJVM*)env->functions->reserved0,(char*)"[I",len);
}

extern JNICALL jlongArray SJVM_NewLongArray(JNIEnv* env, jsize len) {
    return (jlongArray) ClassFile::newArray<JLONG>((SJVM*)env->functions->reserved0,(char*)"[J",len);
}

extern JNICALL jfloatArray SJVM_NewFloatArray(JNIEnv* env, jsize len) {
    return (jfloatArray) ClassFile::newArray<JFLOAT>((SJVM*)env->functions->reserved0,(char*)"[F",len);
}

extern JNICALL jdoubleArray SJVM_NewDoubleArray(JNIEnv* env, jsize len) {
    return (jdoubleArray) ClassFile::newArray<JDOUBLE>((SJVM*)env->functions->reserved0,(char*)"[D",len);
}

extern JNICALL jboolean* SJVM_GetBooleanArrayElements(JNIEnv* env, jbooleanArray arr, jboolean* iscopy) {
    if (iscopy != NULL) {
        *iscopy = JNI_FALSE;
    }
    return (jboolean*) ((JBOOLEANARRAY) arr)->array;
}

extern JNICALL jbyte* SJVM_GetByteArrayElements(JNIEnv* env, jbyteArray arr, jboolean* iscopy) {
    if (iscopy != NULL) {
        *iscopy = JNI_FALSE;
    }
    return (jbyte*) ((JBYTEARRAY) arr)->array;
}

extern JNICALL jchar* SJVM_GetCharArrayElements(JNIEnv* env, jcharArray arr, jboolean* iscopy) {
    if (iscopy != NULL) {
        *iscopy = JNI_FALSE;
    }
    return (jchar*) ((JCHARARRAY) arr)->array;
}

extern JNICALL jshort* SJVM_GetShortArrayElements(JNIEnv* env, jshortArray arr, jboolean* iscopy) {
    if (iscopy != NULL) {
        *iscopy = JNI_FALSE;
    }
    return (jshort*) ((JSHORTARRAY) arr)->array;
}

extern JNICALL jint* SJVM_GetIntArrayElements(JNIEnv* env, jintArray arr, jboolean* iscopy) {
    if (iscopy != NULL) {
        *iscopy = JNI_FALSE;
    }
    return (jint*) ((JINTARRAY) arr)->array;
}

extern JNICALL jlong* SJVM_GetLongArrayElements(JNIEnv* env, jlongArray arr, jboolean* iscopy) {
    if (iscopy != NULL) {
        *iscopy = JNI_FALSE;
    }
    return (jlong*) ((JLONGARRAY) arr)->array;
}

extern JNICALL jfloat* SJVM_GetFloatArrayElements(JNIEnv* env, jfloatArray arr, jboolean* iscopy) {
    if (iscopy != NULL) {
        *iscopy = JNI_FALSE;
    }
    return (jfloat*) ((JFLOATARRAY) arr)->array;
}

extern JNICALL jdouble* SJVM_GetDoubleArrayElements(JNIEnv* env, jdoubleArray arr, jboolean* iscopy) {
    if (iscopy != NULL) {
        *iscopy = JNI_FALSE;
    }
    return (jdouble*) ((JDOUBLEARRAY) arr)->array;
}

extern JNICALL void SJVM_ReleaseBooleanArrayElements(JNIEnv* env, jbooleanArray arr, jboolean* elems, jint mode) {
    //nothing
}

extern JNICALL void SJVM_ReleaseByteArrayElements(JNIEnv* env, jbyteArray arr, jbyte* elems, jint mode) {
    //nothing
}

extern JNICALL void SJVM_ReleaseCharArrayElements(JNIEnv* env, jcharArray arr, jchar* elems, jint mode) {
    //nothing
}

extern JNICALL void SJVM_ReleaseShortArrayElements(JNIEnv* env, jshortArray arr, jshort* elems, jint mode) {
    //nothing
}

extern JNICALL void SJVM_ReleaseIntArrayElements(JNIEnv* env, jintArray arr, jint* elems, jint mode) {
    //nothing
}

extern JNICALL void SJVM_ReleaseLongArrayElements(JNIEnv* env, jlongArray arr, jlong* elems, jint mode) {
    //nothing
}

extern JNICALL void SJVM_ReleaseFloatArrayElements(JNIEnv* env, jfloatArray arr, jfloat* elems, jint mode) {
    //nothing
}

extern JNICALL void SJVM_ReleaseDoubleArrayElements(JNIEnv* env, jdoubleArray arr, jdouble* elems, jint mode) {
    //nothing
}

extern JNICALL void SJVM_GetBooleanArrayRegion(JNIEnv* env, jbooleanArray arr, jsize start, jsize len, jboolean* data) {
    memcpy(data, &((JBOOLEANARRAY) arr)->array[start], len * sizeof (jboolean));
}

extern JNICALL void SJVM_GetByteArrayRegion(JNIEnv* env, jbyteArray arr, jsize start, jsize len, jbyte* data) {
    memcpy(data, &((JBYTEARRAY) arr)->array[start], len * sizeof (jbyte));
}

extern JNICALL void SJVM_GetCharArrayRegion(JNIEnv* env, jcharArray arr, jsize start, jsize len, jchar* data) {
    memcpy(data, &((JCHARARRAY) arr)->array[start], len * sizeof (jchar));
}

extern JNICALL void SJVM_GetShortArrayRegion(JNIEnv* env, jshortArray arr, jsize start, jsize len, jshort* data) {
    memcpy(data, &((JSHORTARRAY) arr)->array[start], len * sizeof (jshort));
}

extern JNICALL void SJVM_GetIntArrayRegion(JNIEnv* env, jintArray arr, jsize start, jsize len, jint* data) {
    memcpy(data, &((JINTARRAY) arr)->array[start], len * sizeof (jint));
}

extern JNICALL void SJVM_GetLongArrayRegion(JNIEnv* env, jlongArray arr, jsize start, jsize len, jlong* data) {
    memcpy(data, &((JLONGARRAY) arr)->array[start], len * sizeof (jlong));
}

extern JNICALL void SJVM_GetFloatArrayRegion(JNIEnv* env, jfloatArray arr, jsize start, jsize len, jfloat* data) {
    memcpy(data, &((JFLOATARRAY) arr)->array[start], len * sizeof (jfloat));
}

extern JNICALL void SJVM_GetDoubleArrayRegion(JNIEnv* env, jdoubleArray arr, jsize start, jsize len, jdouble* data) {
    memcpy(data, &((JDOUBLEARRAY) arr)->array[start], len * sizeof (jdouble));
}

extern JNICALL void SJVM_SetBooleanArrayRegion(JNIEnv* env, jbooleanArray arr, jsize start, jsize len, const jboolean* data) {
    Array<char> *array = (Array<char>*)arr;
    memcpy(array->array + sizeof (jboolean) * start, (char*) data, sizeof (jboolean) * len);
}

extern JNICALL void SJVM_SetByteArrayRegion(JNIEnv* env, jbyteArray arr, jsize start, jsize len, const jbyte* data) {
    Array<char> *array = (Array<char>*)arr;
    memcpy(array->array + sizeof (jbyte) * start, (char*) data, sizeof (jbyte) * len);
}

extern JNICALL void SJVM_SetCharArrayRegion(JNIEnv* env, jcharArray arr, jsize start, jsize len, const jchar* data) {
    Array<char> *array = (Array<char>*)arr;
    memcpy(array->array + sizeof (jchar) * start, (char*) data, sizeof (jchar) * len);
}

extern JNICALL void SJVM_SetShortArrayRegion(JNIEnv* env, jshortArray arr, jsize start, jsize len, const jshort* data) {
    Array<char> *array = (Array<char>*)arr;
    memcpy(array->array + sizeof (jshort) * start, (char*) data, sizeof (jshort) * len);
}

extern JNICALL void SJVM_SetIntArrayRegion(JNIEnv* env, jintArray arr, jsize start, jsize len, const jint* data) {
    Array<char> *array = (Array<char>*)arr;
    memcpy(array->array + sizeof (jint) * start, (char*) data, sizeof (jint) * len);
}

extern JNICALL void SJVM_SetLongArrayRegion(JNIEnv* env, jlongArray arr, jsize start, jsize len, const jlong* data) {
    Array<char> *array = (Array<char>*)arr;
    memcpy(array->array + sizeof (jlong) * start, (char*) data, sizeof (jlong) * len);
}

extern JNICALL void SJVM_SetFloatArrayRegion(JNIEnv* env, jfloatArray arr, jsize start, jsize len, const jfloat* data) {
    Array<char> *array = (Array<char>*)arr;
    memcpy(array->array + sizeof (jfloat) * start, (char*) data, sizeof (jfloat) * len);
}

extern JNICALL void SJVM_SetDoubleArrayRegion(JNIEnv* env, jdoubleArray arr, jsize start, jsize len, const jdouble* data) {
    Array<char> *array = (Array<char>*)arr;
    memcpy(array->array + sizeof (jdouble) * start, (char*) data, sizeof (jdouble) * len);
}

extern JNICALL jint SJVM_RegisterNatives(JNIEnv* env, jclass cls, const JNINativeMethod* methods, jint nmethods) {
    return JNI_ERR;
}

extern JNICALL jint SJVM_UnregisterNatives(JNIEnv* env, jclass cls) {
    return JNI_ERR;
}

extern JNICALL jint SJVM_MonitorEnter(JNIEnv* env, jobject obj) {
    ((JOBJECT) obj)->mutex.lock();
    return JNI_OK;
}

extern JNICALL jint SJVM_MonitorExit(JNIEnv* env, jobject obj) {
    ((JOBJECT) obj)->mutex.unlock();
    return JNI_OK;
}

void SJVM_JNIExceptionHandler(void) {

}

extern JNICALL jint SJVM_GetJavaVM(JNIEnv* env, JavaVM** vm) {
    *vm = ((SJVM*) env)->getJavaVM();
    return JNI_OK;
}

extern JNICALL jint SJVM_DestroyJavaVM(JavaVM* vm) {
    SJVM *sjvm = ((SJVM*) vm->functions->reserved0);
    delete sjvm;
    return JNI_OK;
}

extern JNICALL jint SJVM_AttachCurrentThread(JavaVM* vm, void** env, void* args) {
    Thread* thread = Thread::getThread((SJVM*) vm->functions->reserved0);
    if (env) *((JNIEnv**) env) = thread->getEnv();
    return JNI_OK;
}

extern JNICALL jint SJVM_DetachCurrentThread(JavaVM* vm) {
    //FIXME detach thread
    return JNI_ERR;
}

extern JNICALL jint SJVM_GetEnv(JavaVM* vm, void** penv, jint interface_id) {
    //FIXME attaches thread...
    Thread* thread = Thread::getThread((SJVM*) vm->functions->reserved0);
    if (penv) *((JNIEnv**) penv) = thread->getEnv();
    return JNI_OK;
}

struct JNINativeInterface_ SJVM_JNINativeInterface = {
    NULL,
    NULL,
    NULL,
    NULL,
    SJVM_GetVersion,
    SJVM_DefineClass,
    SJVM_FindClass,
    NULL,
    NULL,
    NULL,
    SJVM_GetSuperClass,
    SJVM_IsAssignableFrom,
    NULL,
    SJVM_Throw,
    SJVM_ThrowNew,
    SJVM_ExceptionOccurred,
    SJVM_ExceptionDescribe,
    SJVM_ExceptionClear,
    SJVM_FatalError,
    NULL,
    NULL,
    SJVM_NewGlobalRef,
    SJVM_DeleteGlobalRef,
    SJVM_DeleteLocalRef,
    SJVM_IsSameObject,
    NULL,
    NULL,
    SJVM_AllocObject,
    SJVM_NewObject,
    SJVM_NewObjectV,
    SJVM_NewObjectA,
    SJVM_GetObjectClass,
    SJVM_IsInstanceOf,
    SJVM_GetMethodID,
    SJVM_CallObjectMethod,
    SJVM_CallObjectMethodV,
    SJVM_CallObjectMethodA,
    SJVM_CallBooleanMethod,
    SJVM_CallBooleanMethodV,
    SJVM_CallBooleanMethodA,
    SJVM_CallByteMethod,
    SJVM_CallByteMethodV,
    SJVM_CallByteMethodA,
    SJVM_CallCharMethod,
    SJVM_CallCharMethodV,
    SJVM_CallCharMethodA,
    SJVM_CallShortMethod,
    SJVM_CallShortMethodV,
    SJVM_CallShortMethodA,
    SJVM_CallIntMethod,
    SJVM_CallIntMethodV,
    SJVM_CallIntMethodA,
    SJVM_CallLongMethod,
    SJVM_CallLongMethodV,
    SJVM_CallLongMethodA,
    SJVM_CallFloatMethod,
    SJVM_CallFloatMethodV,
    SJVM_CallFloatMethodA,
    SJVM_CallDoubleMethod,
    SJVM_CallDoubleMethodV,
    SJVM_CallDoubleMethodA,
    SJVM_CallVoidMethod,
    SJVM_CallVoidMethodV,
    SJVM_CallVoidMethodA,
    SJVM_CallNonvirtualObjectMethod,
    SJVM_CallNonvirtualObjectMethodV,
    SJVM_CallNonvirtualObjectMethodA,
    SJVM_CallNonvirtualBooleanMethod,
    SJVM_CallNonvirtualBooleanMethodV,
    SJVM_CallNonvirtualBooleanMethodA,
    SJVM_CallNonvirtualByteMethod,
    SJVM_CallNonvirtualByteMethodV,
    SJVM_CallNonvirtualByteMethodA,
    SJVM_CallNonvirtualCharMethod,
    SJVM_CallNonvirtualCharMethodV,
    SJVM_CallNonvirtualCharMethodA,
    SJVM_CallNonvirtualShortMethod,
    SJVM_CallNonvirtualShortMethodV,
    SJVM_CallNonvirtualShortMethodA,
    SJVM_CallNonvirtualIntMethod,
    SJVM_CallNonvirtualIntMethodV,
    SJVM_CallNonvirtualIntMethodA,
    SJVM_CallNonvirtualLongMethod,
    SJVM_CallNonvirtualLongMethodV,
    SJVM_CallNonvirtualLongMethodA,
    SJVM_CallNonvirtualFloatMethod,
    SJVM_CallNonvirtualFloatMethodV,
    SJVM_CallNonvirtualFloatMethodA,
    SJVM_CallNonvirtualDoubleMethod,
    SJVM_CallNonvirtualDoubleMethodV,
    SJVM_CallNonvirtualDoubleMethodA,
    SJVM_CallNonvirtualVoidMethod,
    SJVM_CallNonvirtualVoidMethodV,
    SJVM_CallNonvirtualVoidMethodA,
    SJVM_GetFieldID,
    SJVM_GetObjectField,
    SJVM_GetBooleanField,
    SJVM_GetByteField,
    SJVM_GetCharField,
    SJVM_GetShortField,
    SJVM_GetIntField,
    SJVM_GetLongField,
    SJVM_GetFloatField,
    SJVM_GetDoubleField,
    SJVM_SetObjectField,
    SJVM_SetBooleanField,
    SJVM_SetByteField,
    SJVM_SetCharField,
    SJVM_SetShortField,
    SJVM_SetIntField,
    SJVM_SetLongField,
    SJVM_SetFloatField,
    SJVM_SetDoubleField,
    SJVM_GetStaticMethodID,
    SJVM_CallStaticObjectMethod,
    SJVM_CallStaticObjectMethodV,
    SJVM_CallStaticObjectMethodA,
    SJVM_CallStaticBooleanMethod,
    SJVM_CallStaticBooleanMethodV,
    SJVM_CallStaticBooleanMethodA,
    SJVM_CallStaticByteMethod,
    SJVM_CallStaticByteMethodV,
    SJVM_CallStaticByteMethodA,
    SJVM_CallStaticCharMethod,
    SJVM_CallStaticCharMethodV,
    SJVM_CallStaticCharMethodA,
    SJVM_CallStaticShortMethod,
    SJVM_CallStaticShortMethodV,
    SJVM_CallStaticShortMethodA,
    SJVM_CallStaticIntMethod,
    SJVM_CallStaticIntMethodV,
    SJVM_CallStaticIntMethodA,
    SJVM_CallStaticLongMethod,
    SJVM_CallStaticLongMethodV,
    SJVM_CallStaticLongMethodA,
    SJVM_CallStaticFloatMethod,
    SJVM_CallStaticFloatMethodV,
    SJVM_CallStaticFloatMethodA,
    SJVM_CallStaticDoubleMethod,
    SJVM_CallStaticDoubleMethodV,
    SJVM_CallStaticDoubleMethodA,
    SJVM_CallStaticVoidMethod,
    SJVM_CallStaticVoidMethodV,
    SJVM_CallStaticVoidMethodA,
    SJVM_GetStaticFieldID,
    SJVM_GetStaticObjectField,
    SJVM_GetStaticBooleanField,
    SJVM_GetStaticByteField,
    SJVM_GetStaticCharField,
    SJVM_GetStaticShortField,
    SJVM_GetStaticIntField,
    SJVM_GetStaticLongField,
    SJVM_GetStaticFloatField,
    SJVM_GetStaticDoubleField,
    SJVM_SetStaticObjectField,
    SJVM_SetStaticBooleanField,
    SJVM_SetStaticByteField,
    SJVM_SetStaticCharField,
    SJVM_SetStaticShortField,
    SJVM_SetStaticIntField,
    SJVM_SetStaticLongField,
    SJVM_SetStaticFloatField,
    SJVM_SetStaticDoubleField,
    SJVM_NewString,
    SJVM_GetStringLength,
    SJVM_GetStringChars,
    SJVM_ReleaseStringChars,
    SJVM_NewStringUTF,
    SJVM_GetStringUTFLength,
    SJVM_GetStringUTFChars,
    SJVM_ReleaseStringUTFChars,
    SJVM_GetArrayLength,
    SJVM_NewObjectArray,
    SJVM_GetObjectArrayElement,
    SJVM_SetObjectArrayElement,
    SJVM_NewBooleanArray,
    SJVM_NewByteArray,
    SJVM_NewCharArray,
    SJVM_NewShortArray,
    SJVM_NewIntArray,
    SJVM_NewLongArray,
    SJVM_NewFloatArray,
    SJVM_NewDoubleArray,
    SJVM_GetBooleanArrayElements,
    SJVM_GetByteArrayElements,
    SJVM_GetCharArrayElements,
    SJVM_GetShortArrayElements,
    SJVM_GetIntArrayElements,
    SJVM_GetLongArrayElements,
    SJVM_GetFloatArrayElements,
    SJVM_GetDoubleArrayElements,
    SJVM_ReleaseBooleanArrayElements,
    SJVM_ReleaseByteArrayElements,
    SJVM_ReleaseCharArrayElements,
    SJVM_ReleaseShortArrayElements,
    SJVM_ReleaseIntArrayElements,
    SJVM_ReleaseLongArrayElements,
    SJVM_ReleaseFloatArrayElements,
    SJVM_ReleaseDoubleArrayElements,
    SJVM_GetBooleanArrayRegion,
    SJVM_GetByteArrayRegion,
    SJVM_GetCharArrayRegion,
    SJVM_GetShortArrayRegion,
    SJVM_GetIntArrayRegion,
    SJVM_GetLongArrayRegion,
    SJVM_GetFloatArrayRegion,
    SJVM_GetDoubleArrayRegion,
    SJVM_SetBooleanArrayRegion,
    SJVM_SetByteArrayRegion,
    SJVM_SetCharArrayRegion,
    SJVM_SetShortArrayRegion,
    SJVM_SetIntArrayRegion,
    SJVM_SetLongArrayRegion,
    SJVM_SetFloatArrayRegion,
    SJVM_SetDoubleArrayRegion,
    SJVM_RegisterNatives,
    SJVM_UnregisterNatives,
    SJVM_MonitorEnter,
    SJVM_MonitorExit,
    SJVM_GetJavaVM,
};

struct JNIInvokeInterface_ SJVM_JNIInvokeInterface = {
    NULL,
    NULL,
    NULL,
    SJVM_DestroyJavaVM,
    SJVM_AttachCurrentThread,
    SJVM_DetachCurrentThread,
    SJVM_GetEnv,
};
/**
 * I've had this on my harddrive forever, no idea where it came from, but I did
 * not write it, just modified it to be in a single file.
 */

//#define MEMORY_TRACE

#ifdef MEMORY_TRACE

#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>

#define LT_MALLOC  malloc
#define LT_FREE    free
#define LT_REALLOC realloc

/*
 * prime number for the address lookup hash table.
 * if you have _really_ many memory allocations, use a
 * higher value, like 343051 for instance.
 */
#define SOME_PRIME 343051
#define ADDR_HASH(addr) ((unsigned long) addr % SOME_PRIME)


#define MAGIC "\xAA\xBB\xCC\xDD\xEE\xF"
#define MAGIC_SIZE (sizeof(MAGIC)-1)


#define SAVEVALUE   0xAA

#define MEMCLEAN    0xEE

/**
 * Initial Number of memory allocations in our list.
 * Doubles for each re-allocation.
 */
#define INITIALSIZE 32768

static class LeakTracer {

    struct Leak {
        const void *addr;
        size_t size;
        const void *allocAddr;
        bool type;
        int nextBucket;
    };

    int newCount; // how many memory blocks do we have
    int leaksCount; // amount of entries in the leaks array
    int firstFreeSpot; // Where is the first free spot in the leaks array?
    int currentAllocated; // currentAllocatedMemory
    int maxAllocated; // maximum Allocated
    unsigned long totalAllocations; // total number of allocations. stats.
    unsigned int abortOn; // resons to abort program (see abortReason_t)

    
    bool initialized;
    bool destroyed; 

    Leak *leaks;

    int *leakHash; // fast lookup

    enum abortReason_t {
        OVERWRITE_MEMORY = 0x01, DELETE_NONEXISTENT = 0x02, NEW_DELETE_MISMATCH = 0x04
    };

public:

    LeakTracer() {
        initialize();
    }

    void initialize() {
        if (initialized) return;
        // fprintf(stderr, "LeakTracer::initialize()\n");
        initialized = true;
        newCount = 0;
        leaksCount = 0;
        firstFreeSpot = 1; // index '0' is special
        currentAllocated = 0;
        maxAllocated = 0;
        totalAllocations = 0;
        abortOn = OVERWRITE_MEMORY | DELETE_NONEXISTENT | NEW_DELETE_MISMATCH;
        leaks = 0;
        leakHash = 0;

        time_t t = time(NULL);
        fprintf(stderr, "# starting %s", ctime(&t));

        leakHash = (int*) LT_MALLOC(SOME_PRIME * sizeof (int));
        memset((void*) leakHash, 0x00, SOME_PRIME * sizeof (int));

#ifdef MAGIC
        fprintf(stderr, "# memory overrun protection of %d Bytes\n", MAGIC_SIZE);
#endif

#ifdef SAVEVALUE
        fprintf(stderr, "# initializing new memory with 0x%2X\n", SAVEVALUE);
#endif

#ifdef MEMCLEAN
        fprintf(stderr, "# sweeping deleted memory with 0x%2X\n", MEMCLEAN);
#endif

        if (getenv("LT_ABORTREASON")) {
            abortOn = atoi(getenv("LT_ABORTREASON"));
        }

#define PRINTREASON(x) if (abortOn & x) fprintf(stderr, "%s ", #x);
        fprintf(stderr, "# aborts on ");
        PRINTREASON(OVERWRITE_MEMORY);
        PRINTREASON(DELETE_NONEXISTENT);
        PRINTREASON(NEW_DELETE_MISMATCH);
        fprintf(stderr, "\n");
#undef PRINTREASON

        fprintf(stderr, "# not thread save; if you use threads, recompile with -DTHREAD_SAVE\n");
    }

    void* registerAlloc(size_t size, bool type);
    void registerFree(void *p, bool type);

    void hexdump(const unsigned char* area, int size);

    void progAbort(abortReason_t reason) {
        if (abortOn & reason) {
            fprintf(stderr, "# abort; DUMP of current state\n");
            fprintf(stderr, "LeakTracer aborting program\n");
            writeLeakReport();
            abort();
        }
    }

    void writeLeakReport();

    ~LeakTracer() {
        //fprintf(stderr, "LeakTracer::destroy()\n");
        time_t t = time(NULL);
        fprintf(stderr, "# finished %s", ctime(&t));
        writeLeakReport();
        free(leaks);
        destroyed = true;
    }
} leakTracer;

void* LeakTracer::registerAlloc(size_t size, bool type) {
    initialize();

    //fprintf(stderr, "LeakTracer::registerAlloc()\n");

    if (destroyed) {
        fprintf(stderr, "Oops, registerAlloc called after destruction of LeakTracer (size=%d)\n", size);
        return LT_MALLOC(size);
    }


    void *p = LT_MALLOC(size + MAGIC_SIZE);
    // Need to call the new-handler
    if (!p) {
        fprintf(stderr, "LeakTracer malloc %m\n");
        _exit(1);
    }

#ifdef SAVEVALUE
    memset(p, SAVEVALUE, size + MAGIC_SIZE);
#endif

#ifdef MAGIC
    memcpy((char*) p + size, MAGIC, MAGIC_SIZE);
#endif

    ++newCount;
    ++totalAllocations;
    currentAllocated += size;
    if (currentAllocated > maxAllocated)
        maxAllocated = currentAllocated;

    for (;;) {
        for (int i = firstFreeSpot; i < leaksCount; i++)
            if (leaks[i].addr == NULL) {
                leaks[i].addr = p;
                leaks[i].size = size;
                leaks[i].type = type;
                leaks[i].allocAddr = __builtin_return_address(1);
                firstFreeSpot = i + 1;
                // allow to lookup our index fast.
                int *hashPos = &leakHash[ ADDR_HASH(p) ];
                leaks[i].nextBucket = *hashPos;
                *hashPos = i;
                return p;
            }

        // Allocate a bigger array
        // Note that leaksCount starts out at 0.
        int new_leaksCount = (leaksCount == 0) ? INITIALSIZE
                : leaksCount * 2;
        leaks = (Leak*) LT_REALLOC(leaks, sizeof (Leak) * new_leaksCount);
        if (!leaks) {
            fprintf(stderr, "# LeakTracer realloc failed: %m\n");
            _exit(1);
        } else {
            fprintf(stderr, "# internal buffer now %d\n", new_leaksCount);
        }
        memset(leaks + leaksCount, 0x00, sizeof (Leak) * (new_leaksCount - leaksCount));
        leaksCount = new_leaksCount;
    }
}

void LeakTracer::hexdump(const unsigned char* area, int size) {
    fprintf(stderr, "# ");
    for (int j = 0; j < size; ++j) {
        fprintf(stderr, "%02x ", *(area + j));
        if (j % 16 == 15) {
            fprintf(stderr, "  ");
            for (int k = -15; k < 0; k++) {
                char c = (char) *(area + j + k);
                fprintf(stderr, "%c", isprint(c) ? c : '.');
            }
            fprintf(stderr, "\n# ");
        }
    }
    fprintf(stderr, "\n");
}

void LeakTracer::registerFree(void *p, bool type) {
    initialize();

    if (p == NULL)
        return;

    if (destroyed) {
        fprintf(stderr, "Oops, allocation destruction of LeakTracer (p=%p)\n", p);
        return;
    }

    int *lastPointer = &leakHash[ ADDR_HASH(p) ];
    int i = *lastPointer;

    while (i != 0 && leaks[i].addr != p) {
        lastPointer = &leaks[i].nextBucket;
        i = *lastPointer;
    }

    if (leaks[i].addr == p) {
        *lastPointer = leaks[i].nextBucket; // detach.
        newCount--;
        leaks[i].addr = NULL;
        currentAllocated -= leaks[i].size;
        if (i < firstFreeSpot)
            firstFreeSpot = i;

        if (leaks[i].type != type) {
            fprintf(stderr, "S %10p %10p  # new%s but delete%s "
                    "; size %d\n", leaks[i].allocAddr, __builtin_return_address(1), ((!type) ? "[]" : " normal"), ((type) ? "[]" : " normal"), leaks[i].size);

            progAbort(NEW_DELETE_MISMATCH);
        }
#ifdef MAGIC
        if (memcmp((char*) p + leaks[i].size, MAGIC, MAGIC_SIZE)) {
            fprintf(stderr, "O %10p %10p  "
                    "# memory overwritten beyond allocated"
                    " %d bytes\n", leaks[i].allocAddr, __builtin_return_address(1), leaks[i].size);
            fprintf(stderr, "# %d byte beyond area:\n", MAGIC_SIZE);
            hexdump((unsigned char*) p + leaks[i].size, MAGIC_SIZE);
            progAbort(OVERWRITE_MEMORY);
        }
#endif

#ifdef MEMCLEAN
        memset((unsigned char*) p, MEMCLEAN, leaks[i].size + MAGIC_SIZE);
#endif
        LT_FREE(p);
        return;
    }

    fprintf(stderr, "D %10p             # delete non alloc or twice pointer %10p\n", __builtin_return_address(1), p);
    progAbort(DELETE_NONEXISTENT);
}

void LeakTracer::writeLeakReport() {
    initialize();

    if (newCount > 0) {
        fprintf(stderr, "# LeakReport\n");
        fprintf(stderr, "# %10s | %9s  # Pointer Addr\n", "from new @", "size");
    }
    /*for (int i = 0; i < leaksCount ; i++)
        if (leaks[i].addr != NULL) {
            // This ought to be 64-bit safe?
            fprintf(stderr, "L %10p   %9ld  # %p\n", leaks[i].allocAddr, (long) leaks[i].size, leaks[i].addr);
        }*/
    fprintf(stderr, "# total allocation requests: %6ld ; max. mem used"
            " %d kBytes\n", totalAllocations, maxAllocated / 1024);
    fprintf(stderr, "# leak %6d Bytes\t:-%c\n", currentAllocated, (currentAllocated == 0) ? ')' : '(');
    if (currentAllocated > 50 * 1024) {
        fprintf(stderr, "# .. that is %d kByte!! A lot ..\n", currentAllocated / 1024);
    }
}

/** -- The actual new/delete operators -- **/

void* operator new(size_t size) {
    return leakTracer.registerAlloc(size, false);
}

void* operator new[] (size_t size) {
    return leakTracer.registerAlloc(size, true);
}

void operator delete (void *p) {
    leakTracer.registerFree(p, false);
}

void operator delete[] (void *p) {
    leakTracer.registerFree(p, true);
}

#endif

#include "jni.h"

#include "ClassFile.h"
#include "ClassLoader.h"
#include "SJVM.h"
#include "Thread.h"
#include "Object.h"

#include <iostream>
#include <fstream>
#include <cstring>

using namespace std;

void printall(); //object.cpp

/*
 * 
 */
int main(int argc, char** argv) {
    JavaVMInitArgs args;
    args.version = JNI_VERSION_1_1;
    args.nOptions = 1;
    args.options = new JavaVMOption[1];
    args.options->optionString = (char*)"/home/benland100/Desktop/sjvm/javatest/";
    JavaVM *vm;
    JNIEnv *env;
    JNI_CreateJavaVM(&vm,(void**)&env,(void*)&args);
    delete [] args.options;
    //jclass system = env->FindClass("java/lang/System");
    //jclass printstream = env->FindClass("java/io/PrintStream");
    //jfieldID outID = env->GetStaticFieldID(system,"out","Ljava/io/PrintStream;");
    //jobject out = env->GetStaticObjectField(system,outID);
    //cout << (int)out << '\n';
    //jclass mainclass = env->FindClass("smart/Client");
    //jmethodID main = env->GetStaticMethodID(mainclass,"main","([Ljava/lang/String;)V");
    //env->CallStaticVoidMethod(mainclass,main,env->NewObjectArray(0,env->FindClass("java/lang/String"),0));
    //jobject obj = env->AllocObject(exception);//env->NewObject(exception,einit);
    //env->CallVoidMethod(obj,einit);
    //jclass test = env->FindClass("fields/subclass");

    jclass mainclass = env->FindClass("javatest");
    jmethodID main = env->GetStaticMethodID(mainclass,"main","([Ljava/lang/String;)V");

    try {
        env->CallStaticVoidMethod(mainclass,main);
        if (env->ExceptionOccurred() == 0) {
            cout << "Executing Success\n";
        } else {
            cout << "Damn, exceptions...\n";
        }
    } catch ( ... ) {
    }
    env->DeleteLocalRef(mainclass);
    vm->DestroyJavaVM();
    return 0;
}

#include "MethodInfo.h"
#include "AttributeInfo.h"

#define U2(var,data,index) var = data[index++] << 8; var |= data[index++];
#define U4(var,data,index) var = data[index++] << 24; var |= data[index++] << 16; var |= data[index++] << 8; var |= data[index++];

MethodInfo::MethodInfo(unsigned char *data, int &index) {
    U2(accessFlags,data,index);
    U2(nameIndex,data,index);
    U2(descriptorIndex,data,index);
    U2(attributeCount,data,index);
    attributes = new AttributeInfo*[attributeCount];
    for (int i = 0; i < attributeCount; i++) 
        attributes[i] = new AttributeInfo(data, index);
    nargs = -1;
    argsc = -1;
    result = -1;
    native = 0;
    clazz = 0;
    resobject = 0;
}

MethodInfo::~MethodInfo() {
    if (code) delete code;
    for (int i = 0; i < attributeCount; i++) 
        delete attributes[i];
    delete [] attributes;
}

Code::Code(AttributeInfo *code) {
    unsigned char *data = code->data;
    int index = 0;
    U2(maxStack,data,index);
    U2(maxLocals,data,index);
    U4(codeLength,data,index);
    this->code = new unsigned char[codeLength];
    for (int i = 0; i < codeLength; i++) {
        this->code[i] = data[index+i];
    }
    index += codeLength;
    U2(exceptionCount,data,index);
    exceptions = new ExceptionEntry*[exceptionCount];
    for (int i = 0; i < exceptionCount; i++) {
        exceptions[i] = new ExceptionEntry;
        U2(exceptions[i]->startPC,data,index);
        U2(exceptions[i]->endPC,data,index);
        U2(exceptions[i]->handlerPC,data,index);
        U2(exceptions[i]->catchType,data,index);
    }
    U2(attributeCount,data,index);
    attributes = new AttributeInfo*[attributeCount];
    for (int i = 0; i < attributeCount; i++) 
        attributes[i] = new AttributeInfo(data, index);
}

Code::~Code() {
    delete [] code;
    for (int i = 0; i < exceptionCount; i++) {
        delete exceptions[i];
    }
    delete [] exceptions;
    for (int i = 0; i < attributeCount; i++) {
        delete attributes[i];
    }
    delete [] attributes;
}
#include "Mutex.h"
#include <pthread.h>
#include <cstring>

Mutex::Mutex() {
    pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;
    data = new pthread_mutex_t;
    memcpy(data,(void*)&mut,__SIZEOF_PTHREAD_MUTEX_T);
}

Mutex::Mutex(Mutex &ref) {
}

Mutex::~Mutex() {
    pthread_mutex_destroy( (pthread_mutex_t*) data);
    delete (pthread_mutex_t*) data;
}

void Mutex::lock() {
   pthread_mutex_lock( (pthread_mutex_t*) data );
}

void Mutex::unlock() {
   pthread_mutex_unlock( (pthread_mutex_t*) data );
}

Lock::Lock(Mutex *_mutex) : mutex(_mutex) {
    mutex->lock();
}

Lock::~Lock() {
    mutex->unlock();
};
/* 
 * File:   native.cpp
 * Author: Benjamin J. Land
 *
 * Created on December 17, 2008, 3:32 PM
 */

#include "Native.h"

#include <dlfcn.h>
#include <iostream>

#define DEBUG_OUTPUT

#ifdef DEBUG_OUTPUT
#define debug(v) std::cout << v;
#else
#define debug(v)
#endif

LibraryPool::LibraryPool() {
    libraries[""] = dlopen(0, RTLD_GLOBAL | RTLD_NOW);
}

LibraryPool::~LibraryPool() {
    for (std::map<std::string,void*>::iterator iter = libraries.begin(); iter != libraries.end(); iter++) {
        dlclose(iter->second);
    }
    libraries.clear();
}

int LibraryPool::loadlib(const char *library) {
    void* ptr = (void*) dlopen(library, RTLD_GLOBAL | RTLD_NOW);
    if (ptr) libraries[library] = ptr;
    return (int) ptr;
}

void* LibraryPool::address(const char *name) {
    debug("Requesting Symbol: " << name << '\n');
    for (std::map<std::string,void*>::iterator iter = libraries.begin(); iter != libraries.end(); iter++) {
        void* lib = iter->second;
        void *ptr = dlsym(lib, name);
        if (ptr) return ptr;
    }
    return 0;
}

#include <set>

#include <set>

#include "Object.h"
#include "Arrays.h"
#include "ClassFile.h"

#include <iostream>
#include <set>

//#define DEBUG_OUTPUT

#ifdef DEBUG_OUTPUT
#define debug(v) std::cout << v;
#else
#define debug(v)
#endif

Object::Object() {
    debug("Object Constructor: " << (int)this << '\n');
    type = 0;
    fields = 0;
    staticCount = 0;
    refCount = 0;
    localCount = 0;
}

Object::~Object() {
    debug("Object Destructor: " << (int)this << '\n');
    if (fields) delete [] fields;
}

#include "jni.h"
#include "GarbageCollector.h"
#include "Arrays.h"
#include "ClassFile.h"
#include "ClassLoader.h"
#include "CPInfo.h"
#include "SJVM.h"
#include "MethodInfo.h"
#include "FieldInfo.h"
#include "Exception.h"
#include "Native.h"
#include "jni.h"

#include <iostream>
#include <map>
#include <string>
#include <sstream>
#include <fstream>
#include <cstring>

#define WARNING_OUTPUT
//#define DEBUG_OUTPUT

#ifdef DEBUG_OUTPUT
#define debug(v) std::cout << v;
#else
#define debug(v)
#endif

#ifdef WARNING_OUTPUT
#define warn(v) std::cout << "WARNING: " << v;
#else
#define warn(v)
#endif

SJVM::SJVM(ClassPath *path) {
    gc = new GlobalGC;
    loader = new ClassLoader(path);
    vm = new JavaVM;
    JNIInvokeInterface_ *functions = new JNIInvokeInterface_;
    memcpy(functions, &SJVM_JNIInvokeInterface, sizeof (JNIInvokeInterface_));
    functions->reserved0 = this;
    vm->functions = functions;
}

SJVM::~SJVM() {
    delete gc;
    delete loader;
    delete vm->functions;
    delete vm;
    debug("SJVM Destroyed");
}

extern "C" void JNICALL Java_sjvm_SJVM_nativePrint(JNIEnv* env, jclass type, jstring string) {
    const char* bytes = env->GetStringUTFChars(string, 0);
    std::cout << bytes << '\n';
    env->ReleaseStringUTFChars(string, bytes);
}

ClassFile* SJVM::loadClass(const char* name) {
    return loader->load(name, this);
}

JavaVM* SJVM::getJavaVM() {
    return vm;
}

#include <math.h>
#include "OPCodes.h"
#include "Thread.h"
#include "Native.h"
#include "GarbageCollector.h"
#define U2(var,data,index) var = data[index++] << 8; var |= data[index++];
#define U4(var,data,index) var = data[index++] << 24; var |= data[index++] << 16; var |= data[index++] << 8; var |= data[index++];

/**
 * args are treated as a 32bit array, longs happen to be 32 bits
 * exception sets the value to zero if no exception, otherwise a pointer to
 * a valid exception object (must be freed by caller) 
 */
Variable SJVM::execute(MethodInfo *meth, ClassFile *cur, Thread* thread, long* args, long argsc, Exception **thrown) {
    debug("Invoked " << meth->full << " from " << cur->name << '\n');
    *thrown = 0;
    LocalGC localgc(gc, thread);
    if (meth->native || meth->accessFlags & 0x0100) {
        if (meth->accessFlags & 0x0008) {
            argsc += 2;
            long *newargs = new long[argsc];
            newargs[0] = (long) thread->getEnv();
            newargs[1] = (long) cur;
            for (int i = 2; i < argsc; i++)
                newargs[i] = args[i - 2];
            args = newargs;
        } else {
            argsc++;
            long *newargs = new long[argsc];
            newargs[0] = (long) thread->getEnv();
            for (int i = 1; i < argsc; i++)
                newargs[i] = args[i - 1];
            args = newargs;
        }
        if (meth->native == 0) {
            debug("Locating Native Method\n");
            std::stringstream fullname;
            fullname << "Java_";
            std::string classname(cur->name);
            for (int i = 0; (i = classname.find('_', i)) != std::string::npos; i += 2)
                classname.replace(i, 1, "_1", 0, 2);
            for (int i = 0; (i = classname.find('/', i)) != std::string::npos; i += 1)
                classname.replace(i, 1, "_", 0, 1);
            fullname << classname;
            std::string methodname(meth->name);
            for (int i = 0; (i = methodname.find('_', i)) != std::string::npos; i += 2)
                methodname.replace(i, 1, "_1", 0, 2);
            for (int i = 0; (i = methodname.find('/', i)) != std::string::npos; i += 1)
                methodname.replace(i, 1, "_", 0, 1);
            fullname << "_";
            fullname << methodname;
            std::stringstream search;
            search << fullname.str();
            //search << '@' << argsc * 4;
            debug("Searching for native... " << search.str() << '\n');
            if (!(meth->native = libpool.address(search.str().c_str()))) {
                std::string descriptor;
                descriptor.append(meth->descriptor, 1, meth->descriptor.find(')') - 1);
                for (int i = 0; (i = descriptor.find('_', i)) != std::string::npos; i += 2)
                    descriptor.replace(i, 1, "_1", 0, 2);
                for (int i = 0; (i = descriptor.find(';', i)) != std::string::npos; i += 2)
                    descriptor.replace(i, 1, "_2", 0, 2);
                for (int i = 0; (i = descriptor.find('[', i)) != std::string::npos; i += 2)
                    descriptor.replace(i, 1, "_3", 0, 2);
                for (int i = 0; (i = descriptor.find('/', i)) != std::string::npos; i += 1)
                    descriptor.replace(i, 1, "_", 0, 1);
                search.seekp(0);
                fullname << "__";
                fullname << descriptor;
                search << fullname.str();
                //search << '@' << argsc * 4;
                debug("Searching for native... " << search.str() << '\n');
                if (!(meth->native = libpool.address(search.str().c_str()))) {
                    warn("Failed to locate native method: " << search.str() << '\n');
                    Variable result;
                    result.j = 0;
                    /*JNIEnv* env = thread->getEnv();
                    jclass clazz = env->FindClass("java/lang/UnsatisfiedLinkError");
                    if (thread->nativeException) return result;
                    jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                    JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                     *thrown = new Exception(cur, meth, obj);*/
                    delete [] args;
                    return result;
                }
            }
        }
        debug("Native address: " << (unsigned int) meth->native << '\n');
        thread->nativeException = 0;
        long resl, resh;
        asm ("1:\n"
                    "dec %%ecx\n"
                    "push (%%edx,%%ecx,4)\n"
                    "jnz 1b\n"
                    "call *%%eax"
                    : "=a" (resl), "=d" (resh)
                    : "c" (argsc), "d" (args), "a" (meth->native)
                    : "memory");
        delete [] args;
        *thrown = thread->nativeException;
        if (meth->resobject) thread->nativeLocal->removeLocal((JOBJECT) resl);
        Variable result;
        if (meth->result == 2) {
            result.j = ((long long) resh << 32) | (resl);
        } else if (meth->result == 1) {
            result.i = resl;
        }
        return result;
    } else {
        CPInfo **cp = cur->cp;
        long locals[meth->code->maxLocals];
        for (int i = 0; i < argsc; i++)
            locals[i] = args[i];
        long stackStart[meth->code->maxStack];
        long *stack = stackStart - 1;
        unsigned char *bc = meth->code->code;
        unsigned int pc = 0;
        Exception *exception = 0;
        for (;;) {
            debug("OP: " << (unsigned int) bc[pc] << '\n');
            switch (bc[pc++]) {
                case aaload:
                {
                    int pos = *(stack--);
                    JOBJECTARRAY array = (JOBJECTARRAY) * stack;
                    if (!array) {
                        JNIEnv* env = thread->getEnv();
                        debug("aaload null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    if (pos < 0 || pos >= array->size) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "(I)V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id, pos);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    *(JOBJECT*) stack = array->array[pos];
                    localgc.addLocal(*(JOBJECT*) stack);
                    break;
                }
                case aastore:
                {
                    JOBJECT obj = *(JOBJECT*) (stack--);
                    int pos = *(stack--);
                    JOBJECTARRAY array = (JOBJECTARRAY) *(stack--);
                    if (!array) {
                        JNIEnv* env = thread->getEnv();
                        debug("aastore null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    if (pos < 0 || pos >= array->size) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "(I)V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id, pos);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    JOBJECT old = array->array[pos];
                    if (old) gc->decrRef(old);
                    array->array[pos] = obj;
                    gc->incrRef(obj);
                    break;
                }
                case aconst_null:
                    stack++;
                    *stack = 0;
                    break;
                case aload:
                    stack++;
                    *stack = locals[bc[pc++]];
                    break;
                case aload_0:
                    stack++;
                    *stack = locals[0];
                    break;
                case aload_1:
                    stack++;
                    *stack = locals[1];
                    break;
                case aload_2:
                    stack++;
                    *stack = locals[2];
                    break;
                case aload_3:
                    stack++;
                    *stack = locals[3];
                    break;
                case anewarray:
                {
                    int size = *(stack--);
                    unsigned short index;
                    U2(index, bc, pc);
                    ClassInfo *cinfo = (ClassInfo*) cp[index];
                    ClassFile* arrayType;
                    if (cinfo->classRef == 0) {
                        std::string name(((UTF8Info*) cp[cinfo->nameIndex])->bytes);
                        arrayType = loader->load((char*) name.c_str(), this);
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        cinfo->classRef = arrayType;
                        cinfo->name = name;
                    } else {
                        arrayType = cinfo->classRef;
                    }
                    std::string name("[");
                    name.append(cinfo->name);
                    JOBJECTARRAY array = ClassFile::newArray<JOBJECT>(this,(char*)name.c_str(),size);
                    *(JOBJECT*) (++stack) = array;
                    localgc.addLocal(*(JOBJECT*) stack);
                    debug("anewarray\n");
                    break;
                }
                case areturn:
                {
                    Variable result;
                    result.l = *(JOBJECT*) stack;
                    localgc.removeLocal(result.l);
                    return result;
                }
                case arraylength:
                    if (!(*(JOBJECTARRAY*) stack)) {
                        JNIEnv* env = thread->getEnv();
                        debug("arraylength null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    *stack = ((JOBJECTARRAY) * stack)->size; //type irrelevant
                    break;
                case astore:
                    locals[bc[pc++]] = *stack;
                    stack--;
                    break;
                case astore_0:
                    locals[0] = *stack;
                    stack--;
                    break;
                case astore_1:
                    locals[1] = *stack;
                    stack--;
                    break;
                case astore_2:
                    locals[2] = *stack;
                    stack--;
                    break;
                case astore_3:
                    locals[3] = *stack;
                    stack--;
                    break;
                case baload:
                {
                    int pos = *(stack--);
                    JBYTEARRAY array = (JBYTEARRAY) * stack;
                    if (!array) {
                        JNIEnv* env = thread->getEnv();
                        debug("baload null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    if (pos < 0 || pos >= array->size) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "(I)V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id, pos);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    *stack = array->array[pos];
                    break;
                }
                case bastore:
                {
                    JBYTE b = *(stack--);
                    int pos = *(stack--);
                    JBYTEARRAY array = (JBYTEARRAY) *(stack--);
                    if (!array) {
                        JNIEnv* env = thread->getEnv();
                        debug("bastore null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    if (pos < 0 || pos >= array->size) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "(I)V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id, pos);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    array->array[pos] = b;
                    break;
                }
                case bipush:
                    *(++stack) = bc[pc++];
                    break;
                case caload:
                {
                    int pos = *(unsigned int*) (stack--);
                    JCHARARRAY array = (JCHARARRAY) * stack;
                    if (!array) {
                        JNIEnv* env = thread->getEnv();
                        debug("caload null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    if (pos < 0 || pos >= array->size) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "(I)V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id, pos);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    *stack = array->array[pos];
                    break;
                }
                case castore:
                {
                    JCHAR c = *(unsigned int*) (stack--);
                    int pos = *(stack--);
                    JCHARARRAY array = (JCHARARRAY) *(stack--);
                    if (!array) {
                        JNIEnv* env = thread->getEnv();
                        debug("castore null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    if (pos < 0 || pos >= array->size) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "(I)V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id, pos);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    array->array[pos] = c;
                    break;
                }
                case checkcast:
                {
                    unsigned short index;
                    U2(index, bc, pc);
                    ClassInfo *cinfo = (ClassInfo*) cp[index];
                    ClassFile *type;
                    if (cinfo->classRef == 0) {
                        std::string name(((UTF8Info*) cp[cinfo->nameIndex])->bytes);
                        type = loader->load((char*) name.c_str(), this);
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        cinfo->classRef = type;
                        cinfo->name = name;
                    } else {
                        type = cinfo->classRef;
                    }
                    if (!(*(JOBJECT*) stack)) break;
                    if (!type->instanceOf(*(JOBJECT*) stack)) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ClassCastException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    break;
                }
                case d2f:
                    *(JFLOAT*) (--stack) = (JFLOAT) *((JDOUBLE*) (stack - 1));
                    break;
                case d2i:
                    *(JINT*) (--stack) = (JINT) *((JDOUBLE*) (stack - 1));
                    break;
                case d2l:
                    *(JLONG*) (stack - 1) = (JLONG) *((JDOUBLE*) (stack - 1));
                    break;
                case dadd:
                {
                    double a = *((JDOUBLE*) (stack - 1));
                    stack -= 2;
                    *(JDOUBLE*) (stack - 1) = *(JDOUBLE*) (stack - 1) + a;
                    debug("dadd: " << *(JDOUBLE*) (stack - 1) << '\n');
                    break;
                }
                case daload:
                {
                    int pos = *(stack--);
                    JDOUBLEARRAY array = (JDOUBLEARRAY) * stack;
                    if (!array) {
                        JNIEnv* env = thread->getEnv();
                        debug("daload null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    if (pos < 0 || pos >= array->size) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "(I)V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id, pos);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    *(JDOUBLE*) (stack++) = array->array[pos];
                    break;
                }
                case dastore:
                {
                    JDOUBLE d = *((JDOUBLE*) (stack - 1));
                    stack -= 2;
                    int pos = *(stack--);
                    JDOUBLEARRAY array = (JDOUBLEARRAY) *(stack--);
                    if (!array) {
                        JNIEnv* env = thread->getEnv();
                        debug("dastore null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    if (pos < 0 || pos >= array->size) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "(I)V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id, pos);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    array->array[pos] = d;
                    break;
                }
                case dcmpl:
                case dcmpg:
                {
                    JDOUBLE a = *((JDOUBLE*) (stack - 1));
                    stack -= 2;
                    JDOUBLE b = *((JDOUBLE*) (stack - 1));
                    stack -= 2;
                    if (b > a) *(++stack) = 1;
                    if (b < a) *(++stack) = -1;
                    if (b == a) *(++stack) = 0;
                    debug("dcmp[l/g]: " << a << " " << b << " " << *stack << '\n');
                    break;
                }
                case dconst_0:
                    *(JDOUBLE*) (++stack) = (JDOUBLE) 0;
                    stack++;
                    break;
                case dconst_1:
                    *(JDOUBLE*) (++stack) = (JDOUBLE) 1;
                    stack++;
                    break;
                case ddiv:
                {
                    double a = *((JDOUBLE*) (stack - 1));
                    stack -= 2;
                    *(JDOUBLE*) (stack - 1) = *(JDOUBLE*) (stack - 1) / a;
                    break;
                }
                case dload:
                    *(++stack) = locals[bc[pc]];
                    *(++stack) = locals[bc[pc++]];
                    break;
                case dload_0:
                    *(++stack) = locals[0];
                    *(++stack) = locals[1];
                    break;
                case dload_1:
                    *(++stack) = locals[1];
                    *(++stack) = locals[2];
                    break;
                case dload_2:
                    *(++stack) = locals[2];
                    *(++stack) = locals[3];
                    break;
                case dload_3:
                    *(++stack) = locals[3];
                    *(++stack) = locals[4];
                    break;
                case dmul:
                {
                    double a = *((JDOUBLE*) (stack - 1));
                    stack -= 2;
                    *(JDOUBLE*) (stack - 1) = *(JDOUBLE*) (stack - 1) * a;
                    break;
                }
                case dneg:
                    *(JDOUBLE*) (stack - 1) = -(*(JDOUBLE*) (stack - 1));
                    break;
                case drem:
                {
                    double a = *((JDOUBLE*) (stack - 1));
                    stack -= 2;
                    *(JDOUBLE*) (stack - 1) = fmod(*(JDOUBLE*) (stack - 1), a);
                    break;
                }
                case dreturn:
                {
                    Variable result;
                    result.d = *(JDOUBLE*) (stack - 1);
                    return result;
                }
                case dstore:
                    locals[bc[pc]] = *(stack - 1);
                    locals[bc[pc++]] = *(stack);
                    stack -= 2;
                    break;
                case dstore_0:
                    locals[0] = *(stack - 1);
                    locals[1] = *(stack);
                    stack -= 2;
                    break;
                case dstore_1:
                    locals[1] = *(stack - 1);
                    locals[2] = *(stack);
                    stack -= 2;
                    break;
                    ;
                case dstore_2:
                    locals[2] = *(stack - 1);
                    locals[3] = *(stack);
                    stack -= 2;
                    break;
                case dstore_3:
                    locals[3] = *(stack - 1);
                    locals[4] = *(stack);
                    stack -= 2;
                    break;
                case dsub:
                {
                    double a = *((JDOUBLE*) (stack - 1));
                    stack -= 2;
                    *(JDOUBLE*) (stack - 1) = *(JDOUBLE*) (stack - 1) - a;
                    break;
                }
                case dup:
                {
                    int temp = *stack;
                    *(++stack) = temp;
                    break;
                }
                case dup_x1:
                {
                    int temp = *stack;
                    int last = *(--stack);
                    *stack = temp;
                    *(++stack) = last;
                    *(++stack) = temp;
                    break;
                }
                case dup_x2:
                {
                    int temp = *stack;
                    int last1 = *(--stack);
                    int last2 = *(--stack);
                    *stack = temp;
                    *(++stack) = last2;
                    *(++stack) = last1;
                    *(++stack) = temp;
                    break;
                }
                case dup2: //assumes being used on cat2
                {
                    int h = *(stack - 1);
                    int l = *(stack);
                    *(++stack) = h;
                    *(++stack) = l;
                    break;
                }
                case dup2_x1: //assumes being used on cat2
                {
                    int h = *(stack - 1);
                    int l = *(stack);
                    int last = *(stack - 2);
                    stack -= 3;
                    *(++stack) = h;
                    *(++stack) = l;
                    *(++stack) = last;
                    *(++stack) = h;
                    *(++stack) = l;
                    break;
                    break;
                }
                case dup2_x2: //assumes being used on cat2
                {
                    int h = *(stack - 1);
                    int l = *(stack);
                    int lasth = *(stack - 2);
                    int lastl = *(stack - 3);
                    stack -= 4;
                    *(++stack) = h;
                    *(++stack) = l;
                    *(++stack) = lastl;
                    *(++stack) = lasth;
                    *(++stack) = h;
                    *(++stack) = l;
                    break;
                }
                case f2d:
                    *(JDOUBLE*) stack = (JDOUBLE) *(JFLOAT*) stack;
                    stack++;
                    break;
                case f2i:
                    *(JINT*) stack = (JINT) *(JFLOAT*) stack;
                    break;
                case f2l:
                    *(JLONG*) stack = (JLONG) *(JFLOAT*) stack;
                    stack++;
                    break;
                case fadd:
                {
                    JFLOAT a = *(JFLOAT*) (stack--);
                    debug("fadd: " << a << '+');
                    debug(*(JFLOAT*) stack << '=');
                    *(JFLOAT*) stack = *(JFLOAT*) stack + a;
                    debug(*(JFLOAT*) stack << '\n');
                    break;
                }
                case faload:
                {
                    int pos = *(stack--);
                    JFLOATARRAY array = (JFLOATARRAY) * stack;
                    if (!array) {
                        JNIEnv* env = thread->getEnv();
                        debug("faload null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    if (pos < 0 || pos >= array->size) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "(I)V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id, pos);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    *(JFLOAT*) stack = array->array[pos];
                    break;
                }
                case fastore:
                {
                    JFLOAT f = *(stack--);
                    int pos = *(stack--);
                    JFLOATARRAY array = (JFLOATARRAY) *(stack--);
                    if (!array) {
                        JNIEnv* env = thread->getEnv();
                        debug("fastore null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    if (pos < 0 || pos >= array->size) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "(I)V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id, pos);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    array->array[pos] = f;
                    break;
                }
                case fcmpl:
                case fcmpg:
                {
                    JFLOAT a = *(JFLOAT*) (stack--);
                    JFLOAT b = *(JFLOAT*) (stack);
                    if (b > a) *(stack) = 1;
                    if (b < a) *(stack) = -1;
                    if (b == a) *(stack) = 0;
                    debug("fcmp[l/g]: " << a << " " << b << " " << *stack << '\n');
                    break;
                }
                case fconst_0:
                    *(++stack) = 0;
                    break;
                case fconst_1:
                    *(++stack) = 1;
                    break;
                case fconst_2:
                    *(++stack) = 2;
                    break;
                case fdiv:
                {
                    JFLOAT a = *(JFLOAT*) (stack--);
                    *(JFLOAT*) stack = *(JFLOAT*) stack / a;
                    break;
                }
                case fload:
                    *(++stack) = locals[bc[pc++]];
                    debug("fload: " << *(JFLOAT*) stack << '\n');
                    break;
                case fload_0:
                    *(++stack) = locals[0];
                    break;
                case fload_1:
                    *(++stack) = locals[1];
                    break;
                case fload_2:
                    *(++stack) = locals[2];
                    break;
                case fload_3:
                    *(++stack) = locals[3];
                    break;
                case fmul:
                {
                    float a = *(JFLOAT*) (stack--);
                    *(JFLOAT*) stack = *(JFLOAT*) stack * a;
                    break;
                }
                case fneg:
                    *stack = -(*stack);
                    break;
                case frem:
                {
                    JFLOAT a = *(stack--);
                    *(JFLOAT*) stack = fmod(*(JFLOAT*) stack, a);
                    break;
                }
                case freturn:
                {
                    Variable result;
                    result.f = *(JFLOAT*) stack;
                    return result;
                }
                case fstore:
                    locals[bc[pc++]] = *stack;
                    debug("fstore: " << *(JFLOAT*) stack << '\n');
                    stack--;
                    break;
                case fstore_0:
                    locals[0] = *stack;
                    stack--;
                    break;
                case fstore_1:
                    locals[1] = *stack;
                    stack--;
                    break;
                case fstore_2:
                    locals[2] = *stack;
                    stack--;
                    break;
                case fstore_3:
                    locals[3] = *stack;
                    stack--;
                    break;
                case fsub:
                {
                    JFLOAT a = *(JFLOAT*) (stack--);
                    *(JFLOAT*) stack = *(JFLOAT*) stack - a;
                    break;
                }
                case getfield:
                {
                    unsigned short int index;
                    U2(index, bc, pc);
                    FieldMethodInfo *info = (FieldMethodInfo*) cp[index];
                    ClassInfo *cinfo = (ClassInfo*) cp[info->classIndex];
                    JCLASS type;
                    if (cinfo->classRef == 0) {
                        std::string name(((UTF8Info*) cp[cinfo->nameIndex])->bytes);
                        type = loader->load((char*) name.c_str(), this);
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        cinfo->classRef = type;
                        cinfo->name = name;
                    } else {
                        type = cinfo->classRef;
                    }
                    FieldInfo *field;
                    if (info->fieldRef == 0) {
                        if (info->name.size() < 1)
                            info->name.append(((UTF8Info*) cp[((NameAndTypeInfo*) cp[info->nameAndTypeIndex])->nameIndex])->bytes);
                        field = 0;
                        for (JCLASS find = type; find != 0 && field == 0; find = find->superClass)
                            if (find->fieldMap.find(info->name) != find->fieldMap.end())
                                field = find->fieldMap[info->name];
                        info->fieldRef = field;
                    } else {
                        field = info->fieldRef;
                    }
                    debug("getfield: " << field->descriptor << " " << field->name << '\n');
                    if (!(*(JOBJECT*) stack)) {
                        JNIEnv* env = thread->getEnv();
                        debug("getfield null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    switch (field->descriptor.c_str()[0]) {
                        case 'D':
                        case 'J':
                            *(JLONG*) stack = (*(JOBJECT*) stack)->fields[field->index].j;
                            stack++;
                            break;
                        case 'L':
                        case '[':
                            *stack = (*(JOBJECT*) stack)->fields[field->index].i;
                            localgc.addLocal(*(JOBJECT*) stack);
                            break;
                        default:
                            *stack = (*(JOBJECT*) stack)->fields[field->index].i;
                    }
                    break;
                }
                case getstatic:
                {
                    unsigned short int index;
                    U2(index, bc, pc);
                    FieldMethodInfo *info = (FieldMethodInfo*) cp[index];
                    FieldInfo *field;
                    if (info->fieldRef == 0) {
                        ClassInfo *cinfo = (ClassInfo*) cp[info->classIndex];
                        JCLASS type;
                        if (cinfo->classRef == 0) {
                            std::string name(((UTF8Info*) cp[cinfo->nameIndex])->bytes);
                            type = loader->load((char*) name.c_str(), this);
                            if (thread->nativeException) goto EXCEPTION_HANDLER;
                            cinfo->classRef = type;
                            cinfo->name = name;
                        } else {
                            type = cinfo->classRef;
                        }
                        if (info->name.size() < 1)
                            info->name.append(((UTF8Info*) cp[((NameAndTypeInfo*) cp[info->nameAndTypeIndex])->nameIndex])->bytes);
                        field = 0;
                        for (JCLASS find = type; find != 0 && field == 0; find = find->superClass)
                            if (find->fieldMap.find(info->name) != find->fieldMap.end())
                                field = find->fieldMap[info->name];
                        info->fieldRef = field;
                    } else {
                        field = info->fieldRef;
                    }
                    debug("getstatic: " << field->descriptor << " " << field->name << '\n');
                    switch (field->descriptor.c_str()[0]) {
                        case 'D':
                        case 'J':
                            *(JLONG*) (stack + 1) = field->staticValue.j;
                            stack += 2;
                            break;
                        case 'L':
                        case '[':
                            *(++stack) = field->staticValue.i;
                            localgc.addLocal(*(JOBJECT*) stack);
                            break;
                        default:
                            *(++stack) = field->staticValue.i;
                    }
                    break;
                }
                case jump:
                {
                    int orig = pc - 1;
                    short int offset;
                    U2(offset, bc, pc);
                    pc = orig + offset; //fight the autoinc
                    break;
                }
                case jump_w:
                {
                    int orig = pc - 1;
                    long int offset;
                    U4(offset, bc, pc);
                    pc = orig + offset; //fight the autoinc
                    break;
                }
                case i2b:
                    *(JBYTE*) stack = (JBYTE) *(JINT*) stack;
                    break;
                case i2c:
                    *(JCHAR*) stack = (JCHAR) *(JINT*) stack;
                    break;
                case i2d:
                    *(JDOUBLE*) stack = (JDOUBLE) *(JINT*) stack;
                    stack++;
                    break;
                case i2f:
                    *(JFLOAT*) stack = (JFLOAT) *(JINT*) stack;
                    break;
                case i2l:
                    *(JLONG*) stack = (JLONG) *(JINT*) stack;
                    stack++;
                    break;
                case i2s:
                    *(JSHORT*) stack = (JSHORT) *(JINT*) stack;
                    break;
                case iadd:
                {
                    JINT a = *(stack--);
                    *stack = *stack + a;
                    debug("iadd: " << *stack << '\n');
                    break;
                }
                case iaload:
                {
                    int pos = *(stack--);
                    JINTARRAY array = (JINTARRAY) * stack;
                    if (!array) {
                        JNIEnv* env = thread->getEnv();
                        debug("iaload null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    if (pos < 0 || pos >= array->size) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "(I)V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id, pos);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    *stack = array->array[pos];
                    break;
                }
                case iand:
                {
                    JINT a = *(stack--);
                    *stack = *stack & a;
                    break;
                }
                case iastore:
                {
                    JINT i = *(stack--);
                    int pos = *(stack--);
                    JINTARRAY array = (JINTARRAY) *(stack--);
                    if (!array) {
                        JNIEnv* env = thread->getEnv();
                        debug("iastore null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    if (pos < 0 || pos >= array->size) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "(I)V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id, pos);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    array->array[pos] = i;
                    break;
                }
                case iconst_m1:
                    *(++stack) = -1;
                    break;
                case iconst_0:
                    *(++stack) = 0;
                    break;
                case iconst_1:
                    *(++stack) = 1;
                    break;
                case iconst_2:
                    *(++stack) = 2;
                    break;
                case iconst_3:
                    *(++stack) = 3;
                    break;
                case iconst_4:
                    *(++stack) = 4;
                    break;
                case iconst_5:
                    *(++stack) = 5;
                    break;
                case idiv:
                {
                    JINT a = *(stack--);
                    if (a == 0) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArithmeticException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    *stack = *stack / a;
                    break;
                }
                case if_acmpeq:
                {
                    int orig = pc - 1;
                    JOBJECT a = *(JOBJECT*) (stack--);
                    JOBJECT b = *(JOBJECT*) (stack--);
                    short int offset;
                    U2(offset, bc, pc);
                    if (a == b) pc = orig + offset;
                    break;
                }
                case if_acmpne:
                {
                    int orig = pc - 1;
                    JOBJECT a = *(JOBJECT*) (stack--);
                    JOBJECT b = *(JOBJECT*) (stack--);
                    short int offset;
                    U2(offset, bc, pc);
                    if (a != b) pc = orig + offset;
                    break;
                }
                case if_icmpeq:
                {
                    int orig = pc - 1;
                    JINT b = *(stack--);
                    JINT a = *(stack--);
                    short int offset;
                    U2(offset, bc, pc);
                    if (a == b) pc = orig + offset;
                    break;
                }
                case if_icmpne:
                {
                    int orig = pc - 1;
                    JINT b = *(stack--);
                    JINT a = *(stack--);
                    short int offset;
                    U2(offset, bc, pc);
                    if (a != b) pc = orig + offset;
                    break;
                }
                case if_icmplt:
                {
                    int orig = pc - 1;
                    JINT b = *(stack--);
                    JINT a = *(stack--);
                    short int offset;
                    U2(offset, bc, pc);
                    if (a < b) pc = orig + offset;
                    break;
                }
                case if_icmple:
                {
                    int orig = pc - 1;
                    JINT b = *(stack--);
                    JINT a = *(stack--);
                    short int offset;
                    U2(offset, bc, pc);
                    if (a <= b) pc = orig + offset;
                    break;
                }
                case if_icmpgt:
                {
                    int orig = pc - 1;
                    JINT b = *(stack--);
                    JINT a = *(stack--);
                    short int offset;
                    U2(offset, bc, pc);
                    if (a > b) pc = orig + offset;
                    break;
                }
                case if_icmpge:
                {
                    int orig = pc - 1;
                    JINT b = *(stack--);
                    JINT a = *(stack--);
                    short int offset;
                    U2(offset, bc, pc);
                    if (a >= b) pc = orig + offset;
                    break;
                }
                case ifeq:
                {
                    int orig = pc - 1;
                    JINT a = *(stack--);
                    short int offset;
                    U2(offset, bc, pc);
                    if (a == 0) pc = orig + offset;
                    break;
                }
                case ifne:
                {
                    int orig = pc - 1;
                    JINT a = *(stack--);
                    short int offset;
                    U2(offset, bc, pc);
                    if (a != 0) pc = orig + offset;
                    break;
                }
                case iflt:
                {
                    int orig = pc - 1;
                    JINT a = *(stack--);
                    short int offset;
                    U2(offset, bc, pc);
                    if (a < 0) pc = orig + offset;
                    break;
                }
                case ifle:
                {
                    int orig = pc - 1;
                    JINT a = *(stack--);
                    short int offset;
                    U2(offset, bc, pc);
                    if (a <= 0) pc = orig + offset;
                    break;
                }
                case ifgt:
                {
                    int orig = pc - 1;
                    JINT a = *(stack--);
                    short int offset;
                    U2(offset, bc, pc);
                    if (a > 0) pc = orig + offset;
                    break;
                }
                case ifge:
                {
                    int orig = pc - 1;
                    JINT a = *(stack--);
                    short int offset;
                    U2(offset, bc, pc);
                    if (a >= 0) pc = orig + offset;
                    break;
                }
                case ifnonnull:
                {
                    int orig = pc - 1;
                    JOBJECT a = *(JOBJECT*) (stack--);
                    short int offset;
                    U2(offset, bc, pc);
                    if (a != 0) pc = orig + offset;
                    break;
                }
                case ifnull:
                {
                    int orig = pc - 1;
                    JOBJECT a = *(JOBJECT*) (stack--);
                    short int offset;
                    U2(offset, bc, pc);
                    if (a == 0) pc = orig + offset;
                    break;
                }
                case iinc:
                {
                    int i = bc[pc++];
                    JBYTE b = (JBYTE) bc[pc++];
                    locals[i] += b;
                    break;
                }
                case iload:
                    *(++stack) = locals[bc[pc++]];
                    break;
                case iload_0:
                    *(++stack) = locals[0];
                    break;
                case iload_1:
                    *(++stack) = locals[1];
                    break;
                case iload_2:
                    *(++stack) = locals[2];
                    break;
                case iload_3:
                    *(++stack) = locals[3];
                    break;
                case imul:
                {
                    JINT a = *(stack--);
                    *stack = *stack * a;
                    break;
                }
                case ineg:
                    *stack = -(*stack);
                    break;
                case instanceof:
                {
                    unsigned short index;
                    U2(index, bc, pc);
                    ClassInfo *cinfo = (ClassInfo*) cp[index];
                    ClassFile *type;
                    if (cinfo->classRef == 0) {
                        std::string name(((UTF8Info*) cp[cinfo->nameIndex])->bytes);
                        type = loader->load((char*) name.c_str(), this);
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        cinfo->classRef = type;
                        cinfo->name = name;
                    } else {
                        type = cinfo->classRef;
                    }
                    if (*stack) {
                        *stack = (int) type->instanceOf(*(JOBJECT*) stack);
                    } else {
                        *stack = 0;
                    }
                    break;
                }
                case invokeinterface:
                {
                    unsigned short int index;
                    U2(index, bc, pc);
                    pc++; //skip the count
                    pc++; //skip the 0
                    FieldMethodInfo *info = (FieldMethodInfo*) cp[index];
                    ClassInfo *cinfo = (ClassInfo*) cp[info->classIndex];
                    JCLASS type;
                    if (cinfo->classRef == 0) {
                        std::string name(((UTF8Info*) cp[cinfo->nameIndex])->bytes);
                        type = loader->load((char*) name.c_str(), this);
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        cinfo->classRef = type;
                        cinfo->name = name;
                    } else {
                        type = cinfo->classRef;
                    }
                    MethodInfo *method;
                    if (info->methodRef == 0) {
                        if (info->name.size() < 1) {
                            info->name.append(((UTF8Info*) cp[((NameAndTypeInfo*) cp[info->nameAndTypeIndex])->nameIndex])->bytes);
                            info->name.append(((UTF8Info*) cp[((NameAndTypeInfo*) cp[info->nameAndTypeIndex])->descriptorIndex])->bytes);
                        }
                        method = type->methodMap[info->name]; //uses name+descriptor
                        info->methodRef = method;
                    } else {
                        method = info->methodRef;
                    }
                    long args[method->nargs + 1]; //contains object ref
                    for (int i = 0; i < method->nargs + 1; i++)
                        args[i] = (stack - method->nargs)[i];
                    stack -= method->nargs;
                    if (!(*(JOBJECT*) stack)) {
                        JNIEnv* env = thread->getEnv();
                        debug("invokeinterface null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    JOBJECT ref = *(JOBJECT*) (stack--);
                    MethodInfo *invoked;
                    for (type = ref->type; type != 0; type = type->superClass) {
                        if (type->methodMap.find(method->full) != type->methodMap.end()) {
                            invoked = type->methodMap[method->full];
                            break;
                        }
                    }
                    debug("invokeinterface: " << method->full << " in " << type->name << '\n');
                    Variable result = execute(invoked, type, thread, args, method->nargs + 1, &exception);
                    if (exception) goto EXCEPTION_HANDLER;
                    if (method->resobject) localgc.addLocal(result.l);
                    if (method->result == 2) {
                        *(JLONG*) (++stack) = result.j;
                        stack++;
                    } else if (method->result == 1) {
                        *(JINT*) (++stack) = result.i;
                    }
                    break;
                }
                case invokespecial:
                {
                    unsigned short int index;
                    U2(index, bc, pc);
                    FieldMethodInfo *info = (FieldMethodInfo*) cp[index];
                    JCLASS type;
                    ClassInfo *cinfo = (ClassInfo*) cp[info->classIndex];
                    if (cinfo->classRef == 0) {
                        std::string name(((UTF8Info*) cp[cinfo->nameIndex])->bytes);
                        type = loader->load((char*) name.c_str(), this);
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        cinfo->classRef = type;
                        cinfo->name = name;
                    } else {
                        type = cinfo->classRef;
                    }
                    MethodInfo *method;
                    if (info->methodRef == 0) {
                        if (info->name.size() < 1) {
                            info->name.append(((UTF8Info*) cp[((NameAndTypeInfo*) cp[info->nameAndTypeIndex])->nameIndex])->bytes);
                            info->name.append(((UTF8Info*) cp[((NameAndTypeInfo*) cp[info->nameAndTypeIndex])->descriptorIndex])->bytes);
                        }
                        method = type->methodMap[info->name]; //uses name+descriptor
                        info->methodRef = method;
                    } else {
                        method = info->methodRef;
                    }
                    long args[method->nargs + 1]; //contains object ref
                    for (int i = 0; i < method->nargs + 1; i++)
                        args[i] = (stack - method->nargs)[i];
                    stack -= method->nargs;
                    if (!(*(JOBJECT*) stack)) {
                        JNIEnv* env = thread->getEnv();
                        debug("invokespecial null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    JOBJECT ref = *(JOBJECT*) (stack--);
                    Variable result;
                    if ((type->accessFlags & 0x0020) && (method->name.c_str()[0] != '<')) {
                        int found = 0;
                        for (ClassFile *c = cur->superClass; c != 0; c = c->superClass) {
                            debug("searching in " << c->name << '\n');
                            if (c->methodMap.find(method->full) != c->methodMap.end()) {
                                MethodInfo *invoked = c->methodMap[method->full];
                                debug("invokespecial: " << invoked->full << " in " << c->name << '\n');
                                result = execute(invoked, c, thread, args, method->nargs + 1, &exception);
                                found = 1;
                                break;
                            }
                        }
                        if (!found) {
                            debug("invokespecial: " << method->full << " in " << type->name << '\n');
                            result = execute(method, type, thread, args, method->nargs + 1, &exception);
                        }
                    } else {
                        debug("invokespecial: " << method->full << " in " << type->name << '\n');
                        result = execute(method, type, thread, args, method->nargs + 1, &exception);
                    }
                    if (exception) goto EXCEPTION_HANDLER;
                    if (method->resobject) localgc.addLocal(result.l);
                    if (method->result == 2) {
                        *(JLONG*) (++stack) = result.j;
                        stack++;
                    } else if (method->result == 1) {
                        *(JINT*) (++stack) = result.i;
                    }
                    break;
                }
                case invokestatic:
                {
                    unsigned short int index;
                    U2(index, bc, pc);
                    FieldMethodInfo *info = (FieldMethodInfo*) cp[index];
                    JCLASS type;
                    ClassInfo *cinfo = (ClassInfo*) cp[info->classIndex];
                    if (cinfo->classRef == 0) {
                        std::string name(((UTF8Info*) cp[cinfo->nameIndex])->bytes);
                        type = loader->load((char*) name.c_str(), this);
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        cinfo->classRef = type;
                        cinfo->name = name;
                    } else {
                        type = cinfo->classRef;
                    }
                    MethodInfo *method;
                    if (info->methodRef == 0) {
                        if (info->name.size() < 1) {
                            info->name.append(((UTF8Info*) cp[((NameAndTypeInfo*) cp[info->nameAndTypeIndex])->nameIndex])->bytes);
                            info->name.append(((UTF8Info*) cp[((NameAndTypeInfo*) cp[info->nameAndTypeIndex])->descriptorIndex])->bytes);
                        }
                        for (; type != 0; type = type->superClass) {
                            if (type->methodMap.find(info->name) != type->methodMap.end()) {
                                method = type->methodMap[info->name]; //uses name+descriptor
                                break;
                            }
                        }
                        info->methodRef = method;
                    } else {
                        method = info->methodRef;
                    }
                    long args[method->nargs];
                    for (int i = 0; i < method->nargs; i++)
                        args[i] = (stack - method->nargs + 1)[i];
                    stack -= method->nargs;
                    debug("invokestatic: " << method->full << " in " << type->name << '\n');
                    Variable result = execute(method, type, thread, args, method->nargs, &exception);
                    if (exception) goto EXCEPTION_HANDLER;
                    if (method->resobject) localgc.addLocal(result.l);
                    if (method->result == 2) {
                        *(JLONG*) (++stack) = result.j;
                        stack++;
                    } else if (method->result == 1) {
                        *(JINT*) (++stack) = result.i;
                    }
                    break;
                }
                case invokevirtual:
                {
                    unsigned short int index;
                    U2(index, bc, pc);
                    FieldMethodInfo *info = (FieldMethodInfo*) cp[index];
                    MethodInfo *method;
                    ClassInfo *cinfo = (ClassInfo*) cp[info->classIndex];
                    JCLASS type;
                    if (cinfo->classRef == 0) {
                        std::string name(((UTF8Info*) cp[cinfo->nameIndex])->bytes);
                        type = loader->load((char*) name.c_str(), this);
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        cinfo->classRef = type;
                        cinfo->name = name;
                    } else {
                        type = cinfo->classRef;
                    }
                    if (info->methodRef == 0) {
                        if (info->name.size() < 1) {
                            info->name.append(((UTF8Info*) cp[((NameAndTypeInfo*) cp[info->nameAndTypeIndex])->nameIndex])->bytes);
                            info->name.append(((UTF8Info*) cp[((NameAndTypeInfo*) cp[info->nameAndTypeIndex])->descriptorIndex])->bytes);
                        }
                        for (; type != 0; type = type->superClass) {
                            if (type->methodMap.find(info->name) != type->methodMap.end()) {
                                method = type->methodMap[info->name]; //uses name+descriptor
                                break;
                            }
                        }
                        info->methodRef = method;
                    } else {
                        method = info->methodRef;
                    }
                    long args[method->nargs + 1]; //contains object ref
                    for (int i = 0; i < method->nargs + 1; i++)
                        args[i] = (stack - method->nargs)[i];
                    stack -= method->nargs;
                    if (!(*(JOBJECT*) stack)) {
                        JNIEnv* env = thread->getEnv();
                        debug("invokevirtual null\n");
                        debug(method->name << '\n');
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    JOBJECT ref = *(JOBJECT*) (stack--);
                    for (type = ref->type; type != 0; type = type->superClass) {
                        if (type->methodMap.find(method->full) != type->methodMap.end()) {
                            debug("invokevirtual: " << method->full << " in " << type->name << '\n');
                            MethodInfo *invoked = type->methodMap[method->full];
                            Variable result = execute(invoked, type, thread, args, method->nargs + 1, &exception);
                            if (exception) goto EXCEPTION_HANDLER;
                            if (method->resobject) localgc.addLocal(result.l);
                            if (method->result == 2) {
                                *(JLONG*) (++stack) = result.j;
                                stack++;
                            } else if (method->result == 1) {
                                *(JINT*) (++stack) = result.i;
                            }
                            break;
                        }
                    }
                    break;
                }
                case ior:
                {
                    JINT a = *(JINT*) (stack--);
                    *(JINT*) stack = *(JINT*) stack | a;
                    break;
                }
                case irem:
                {
                    JINT a = *(JINT*) (stack--);
                    if (a == 0) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArithmeticException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    *(JINT*) stack = (*(JINT*) stack) % a;
                    debug("irem: " << *stack << '\n');
                    break;
                }
                case ireturn:
                {
                    Variable result;
                    result.i = *(JINT*) stack;
                    return result;
                }
                case ishl:
                {
                    int sh = *(stack--);
                    *stack = *stack << sh;
                    break;
                }
                case ishr:
                {
                    int sh = *(stack--);
                    *stack = *stack >> sh;
                    break;
                }
                case istore:
                    locals[bc[pc++]] = *stack;
                    stack--;
                    break;
                case istore_0:
                    locals[0] = *stack;
                    stack--;
                    break;
                case istore_1:
                    locals[1] = *stack;
                    stack--;
                    break;
                case istore_2:
                    locals[2] = *stack;
                    stack--;
                    break;
                case istore_3:
                    locals[3] = *stack;
                    stack--;
                    break;
                case isub:
                {
                    JINT a = *(stack--);
                    *stack = *stack - a;
                    break;
                }
                case iushr:
                {
                    int sh = *(stack--);
                    *(unsigned int*) stack = *(unsigned int*) stack >> sh;
                    break;
                }
                case ixor:
                {
                    JINT a = *(stack--);
                    *stack = *stack ^ a;
                    break;
                }
                case jsr:
                {
                    int orig = pc - 1;
                    short int offset;
                    U2(offset, bc, pc);
                    *(++stack) = pc;
                    pc = orig + offset;
                    break;
                }
                case jsr_w:
                {
                    int orig = pc - 1;
                    long int offset;
                    U4(offset, bc, pc);
                    *(++stack) = pc;
                    pc = orig + offset;
                    break;
                }
                case l2d:
                    *(JDOUBLE*) (stack - 1) = (JDOUBLE) *(JLONG*) (stack - 1);
                    break;
                case l2f:
                    *(JFLOAT*) (stack - 1) = (JFLOAT) *(JLONG*) (stack - 1);
                    stack--;
                    break;
                case l2i:
                    *(JINT*) (stack - 1) = (JINT) *(JLONG*) (stack - 1);
                    stack--;
                    break;
                case ladd:
                {
                    JLONG a = *(JLONG*) (stack - 1);
                    stack -= 2;
                    *(JLONG*) (stack - 1) = *(JLONG*) (stack - 1) + a;
                    debug("ladd: " << *(JLONG*) (stack - 1) << '\n');
                    break;
                }
                case laload:
                {
                    int pos = *(stack--);
                    JLONGARRAY array = (JLONGARRAY) * stack;
                    if (!array) {
                        JNIEnv* env = thread->getEnv();
                        debug("laload null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    if (pos < 0 || pos >= array->size) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "(I)V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id, pos);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    *(JLONG*) stack = array->array[pos];
                    stack++;
                    break;
                }
                case land:
                {
                    JLONG a = *(JLONG*) (stack - 1);
                    stack -= 2;
                    *(JLONG*) (stack - 1) = *(JLONG*) (stack - 1) & a;
                    break;
                }
                case lastore:
                {
                    JLONG l = *(JLONG*) (stack - 1);
                    stack -= 2;
                    int pos = *(stack--);
                    JLONGARRAY array = (JLONGARRAY) *(stack--);
                    if (!array) {
                        JNIEnv* env = thread->getEnv();
                        debug("lastore null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    if (pos < 0 || pos >= array->size) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "(I)V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id, pos);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    array->array[pos] = l;
                    break;
                }
                case lcmp:
                {
                    JLONG b = *(JLONG*) (stack - 1);
                    stack -= 2;
                    JLONG a = *(JLONG*) (stack - 1);
                    stack -= 2;
                    if (a < b) *(++stack) = -1;
                    if (a = b) *(++stack) = 0;
                    if (a > b) *(++stack) = 1;
                    break;
                }
                case lconst_0:
                    *(JLONG*) (++stack) = (JLONG) 0;
                    stack++;
                    break;
                case lconst_1:
                    *(JLONG*) (++stack) = (JLONG) 1;
                    stack++;
                    break;
                case ldc:
                {
                    CPInfo *info = cp[bc[pc++]];
                    debug("ldc: ");
                    switch (info->type) {
                        case CPInfo::CONSTANT_Float :
                        {
                            unsigned int bits = *(unsigned int*) ((IntegerFloatInfo*) info)->data;
                            int s = ((bits >> 31) == 0) ? 1 : -1;
                            int e = ((bits >> 23) & 0xff);
                            int m = (e == 0) ?
                                    (bits & 0x7fffff) << 1 :
                                    (bits & 0x7fffff) | 0x800000;
                            *(JFLOAT*) (++stack) = (float) s * (float) m * pow((float) 2, e - 150);
                            debug(*(JFLOAT*) stack << '\n');
                            break;
                        }
                        case CPInfo::CONSTANT_Integer :
                        {
                            *(JINT*) (++stack) = *(JINT*) ((IntegerFloatInfo*) info)->data;
                            debug(*(JINT*) stack << '\n');
                            break;
                        }
                        case CPInfo::CONSTANT_String :
                        {
                            unsigned char* bytes = (unsigned char*) ((UTF8Info*) cp[((StringInfo*) info)->stringIndex])->bytes;
                            std::string cstr((const char*) bytes);
                            if (strings.find(cstr) != strings.end()) {
                                *(JOBJECT*) (++stack) = strings[cstr];
                            } else {
                                JCLASS jstring = loader->load("java/lang/String", this);
                                if (thread->nativeException) goto EXCEPTION_HANDLER;
                                JOBJECT sobj = jstring->newInstance(this);
                                int len = 0;
                                for (int i = 0; i < cstr.length();) {
                                    if ((bytes[i] & 0x80) == 0) {
                                        len++;
                                        i++;
                                    } else if ((bytes[i] & 0xE0) == 0xC0) {
                                        len += 2;
                                        i += 2;
                                    } else if ((bytes[i] & 0xF0) == 0xE0) {
                                        len += 3;
                                        i += 3;
                                    }
                                }
                                debug(len << '\n');
                                JCHARARRAY chars = ClassFile::newArray<JCHAR>(this,(char*)"[C",len);
                                JCHAR* array = chars->array;
                                gc->incrRef(chars);
                                sobj->fields[jstring->fieldMap["value"]->index].l = chars;
                                for (int i = 0, c = 0; i < len; i++) {
                                    if ((bytes[c] & 0x80) == 0x00) {
                                        array[i] = bytes[c];
                                        c++;
                                    } else if ((bytes[c] & 0xE0) == 0xC0) {
                                        array[i] = ((bytes[c] & 0x1F) << 6) + (bytes[c + 1] & 0x3F);
                                        c += 2;
                                    } else if ((bytes[c] & 0xF0) == 0xE0) {
                                        array[i] = ((bytes[c] & 0xF) << 12) + ((bytes[c + 1] & 0x3F) << 6) + (bytes[c + 2] & 0x3F);
                                        c += 3;
                                    }
                                }
                                sobj->fields[jstring->fieldMap["offset"]->index].i = 0;
                                sobj->fields[jstring->fieldMap["count"]->index].i = len;
                                strings[cstr] = sobj;
                                gc->incrPersist(sobj);
                                *(JOBJECT*) (++stack) = sobj;
                                localgc.addLocal(*(JOBJECT*) stack);
                            }
                        }
                    }
                    break;
                }
                case ldc_w:
                {
                    unsigned short int index;
                    U2(index, bc, pc);
                    CPInfo *info = cp[index];
                    debug("ldc_w: ");
                    switch (info->type) {
                        case CPInfo::CONSTANT_Float :
                        case CPInfo::CONSTANT_Integer :
                                    *(JINT*) (++stack) = *(JINT*) ((IntegerFloatInfo*) info)->data;
                            debug(*(JFLOAT*) stack << '\n');
                            break;
                        case CPInfo::CONSTANT_String :
                                    unsigned char* bytes = (unsigned char*) ((UTF8Info*) cp[((StringInfo*) info)->stringIndex])->bytes;
                            std::string cstr((const char*) bytes);
                            if (strings.find(cstr) != strings.end()) {
                                *(JOBJECT*) (++stack) = strings[cstr];
                            } else {
                                JCLASS jstring = loader->load("java/lang/String", this);
                                if (thread->nativeException) goto EXCEPTION_HANDLER;
                                JOBJECT sobj = jstring->newInstance(this);
                                int len = 0;
                                for (int i = 0; i < cstr.length();) {
                                    if ((bytes[i] & 0x80) == 0) {
                                        len++;
                                        i++;
                                    } else if ((bytes[i] & 0xE0) == 0xC0) {
                                        len += 2;
                                        i += 2;
                                    } else if ((bytes[i] & 0xF0) == 0xE0) {
                                        len += 3;
                                        i += 3;
                                    }
                                }
                                JCHARARRAY chars = ClassFile::newArray<JCHAR>(this,(char*)"[C",len);
                                JCHAR* array = chars->array;
                                gc->incrRef(chars);
                                sobj->fields[jstring->fieldMap["value"]->index].l = chars;
                                for (int i = 0, c = 0; i < len; i++) {
                                    if ((bytes[c] & 0x80) == 0x00) {
                                        array[i] = bytes[c];
                                        c++;
                                    } else if ((bytes[c] & 0xE0) == 0xC0) {
                                        array[i] = ((bytes[c] & 0x1F) << 6) + (bytes[c + 1] & 0x3F);
                                        c += 2;
                                    } else if ((bytes[c] & 0xF0) == 0xE0) {
                                        array[i] = ((bytes[c] & 0xF) << 12) + ((bytes[c + 1] & 0x3F) << 6) + (bytes[c + 2] & 0x3F);
                                        c += 3;
                                    }
                                }
                                sobj->fields[jstring->fieldMap["offset"]->index].i = 0;
                                sobj->fields[jstring->fieldMap["count"]->index].i = len;
                                strings[cstr] = sobj;
                                gc->incrPersist(sobj);
                                *(JOBJECT*) (++stack) = sobj;
                                localgc.addLocal(*(JOBJECT*) stack);
                            }
                    }
                    break;
                }
                case ldc2_w:
                {
                    unsigned short int index;
                    U2(index, bc, pc);
                    CPInfo *info = cp[index];
                    debug("ldc2_w: ");
                    switch (info->type) {
                        case CPInfo::CONSTANT_Long :
                                    *(JLONG*) (++stack) = *(JLONG*) ((LongDoubleInfo*) info)->data;
                            stack++;
                            debug(*(JLONG*) (stack - 1) << '\n');
                            break;
                        case CPInfo::CONSTANT_Double :
                                    unsigned long long bits = *(unsigned long long*) ((LongDoubleInfo*) info)->data;
                            int s = ((bits >> 63) == 0) ? 1 : -1;
                            int e = (int) ((bits >> 52) & 0x7ffL);
                            long long m = (e == 0) ?
                                    (bits & 0xfffffffffffffLLU) << 1 :
                                    (bits & 0xfffffffffffffLLU) | 0x10000000000000LLU;
                            *(JDOUBLE*) (++stack) = s * m * pow(2, e - 1075);
                            stack++;
                            debug(*(JDOUBLE*) (stack - 1) << '\n');
                            break;
                    }
                    break;
                }
                case ldiv:
                {
                    JLONG a = *(JLONG*) (stack - 1);
                    if (a == 0) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArithmeticException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    stack -= 2;
                    *(JLONG*) (stack - 1) = *(JLONG*) (stack - 1) / a;
                    break;
                }
                case lload:
                    *(JLONG*) (++stack) = *(JLONG*) & locals[bc[pc++]];
                    stack++;
                    break;
                case lload_0:
                    *(JLONG*) (++stack) = *(JLONG*) & locals[0];
                    stack++;
                    break;
                case lload_1:
                    *(JLONG*) (++stack) = *(JLONG*) & locals[1];
                    stack++;
                    break;
                case lload_2:
                    *(JLONG*) (++stack) = *(JLONG*) & locals[2];
                    stack++;
                    break;
                case lload_3:
                    *(JLONG*) (++stack) = *(JLONG*) & locals[3];
                    stack++;
                    break;
                case lmul:
                {
                    JLONG a = *(JLONG*) (stack - 1);
                    stack -= 2;
                    *(JLONG*) (stack - 1) = *(JLONG*) (stack - 1) * a;
                    break;
                }
                case lneg:
                    *(JLONG*) (stack - 1) = -(*(JLONG*) (stack - 1));
                    break;
                case lookupswitch:
                {
                    int orig = pc - 1;
                    pc += (4 - pc % 4) & 3; //4byte allign
                    int defa;
                    U4(defa, bc, pc);
                    int npairs;
                    U4(npairs, bc, pc);
                    npairs *= 8;
                    int k = *(stack--);
                    int v, offset;
                    for (int i = pc; i < npairs + pc; i += 4) {
                        U4(v, bc, i);
                        if (k == v) {
                            U4(offset, bc, i);
                            pc = orig + offset;
                            goto done;
                        }
                    }
                    pc = orig + defa;
done:
                    debug("lookupswitch: " << k << '\n');
                    break;
                }
                case lor:
                {
                    JLONG a = *(JLONG*) (stack - 1);
                    stack -= 2;
                    *(JLONG*) (stack - 1) = *(JLONG*) (stack - 1) | a;
                    break;
                }
                case lrem:
                {
                    JLONG a = *(JLONG*) (stack - 1);
                    if (a == 0) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArithmeticException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    stack -= 2;
                    *(JLONG*) (stack - 1) = *(JLONG*) (stack - 1) % a;
                    debug("lrem: " << *(JLONG*) (stack - 1) << '\n');
                    break;
                }
                case lreturn:
                {
                    Variable result;
                    result.j = *(JLONG*) (stack - 1);
                    return result;
                }
                case lshl:
                {
                    int sh = *(stack--);
                    *(JLONG*) (stack - 1) = *(JLONG*) (stack - 1) << sh;
                    break;
                }
                case lshr:
                {
                    int sh = *(stack--);
                    *(JLONG*) (stack - 1) = *(JLONG*) (stack - 1) >> sh;
                    break;
                }
                case lstore:
                    *(JLONG*) & locals[bc[pc++]] = *(JLONG*) (stack - 1);
                    stack -= 2;
                    break;
                case lstore_0:
                    *(JLONG*) & locals[0] = *(JLONG*) (stack - 1);
                    stack -= 2;
                    break;
                case lstore_1:
                    *(JLONG*) & locals[1] = *(JLONG*) (stack - 1);
                    stack -= 2;
                    break;
                case lstore_2:
                    debug("lstore_2: " << *(JLONG*) (stack - 1) << '\n');
                    *(JLONG*) &locals[2] = *(JLONG*) (stack - 1);
                    stack -= 2;
                    break;
                case lstore_3:
                    *(JLONG*) & locals[3] = *(JLONG*) (stack - 1);
                    stack -= 2;
                    break;
                case lushr:
                {
                    int sh = *(stack--);
                    *(unsigned JLONG*) (stack - 1) = *(unsigned JLONG*) (stack - 1) >> sh;
                    break;
                }
                case lsub:
                {
                    JLONG a = *(JLONG*) (stack - 1);
                    stack -= 2;
                    *(JLONG*) (stack - 1) = *(JLONG*) (stack - 1) - a;
                    break;
                }
                case lxor:
                {
                    JLONG a = *(JLONG*) (stack - 1);
                    stack -= 2;
                    *(JLONG*) (stack - 1) = *(JLONG*) (stack - 1) ^ a;
                    break;
                }
                case monitorenter:
                    if (!(*(JOBJECT*) stack)) {
                        JNIEnv* env = thread->getEnv();
                        debug("monitorenter null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    (*(JOBJECT*) stack--)->mutex.lock();
                    debug("Monitor Enter\n");
                    break;
                case monitorexit:
                    if (!(*(JOBJECT*) stack)) {
                        JNIEnv* env = thread->getEnv();
                        debug("monitorexit null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    (*(JOBJECT*) stack--)->mutex.unlock();
                    debug("Monitor Exit\n");
                    break;
                case multianewarray:
                {
                    debug("Multi A New Array\n");
                    JNIEnv* env = thread->getEnv();
                    env->FatalError("MultiANewArray not implemented");
                    break;
                }
                case newobj:
                {
                    unsigned short index;
                    U2(index, bc, pc);
                    ClassInfo *cinfo = (ClassInfo*) cp[index];
                    ClassFile* type;
                    if (cinfo->classRef == 0) {
                        type = loader->load(((UTF8Info*) cp[cinfo->nameIndex])->bytes, this);
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        cinfo->classRef = type;
                        std::string name(((UTF8Info*) cp[cinfo->nameIndex])->bytes);
                        cinfo->name = name;
                    } else {
                        type = cinfo->classRef;
                    }
                    debug("new: " << cinfo->name << '\n');
                    *(JOBJECT*) (++stack) = type->newInstance(this);
                    localgc.addLocal(*(JOBJECT*) stack);
                    break;
                }
                case newarray:
                {
                    int size = *(stack--);
                    if (size < 0) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/NegativeArraySizeException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    JOBJECT array;
                    switch (bc[pc++]) {
                        case 4:
                            array = ClassFile::newArray<JBOOLEAN>(this,(char*)"[Z",size);
                            break;
                        case 5:
                            array = ClassFile::newArray<JCHAR>(this,(char*)"[C",size);
                            break;
                        case 6:
                            array = ClassFile::newArray<JFLOAT>(this,(char*)"[F",size);
                            break;
                        case 7:
                            array = ClassFile::newArray<JDOUBLE>(this,(char*)"[D",size);
                            break;
                        case 8:
                            array = ClassFile::newArray<JBYTE>(this,(char*)"[B",size);
                            break;
                        case 9:
                            array = ClassFile::newArray<JSHORT>(this,(char*)"[S",size);
                            break;
                        case 10:
                            array = ClassFile::newArray<JINT>(this,(char*)"[I",size);
                            break;
                        case 11:
                            array = ClassFile::newArray<JLONG>(this,(char*)"[J",size);
                            break;
                    }
                    if (thread->nativeException) goto EXCEPTION_HANDLER;
                    *(JOBJECT*) (++stack) = array;
                    localgc.addLocal(*(JOBJECT*) stack);
                    break;
                }
                case nop:
                    break;
                case pop:
                    stack--;
                    break;
                case pop2:
                    stack -= 2;
                    break;
                case putfield:
                {
                    unsigned short int index;
                    U2(index, bc, pc);
                    FieldMethodInfo *info = (FieldMethodInfo*) cp[index];
                    FieldInfo *field;
                    JCLASS type;
                    ClassInfo *cinfo = (ClassInfo*) cp[info->classIndex];
                    if (cinfo->classRef == 0) {
                        std::string name(((UTF8Info*) cp[cinfo->nameIndex])->bytes);
                        type = loader->load((char*) name.c_str(), this);
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        cinfo->classRef = type;
                        cinfo->name = name;
                    } else {
                        type = cinfo->classRef;
                    }
                    if (info->fieldRef == 0) {
                        if (info->name.size() < 1)
                            info->name.append(((UTF8Info*) cp[((NameAndTypeInfo*) cp[info->nameAndTypeIndex])->nameIndex])->bytes);
                        field = 0;
                        for (JCLASS find = type; find != 0 && field == 0; find = find->superClass)
                            if (find->fieldMap.find(info->name) != find->fieldMap.end())
                                field = find->fieldMap[info->name];
                        info->fieldRef = field;
                    } else {
                        field = info->fieldRef;
                    }
                    debug("putfield: " << field->descriptor << " " << field->name << '\n');
                    if (!(*(JOBJECT*) (stack - 1))) {
                        JNIEnv* env = thread->getEnv();
                        debug("putfield null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    switch (field->descriptor.c_str()[0]) {
                        case 'D':
                        case 'J':
                            (*(JOBJECT*) (stack - 2))->fields[field->index].j = *(JLONG*) (stack - 1);
                            stack -= 3;
                            break;
                        case 'L':
                        case '[':
                        {
                            JOBJECT old = (*(JOBJECT*) (stack - 1))->fields[field->index].l;
                            if (old) gc->decrRef(old);
                            (*(JOBJECT*) (stack - 1))->fields[field->index].i = *stack;
                            gc->incrRef(*(JOBJECT*) stack);
                            stack -= 2;
                            break;
                        }
                        default:
                            (*(JOBJECT*) (stack - 1))->fields[field->index].i = *stack;
                            stack -= 2;
                    }
                    break;
                }
                case putstatic:
                {
                    unsigned short int index;
                    U2(index, bc, pc);
                    FieldMethodInfo *info = (FieldMethodInfo*) cp[index];
                    FieldInfo *field;
                    if (info->fieldRef == 0) {
                        ClassInfo *cinfo = (ClassInfo*) cp[info->classIndex];
                        JCLASS type;
                        if (cinfo->classRef == 0) {
                            std::string name(((UTF8Info*) cp[cinfo->nameIndex])->bytes);
                            type = loader->load((char*) name.c_str(), this);
                            if (thread->nativeException) goto EXCEPTION_HANDLER;
                            cinfo->classRef = type;
                            cinfo->name = name;
                        } else {
                            type = cinfo->classRef;
                        }
                        if (info->name.size() < 1)
                            info->name.append(((UTF8Info*) cp[((NameAndTypeInfo*) cp[info->nameAndTypeIndex])->nameIndex])->bytes);
                        field = 0;
                        for (JCLASS find = type; find != 0 && field == 0; find = find->superClass)
                            if (find->fieldMap.find(info->name) != find->fieldMap.end())
                                field = find->fieldMap[info->name];
                        info->fieldRef = field;
                    } else {
                        field = info->fieldRef;
                    }
                    debug("putfield: " << field->descriptor << " " << field->name << '\n');
                    switch (field->descriptor.c_str()[0]) {
                        case 'D':
                        case 'J':
                            field->staticValue.j = *(JLONG*) (stack - 1);
                            stack -= 2;
                            break;
                        case 'L':
                        case '[':
                            if (field->staticValue.l)
                                gc->decrPersist(field->staticValue.l);
                            field->staticValue.i = *(stack--);
                            gc->incrPersist(field->staticValue.l);
                            break;
                        default:
                            field->staticValue.i = *(stack--);
                    }
                    break;
                }
                case ret:
                    pc = locals[bc[pc++]];
                    break;
                case vreturn:
                    Variable result;
                    return result;
                case saload:
                {
                    int pos = *(stack--);
                    JSHORTARRAY array = (JSHORTARRAY) * stack;
                    if (!array) {
                        JNIEnv* env = thread->getEnv();
                        debug("saload null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    if (pos < 0 || pos >= array->size) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "(I)V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id, pos);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    *stack = array->array[pos];
                    break;
                }
                case sastore:
                {
                    JSHORT s = *(stack--);
                    int pos = *(stack--);
                    JSHORTARRAY array = (JSHORTARRAY) *(stack--);
                    if (!array) {
                        JNIEnv* env = thread->getEnv();
                        debug("sastore null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    if (pos < 0 || pos >= array->size) {
                        JNIEnv* env = thread->getEnv();
                        jclass clazz = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "(I)V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id, pos);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    array->array[pos] = s;
                    break;
                }
                case sipush:
                {
                    JSHORT s;
                    U2(s, bc, pc);
                    *(++stack) = s;
                    break;
                }
                case swap:
                {
                    int temp = *stack;
                    *stack = *(stack - 1);
                    *(stack - 1) = temp;
                }
                case tableswitch:
                {
                    int orig = pc - 1;
                    pc += (4 - pc % 4) & 3; //4byte allign
                    int defoff;
                    U4(defoff, bc, pc);
                    int low;
                    U4(low, bc, pc);
                    int high;
                    U4(high, bc, pc);
                    int count = high - low + 1;
                    int index = *(stack--);
                    if (index <= high && index >= low) {
                        int offset;
                        int pos = pc + (index - low)*4;
                        U4(offset, bc, pos);
                        pc = orig + offset;
                    } else {
                        pc = orig + defoff;
                    }
                    debug("tableswitch: " << index << '\n');
                    break;
                }
                case wide:
                    switch (bc[pc++]) {
                        case aload:
                        {
                            unsigned int index;
                            U2(index, bc, pc);
                            *(++stack) = locals[index];
                            break;
                        }
                        case iload:
                        case fload:
                        {
                            unsigned int index;
                            U2(index, bc, pc);
                            *(++stack) = locals[index];
                            break;
                        }
                        case dload:
                        case lload:
                        {
                            unsigned int index;
                            U2(index, bc, pc);
                            *(JLONG*) (++stack) = *(JLONG*) & locals[index];
                            stack++;
                            break;
                        }
                        case astore:
                        case istore:
                        case fstore:
                        {
                            unsigned int index;
                            U2(index, bc, pc);
                            locals[index] = *(stack--);
                            break;
                        }
                        case dstore:
                        case lstore:
                        {
                            unsigned int index;
                            U2(index, bc, pc);
                            *(JLONG*) & locals[index] = *(JLONG*) (stack - 1);
                            stack -= 2;
                            break;
                        }
                        case ret:
                        {
                            unsigned int index;
                            U2(index, bc, pc);
                            pc = locals[index];
                            break;
                        }
                        case iinc:
                        {
                            unsigned short int index;
                            U2(index, bc, pc);
                            short int value;
                            U2(value, bc, pc);
                            locals[index] += value;
                            break;
                        }
                    }
                    break;
                case athrow:
                {
                    if (!(*(JOBJECT*) stack)) {
                        JNIEnv* env = thread->getEnv();
                        debug("athrow null\n");
                        jclass clazz = env->FindClass("java/lang/NullPointerException");
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        jmethodID id = env->GetMethodID(clazz, "<init>", "()V");
                        JOBJECT obj = (JOBJECT) env->NewObject(clazz, id);
                        exception = new Exception(cur, meth, obj);
                        gc->incrPersist(exception->cause);
                        goto EXCEPTION_HANDLER;
                    }
                    exception = new Exception(cur, meth, *(JOBJECT*) (stack--));
                    gc->incrPersist(exception->cause);
                    goto EXCEPTION_HANDLER;
                }
                default:
                    warn("Unknown Code --- Ignoring\n");
            }
            continue;
EXCEPTION_HANDLER:
            if (thread->nativeException) {
                exception = thread->nativeException;
                thread->nativeException = 0;
            }
            debug("Exception Detected " << (exception->cause ? exception->cause->type->name : "Native") << '\n');
            unsigned short count = meth->code->exceptionCount;
            ExceptionEntry **entries = meth->code->exceptions;
            for (int i = 0; i < count; i++) {
                debug(entries[i]->startPC << '<' << pc << '<' << entries[i]->endPC << '\n');
                if (pc >= entries[i]->startPC && pc <= entries[i]->endPC) {
                    if (entries[i]->catchType == 0) {
                        pc = entries[i]->handlerPC;
                        goto EXCEPTION_CONTINUE;
                    }
                    ClassInfo *cinfo = (ClassInfo*) cp[entries[i]->catchType];
                    ClassFile *type;
                    if (cinfo->classRef == 0) {
                        std::string name(((UTF8Info*) cp[cinfo->nameIndex])->bytes);
                        type = loader->load((char*) name.c_str(), this);
                        if (thread->nativeException) goto EXCEPTION_HANDLER;
                        cinfo->classRef = type;
                        cinfo->name = name;
                    } else {
                        type = cinfo->classRef;
                    }
                    JOBJECT cause = exception->cause;
                    if (type->instanceOf(cause)) {
                        pc = entries[i]->handlerPC;
                        goto EXCEPTION_CONTINUE;
                    }
                }
            }
            *thrown = new Exception(cur, meth, exception);
            debug("Throwing Exeption: " << (exception->cause ? exception->cause->type->name : "Native") << '\n');
            Variable result;
            return result; //meaningless result
EXCEPTION_CONTINUE:
            localgc.addLocal(exception->cause);
            gc->decrPersist(exception->cause);
            *(JOBJECT*) (++stack) = exception->cause;
            delete exception;
            debug("Exception Caught Entering Handler");
            continue;
        }
    }
}
#include "Thread.h"
#include "SJVM.h"

#include <iostream>
#include <pthread.h>
#include <cstring>

#define DEBUG_OUTPUT

#ifdef DEBUG_OUTPUT
#define debug(v) std::cout << v;
#else
#define debug(v)
#endif

Thread::Thread(SJVM *_sjvm) : sjvm(_sjvm), nativeException(0) {
    debug("Thread Entered\n");
    jnienv = new JNIEnv;
    JNINativeInterface_ *functions = new JNINativeInterface_;
    memcpy(functions, &SJVM_JNINativeInterface, sizeof(JNINativeInterface_));
    functions->reserved0 = sjvm;
    functions->reserved1 = this;
    jnienv->functions = functions;
    id = pthread_self();
    sjvm->threads[id] = this;
    nativeLocal = 0;
    new LocalGC(sjvm->gc,this); //Perisistes until gc is destroyed... not so smart
    sjvm->gc->objects.insert(this);
    nativeLocal->addLocal(this);
}

Thread::~Thread() {
    debug("Thread Exited\n");
    sjvm->threads.erase(id);
    delete jnienv->functions;
    delete jnienv;
}

Thread* Thread::getThread(SJVM *sjvm) {
    unsigned int id = pthread_self();
    if (sjvm->threads.find(id) == sjvm->threads.end()) {
        return new Thread(sjvm);
    }
    return sjvm->threads[id];
}

JNIEnv* Thread::getEnv() {
    return jnienv;
}

void Thread::start() {
    
}
